<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>《NoSQL精粹》读书笔记 | 张先森的代码小屋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="NoSQL">
  
  
  
  
  <meta name="description" content="本文是《NoSQL精粹》的读书笔记。">
<meta name="keywords" content="NoSQL">
<meta property="og:type" content="article">
<meta property="og:title" content="《NoSQL精粹》读书笔记">
<meta property="og:url" content="https://nullcc.github.io/2017/05/09/《NoSQL精粹》读书笔记/index.html">
<meta property="og:site_name" content="张先森的代码小屋">
<meta property="og:description" content="本文是《NoSQL精粹》的读书笔记。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2022-04-15T03:41:13.027Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《NoSQL精粹》读书笔记">
<meta name="twitter:description" content="本文是《NoSQL精粹》的读书笔记。">
  
    <link rel="alternate" href="/atom.xml" title="张先森的代码小屋" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="124px" height="124px" alt="Hike News" src=" /css/images/logo.jpg">
              </a>
            
          </h1>
          
          
            <div class="site-description">明镜止水</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-《NoSQL精粹》读书笔记" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      《NoSQL精粹》读书笔记
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/05/09/《NoSQL精粹》读书笔记/" class="article-date">
	  <time datetime="2017-05-08T16:00:00.000Z" itemprop="datePublished">五月 9, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/读书笔记/">读书笔记</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文是《NoSQL精粹》的读书笔记。</p>
<a id="more"></a>
<p>NoSQL数据库数据模型的一般分类：</p>
<ol>
<li>键值数据模型</li>
<li>文档数据模型</li>
<li>列族数据模型</li>
<li>图数据模型</li>
</ol>
<p>常见NoSQL数据库：</p>
<p>Redis, Cassandra, MongoDB, Neo4J, Riak…</p>
<p>数据库应用趋势：</p>
<ol>
<li><p>由于数据量越来越大，大型系统的扩展方式由数据库在单一计算机上的纵向扩展-&gt;在计算机集群中的横向扩展</p>
</li>
<li><p>混合持久化(关系型数据库 + NoSQL数据库)</p>
</li>
</ol>
<h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><h3 id="第1章-为什么使用NoSQL"><a href="#第1章-为什么使用NoSQL" class="headerlink" title="第1章 为什么使用NoSQL"></a>第1章 为什么使用NoSQL</h3><ul>
<li><p>关系型数据库和应用程序之间的“阻抗不匹配”。关系模型和应用程序程序中内存数据结构的不一致导致这种状况，因此涌现出很多对象-关系映射(ORM)框架，但滥用ORM可能会导致性能问题。</p>
</li>
<li><p>“集成数据库”和“应用程序数据库”，前者是一种多应用程序分享使用同一数据库的方式，特点是所有应用程序都可以获得自己想要的东西，但由于要兼容所有应用程序，因此数据库的设计可能会过分复杂导致不好维护，并且也需要应对系型数据库和应用程序之间的“阻抗不匹配”。后者衍生除了web服务，应用程序之间以接口的方式进行交互，通常使用XML或JSON来交换数据，此时就可以使用结构丰富的数据格式(数组、嵌套结构等)了。</p>
</li>
<li><p>web服务经常使用传输文本信息的HTTP协议，对一些性能要求较高的情况，可以使用二进制协议。</p>
</li>
<li><p>关系型数据库和计算机集群的格格不入。关系型数据库能把数据划分为几个集合，分别部署在各自独立的服务器上运行，这可以有效地对数据库分片。但这么做也有缺点，应用程序必须控制所有分片，它要知道数据库中的每份小数据存放在哪里才行。而且，查询、参照完整性、事务、一致性控制等操作也无法再跨分片的环境下执行。</p>
</li>
<li><p>在集群中使用关系型数据库有可能遇到成本的问题(商用关系型数据库一般按服务器台数计费)。</p>
</li>
<li><p>出现了以谷歌和亚马逊为首的典型计算机集群用户，为此谷歌研发了BigTable，亚马逊则是Dynamo。</p>
</li>
<li><p>混合持久化需要把集成数据库迁移到应用程序数据库上，一般来说，应用程序数据库都可以采用NoSQL数据库，但集成数据库不适合使用NoSQL数据库。企业可以考虑把原来存放在集成数据库中的数据转移到各个应用程序数据库，然后使用web服务来连接这些系统。这既降低了应用之间的耦合度，也降低了成本和维护难度。</p>
</li>
<li><p>选用NoSQL数据库的两个主要原因：</p>
</li>
</ul>
<ol>
<li>待处理的数据量很大，对数据访问的效率要求很高，从而必须把数据放在集群上。</li>
<li>希望采用一种更为方便的数据交互方式来提高应用程序的开发效率。</li>
</ol>
<ul>
<li>NoSQL的特征：</li>
</ul>
<ol>
<li>不使用关系模型</li>
<li>在集群中运行良好</li>
<li>开源</li>
<li>适用于21世纪的互联网公司</li>
<li>无模式</li>
</ol>
<h3 id="第2章-聚合数据模型"><a href="#第2章-聚合数据模型" class="headerlink" title="第2章 聚合数据模型"></a>第2章 聚合数据模型</h3><ul>
<li><p>聚合结构可以把关联数据直接嵌入在某个聚合中，从而方便查找。聚合使数据库在集群上管理数据存储更为方便。</p>
</li>
<li><p>对某些数据交互有用的聚合结构，可能会阻碍另一些数据交互。在对数据建模时，需要考虑到哪种场景占主导地位，据此来设计数据聚合的方式。</p>
</li>
<li><p>选用面向聚合模型的决定性因素，就是它很适合在集群上运行。我们需要把采集数据时所需的节点数将至最小。如果在数据库中明确包含聚合结构，那么数据库就知道这些数据就会被一起操作，并放在同一节点中。</p>
</li>
<li><p>通常情况下，面向聚合的数据库不支持跨越多个聚合的ACID事务。聚合是作为交互单元的数据集合，数据库中的ACID操作以聚合为界。</p>
</li>
<li><p>键值数据库、文档数据库、列族数据库都属于面向聚合的数据库。</p>
</li>
<li><p>如果数据交互大都在同一聚合内执行，则应使用面向聚合的数据库；如果数据交互操作需要使用多种不同格式的数据，那么最好选用“聚合无知式数据库”。</p>
</li>
</ul>
<h3 id="第3章-数据模型详解"><a href="#第3章-数据模型详解" class="headerlink" title="第3章 数据模型详解"></a>第3章 数据模型详解</h3><h4 id="图数据库"><a href="#图数据库" class="headerlink" title="图数据库"></a>图数据库</h4><ul>
<li><p>常见的图数据库有：FlockDB, Neo4J, Infinite Graph。</p>
</li>
<li><p>图数据库对于处理复杂关系的场景较为理想，例如社交网络、产品偏好、资格认定规则等包含复杂关系的数据。</p>
</li>
<li><p>对关系型数据库来说，操作内部相互关系比较紧密的数据模型通常需要使用很多JOIN语句，效率也较差。使用图数据库遍历关系，则非常迅速。主要原因是由于图数据库会多花一些时间用于插入关系数据，以此来缩短遍历关系时所需的时间。在一些查询效率高于插入效率的场合，这种权衡非常重要。</p>
</li>
<li><p>图数据库使用边和节点来存储数据，使用图数据库时，大部分时候都是在浏览各种关系。</p>
</li>
<li><p>图数据库和面向聚合的数据库的明显差别，在于图数据库重视数据间的“关系”，这种数据模型上的差异也导致了其他一些区别。图数据库一般运行在单一服务器上而非集群中。为了使数据保持一致，ACID事务需要涵盖多个节点与边。相似之处是，它们都不适用关系模型。</p>
</li>
</ul>
<h4 id="无模式数据库"><a href="#无模式数据库" class="headerlink" title="无模式数据库"></a>无模式数据库</h4><ul>
<li><p>各种形式的NoSQL都有一个特性，就是它们都是无模式的。在关系型数据库中，我们首先要定义好模式，就是用一种预定义结构向数据库说明，有哪些表，表中有哪些列，每列存放什么类型的数据，必须先定义好模式，才能使用数据库。相反，无模式数据库就显得相当随意了，可以在一个键下存放任意数据。</p>
</li>
<li><p>无模式数据库没有关系型数据库的那么多限制，但是它本身也存在一些问题，不管数据库无模式到什么程度，它都存在“隐含模式”，它是指在编写数据操作代码时，对数据结构所做的一系列假设。虽然我们可以在无模式数据库中以合法名称的键值存放数据，但是这也就假定了程序需要知道这些字段，除非我们只是无脑地遍历数据结构依次打印键值对，然而这基本没有什么意义。</p>
</li>
<li><p>应用程序代码中的隐含模式也会带来一些问题，它意味着要想理解数据库中的数据，必须深入研究应用程序的代码才行，如果代码很清晰易懂，那么你可以根据它推断出数据的模式，然而这一点却无法保证，因为这完全取决于你的代码是否清晰。举个简单的例子，某个字段，在一些聚合中保存为字符串，在另一些聚合中保存为对象(因为数据库是无模式的，理论上完全可能出现这种情况)，如果你不知晓代码的逻辑，基本无法判断出这个字段的这两种数据类型究竟有什么区别。而且，由于数据库感知不到模式，也就无法自行验证数据，这就少了一道保障。不同应用程序可能也会以完全不同的方式使用某个字段。当然了，在验证数据方面，我们还必须在所有使用这个数据库的应用程序中都加上完全相同的验证逻辑来确保数据正确性和安全性。</p>
</li>
<li><p>从本质上说，无模式数据库是把模式交由访问其数据的应用程序代码来处理，如果有多个应用程序需要访问同一个数据库，可能会出现问题。一种缓解此问题的方法是把数据互动操作封装成独立的应用程序，并通过web服务的形式将它和其他应用程序集成。另一种方法是在聚合中明确划分出不同应用程序的区域。</p>
</li>
</ul>
<h4 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h4><ul>
<li><p>关系型数据库可以利用视图来展示一些需要复杂计算才能给出的数据，视图就好比一张关系表，只不过它是通过基表计算得来的，在访问视图时，数据库会计算出视图中的数据，这种形式的封装很方便。有了视图这种机制，客户端不需要担心它访问到的是基本数据还是派生数据，不过生成视图需要大量计算，比较消耗性能。</p>
</li>
<li><p>物化视图是一种事先计算好并缓存起来的视图，如果数据读取频繁，且对实时性要求不高的话，可以使用物化视图来优化性能。在NoSQL中，可以利用物化视图来处理这种需求。面向聚合的数据库更强调这个问题，因为大多数应用程序都要处理某种与聚合机构不相符的查询操作。</p>
</li>
<li><p>构建物化视图有两种方法，第一种是在每次基础数据变更的时候都去更新物化视图，如果读取物化视图的次数远比写入的多，且想获得更为实时的数据，那么这种方法比较合适。第二种是通过批处理来定时更新物化视图，这需要根据业务需求来制定方案，需要考察业务能容忍过时多久的数据。</p>
</li>
<li><p>面向聚合的数据库通常能够用不同方式重组主聚合的数据，以计算出各种物化视图，计算过程一般使用map-reduce的方式。</p>
</li>
</ul>
<h4 id="构建数据存储模型"><a href="#构建数据存储模型" class="headerlink" title="构建数据存储模型"></a>构建数据存储模型</h4><ul>
<li>使用列族数据库建模时，应该按照查询需求而不是写入需求来处理。建模的通则是要便于查询，而且在写入数据时要对其执行“反规范化”操作。</li>
</ul>
<h3 id="第4章-分布式模型"><a href="#第4章-分布式模型" class="headerlink" title="第4章 分布式模型"></a>第4章 分布式模型</h3><ul>
<li><p>面向聚合数据库非常适合于横向扩展方式，因为聚合此时就自然成了数据分布单元。</p>
</li>
<li><p>数据分布有两条途径：</p>
</li>
</ul>
<ol>
<li>复制</li>
<li>分片</li>
</ol>
<ul>
<li>复制，就是将同一份数据拷贝至多个节点。分片，就是将不同数据存放在不同节点中。复制和分片是两项正交的技术，它们既可以选其一使用，也可以结合使用。</li>
</ul>
<h4 id="单一服务器"><a href="#单一服务器" class="headerlink" title="单一服务器"></a>单一服务器</h4><ul>
<li>在大多数情况下，最简单的分布形式就是没有分布，采用单一服务器的形式，特点是简单。</li>
</ul>
<h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><ul>
<li><p>分片是把数据的各个部分放在不同的服务器(节点)中，以此实现横向扩展。分片技术能有效实现负载均衡。为了最大程度地利用分片技术，我们必须保证需要同时访问的数据都存放在同一个节点上，并且节点必须排布好这些数据块，使访问速度最优。这些措施包括，使服务器服务于地理位置上较近的用户、最大程度实现负载均衡，某些情况下可以把需要依次读取的聚合放在一起。</p>
</li>
<li><p>经常有人通过应用程序来处理分片，比如把用户姓氏首字母按照A-D，E-G之类的方式存放在不同分片中，但这样做就把编程模型复杂化了，因为应用程序需要把查询操作分布到多个分片上。如果想调整分片，就需要修改应用程序的相关逻辑并迁移数据。很多NoSQL数据库都提供了“自动分片”来让数据库自己负责把数据分布到各分片，并将查询请求路由至适当分片中。</p>
</li>
<li><p>单一使用分片技术在应对数据库故障时比较力不从心，一旦某个节点崩溃，则该分片上的数据就不可访问，虽说可能只是其中一个分片出问题，但比较已经无法对外提供完整的服务了。后面会看到采用分片结合复制的技术构造冗余可以缓解此问题。</p>
</li>
</ul>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><ul>
<li><p>在主从复制中，有一个节点叫节点，其余的叫从节点。主节点存放权威数据，复制操作就是要让从节点和主节点的数据保持同步。</p>
</li>
<li><p>主节点负责处理数据的读写，从节点只负责数据读。这样只要增加从节点就可以实现横向扩展。</p>
</li>
<li><p>可以采用手动指定主节点和自动选择主节点两种模式，手动指定需要我们自己配置集群，自动选择比较简单，会让它们自动选举出主节点，如果之后这个主节点崩溃了，会自动指派新的主节点，减少故障时间，手动指定则无此福利。</p>
</li>
<li><p>主从复制有助于增强读取操作的故障恢复能力。</p>
</li>
<li><p>主从复制对于写入操作非常频繁的场合，虽然能将读取操作分流，稍稍缓解主节点写入数据的压力，但对写入操作的性能并没有什么显著的提升。</p>
</li>
<li><p>复制技术再带来好处的同时也有一个致命弱点，就是数据的不一致。如果主节点更新了一个数据，但还未通知从节点，那么用户从从节点读出的数据就不是最新的，甚至由于各从节点同步速度的快慢数据还是各异的。更极端的情况是，主节点崩溃了，此时有部分数据尚未同步到从节点，这部分数据就会丢失。</p>
</li>
<li><p>主节点仍然是系统的瓶颈和弱点。</p>
</li>
</ul>
<h4 id="对等复制"><a href="#对等复制" class="headerlink" title="对等复制"></a>对等复制</h4><ul>
<li><p>对等复制中的所有节点都是平等的，不存在主从节点一说，所有节点都可以接受读写请求，节点会将自身的写入操作通知给其他所有节点。</p>
</li>
<li><p>增加节点可以轻易提升性能。</p>
</li>
<li><p>对等复制也存在数据一致性问题，由于两个不同节点可以同时处理写入操作，所以可能出现两位用户同时对同一条记录的情况，这就导致“写入冲突”。数据读取的不一致性也存在，但持续时间相对较短，因为最终都会归于一致，写入不一致却总是存在。</p>
</li>
<li><p>写入不一致的几种解决方案思路：</p>
</li>
</ul>
<ol>
<li>不管何时写入数据，各副本之间总能相互协调，确保不发生冲突，这需要花费一定的网络流量来协调写入操作。</li>
<li>设法处理这些不一致的写入操作，比如合并这些操作。</li>
</ol>
<h4 id="结合分片和复制技术"><a href="#结合分片和复制技术" class="headerlink" title="结合分片和复制技术"></a>结合分片和复制技术</h4><ul>
<li>每个系统有多个主节点，但对于每项数据来说，负责它的主节点又只有一个。根据配置的需要，同一个节点既可以作为某些数据的主节点，也可以充当其他数据的从节点，也可以指派全职的主节点和从节点。</li>
</ul>
<h3 id="第5章-一致性"><a href="#第5章-一致性" class="headerlink" title="第5章 一致性"></a>第5章 一致性</h3><ul>
<li>面向集群的NoSQL数据库需要面对一致性的问题，关系型数据库试图通过“强一致性”来避免各种不一致问题，在NoSQL领域中，需要我们自己思考系统需要何种一致性。</li>
</ul>
<h4 id="更新一致性"><a href="#更新一致性" class="headerlink" title="更新一致性"></a>更新一致性</h4><ul>
<li>多个请求同时更新同一条数据会产生写冲突问题，在并发环境下维护数据一致性一般有两种方式：悲观方式和乐观方式。</li>
</ul>
<ol>
<li>悲观方式，就是要避免冲突。常见做法是使用写入锁，确保同一时间只有一个请求可以获取该锁。但注意可能导致死锁问题。</li>
<li>乐观方式，就是允许冲突发生，然后检测冲突并对发生冲突的操作排序，再进一步处理。通常使用“条件更新”，就是任意用户在执行更新操作前，都要先检测数据的当前值和上一次读入的是否相同。如果相同，就更新，如果不同，则更新失败，此时需要先更新到最新在做更新。可参考git等分布式版本管理系统处理冲突的方式。</li>
</ol>
<ul>
<li><p>悲观和乐观的方式，都有一个先决条件，就是更新顺序必须一致，这在单机环境下显然成立，但在分布式集群下，可能两个节点会以不同的顺序执行操作，最终数据就会不一致。</p>
</li>
<li><p>在分布式系统的并发问题上，需要有“顺序一致性”，就是所有节点都要保证以相同的次序执行操作。</p>
</li>
</ul>
<h4 id="读取一致性"><a href="#读取一致性" class="headerlink" title="读取一致性"></a>读取一致性</h4><ul>
<li><p>数据库必须具有更新一致性，但就这样还不够，它未必能保证用户所提交的访问请求总是能得到一致的响应。典型场景是一个用户A的一个更新动作需要顺序操作两张表的数据，如果是面向聚合的数据库则此处无法使用ACID事务，因此是依次更新。如果在更新完第一张表但还未更新第二张表时，用户B访问了第二张表的那条数据，就会看到一个不一致的数据。这种一致性叫“逻辑一致性”。</p>
</li>
<li><p>并不是所有NoSQL数据库都不支持ACID事务，只有面向聚合的数据库不支持，图数据库是支持ACID事务的。</p>
</li>
<li><p>面向聚合数据库可以“原子地”更新一个聚合的数据，但仅限于单一聚合内部。所以说，“逻辑一致性”可以在某个聚合内部保持，但各聚合之间则不行。在多个聚合之间更新数据就存在一个时间空档，在此空档内读出的相关数据不满足“逻辑一致性”，这个空档叫“不一致窗口”。NoSQL系统的“不一致窗口”一般很短暂。</p>
</li>
<li><p>在引入复制的场景下，就会遭遇一种全新的不一致问题，叫“复制不一致”。如果有多个节点，在个节点上更新了数据，在所有节点尚未全部同步数据前，就会有部分用户访问到过期的数据。但最终，更新还是会传播到所有节点上，这叫“最终一致性”。</p>
</li>
<li><p>“复制一致性”和“逻辑一致性”虽说是两个独立的问题，不过如果“复制”过程中的“不一致窗口”太长，就会加剧“逻辑不一致”问题。两个时间间隔很短且内容不同的更新操作，在主节点中留下的“不一致窗口”也就几毫秒而已，但由于网络延迟，这个“不一致窗口”在从节点上会比在主节点上长得多。</p>
</li>
<li><p>“会话一致性”是指在用户会话内部保持“照原样读出所写内容的一致性”。要确保“会话一致性”，其中一种方法是使用“粘性会话”，就是把会话绑定到某个固定的节点，但缺点是会降低负载均衡器的效率。另一种方法是使用“版本戳”，这个之后会详述。</p>
</li>
</ul>
<h4 id="放宽“一致性”约束"><a href="#放宽“一致性”约束" class="headerlink" title="放宽“一致性”约束"></a>放宽“一致性”约束</h4><ul>
<li><p>一致性很重要，不过有时必须舍弃它。在设计系统时，我们经常需要牺牲一致性来换取其他特性。</p>
</li>
<li><p>关系型数据库一般用事务来加强一致性，但是事务会影响系统性能。</p>
</li>
<li><p>CAP定理，其中CAP的意思是</p>
</li>
</ul>
<ol>
<li>一致性(Consistency)，具体含义之前说过。</li>
<li>可用性(Availability)，这里可以指响应的效率，或者说延时。</li>
<li>分区耐受性(Partition tolerance)，如果发生通信故障，导致整个集群被分割成多个无法通信的分区时(也叫脑裂)，集群仍然可用。</li>
</ol>
<p>CAP定理所表述的是，给定一致性、可用性和分区耐受性这三个属性，我们只能同时满足其中两个属性。</p>
<h4 id="放宽“持久性”约束"><a href="#放宽“持久性”约束" class="headerlink" title="放宽“持久性”约束"></a>放宽“持久性”约束</h4><ul>
<li><p>某些数据可以不持久化或延迟持久化，比如用户session或者一些临时数据可以保存在redis中，生成和更新非常频繁但又不是那么重要的数据可以延迟持久化，比如定时持久化写入。</p>
</li>
<li><p>是否放宽“持久化”约束需要根据具体需求来确定。</p>
</li>
</ul>
<h4 id="仲裁"><a href="#仲裁" class="headerlink" title="仲裁"></a>仲裁</h4><ul>
<li><p>假设某份数据需要复制到3个节点中，为了保证”强一致性”，不需要所有节点都确认写入操作，只需其中两个节点(超过半数)确认即可。就是说如果发生两个发生冲突的写入操作，那么只有其中一个操作能为超过半数的节点所认可(W&gt;N/2)。这就叫写入仲裁。</p>
</li>
<li><p>读取仲裁，是指想要读取保证能够读到最新的数据，必须联系多少个节点才行。</p>
</li>
<li><p>在采用“复制”技术的分布式模型中执行数据操作时，无需联系所有副本，只要为足够多的副本所认可，就能保持“强一致性”了。</p>
</li>
<li><p>执行读取操作时所需联系的节点数(R)、确认写入操作时需要联系的节点数(W)和复制因子(N)之间可以用一个不等式来表达：R+W&gt;N。</p>
</li>
</ul>
<h3 id="第6章-版本戳"><a href="#第6章-版本戳" class="headerlink" title="第6章 版本戳"></a>第6章 版本戳</h3><ul>
<li><p>版本戳用户标识数据的版本，典型情况是使用计数器版本戳，如果当前数据库中某条数据的版本戳是3，而用户请求更新的数据版本戳是2，说明在用户上一次读取到更新之间，该条数据发生了一次更新，可能是有其他人在此时更新了数据，所以这个用户的更新会失败。</p>
</li>
<li><p>版本戳一般可以使用计数器、GUID、内容哈希值、上一次更新的时间戳来表示，这几种方案各有优劣。也可以结合起来使用，比如CouchDB的版本戳就结合使用了内容哈希和计数器。</p>
</li>
<li><p>除了可以避免“更新冲突”之外，版本戳也有助于维护“会话一致性”。</p>
</li>
<li><p>在分布式环境中，可以使用“由版本戳构成的数组”，来检测不同节点之间是否发生了“相互冲突的更新操作”。</p>
</li>
</ul>
<h3 id="第7章-Map-reduce-映射-化简"><a href="#第7章-Map-reduce-映射-化简" class="headerlink" title="第7章 Map-reduce(映射-化简)"></a>第7章 Map-reduce(映射-化简)</h3><ul>
<li><p>映射-化简是一种在集群上执行并发计算所用的模式。</p>
</li>
<li><p>映射操作从聚合中读出数据，将之缩减为相关键值对。映射操作每次只能读取一条记录，所以可在存放记录的节点上并发执行。</p>
</li>
<li><p>映射任务会生成很多具备同一关键字的值，而化简任务则将它们化简为单一的输出值。每个化简函数只操作与单个键相关的映射结果，所以多个化简函数可以根据关键字执行并发化简。</p>
</li>
<li><p>输入数据与输出数据形式相同的多个“化简函数”可归并为“管道”，以提高并发执行能力，并减少所需传输的数据量。</p>
</li>
<li><p>若某个“化简输出”的结果是下一个“映射操作”的输入，那么可以用“管道”组合映射-化简操作。</p>
</li>
<li><p>如果需要广泛使用映射-化简的计算结果，那么可以将其存储为“物化视图”。</p>
</li>
<li><p>可使用增量式映射-化简操作来更新“物化视图”，这样做只需要计算视图中发生改变的那部分数据即可，无需把全部数据从头算一遍。</p>
</li>
</ul>
<h3 id="第8章-键值数据库"><a href="#第8章-键值数据库" class="headerlink" title="第8章 键值数据库"></a>第8章 键值数据库</h3><h4 id="键值数据库和关系型数据库的对比"><a href="#键值数据库和关系型数据库的对比" class="headerlink" title="键值数据库和关系型数据库的对比"></a>键值数据库和关系型数据库的对比</h4><table>
<thead>
<tr>
<th style="text-align:left">Oracle</th>
<th style="text-align:left">Raik</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">数据库实例</td>
<td style="text-align:left">Raik集群</td>
</tr>
<tr>
<td style="text-align:left">表</td>
<td style="text-align:left">存储区</td>
</tr>
<tr>
<td style="text-align:left">行</td>
<td style="text-align:left">键值对</td>
</tr>
<tr>
<td style="text-align:left">rowid</td>
<td style="text-align:left">键</td>
</tr>
</tbody>
</table>
<h4 id="什么是“键值数据库”"><a href="#什么是“键值数据库”" class="headerlink" title="什么是“键值数据库”"></a>什么是“键值数据库”</h4><ul>
<li><p>从API的角度来看，键值数据库是最简单的NoSQL数据库。客户端可以根据键查询值，设置键所对应的值。</p>
</li>
<li><p>Redis等键值数据库中，所存储的数据不一定非要是领域对象，任何数据结构都行。Redis可以存储list、set、hash等数据结构，还可以求差集、并集、交集和获取某个范围内的数值。</p>
</li>
</ul>
<h4 id="键值数据库特性"><a href="#键值数据库特性" class="headerlink" title="键值数据库特性"></a>键值数据库特性</h4><ul>
<li><p>一致性，只有针对单个键的操作才具备一致性，一般就是set、get或del。</p>
</li>
<li><p>事务，不同键值数据库其事务规范不同，一般无法保证写入一致性。比如Raik采用仲裁。</p>
</li>
<li><p>查询功能，所有键值数据库都可以按照关键字来查询，但无法根据列值来查询。</p>
</li>
<li><p>数据结构，键值数据库一般不关心值，值可以是二进制、文本、JSON等。</p>
</li>
<li><p>可扩展性，很多键值数据库都可以采用分片技术。采用这种技术后，键的名字决定了负责存储该键的节点。像Raik这样的数据库，可以控制“CAP”定理中的参数，N(存放键值对的副本节点数)、R(顺利完成读取操作所需的最小节点数)和W(顺利完成写入操作所需的最小节点数)。</p>
</li>
</ul>
<h4 id="适用案例"><a href="#适用案例" class="headerlink" title="适用案例"></a>适用案例</h4><ul>
<li><p>存放会话信息</p>
</li>
<li><p>用户配置信息</p>
</li>
<li><p>购物车数据</p>
</li>
</ul>
<p>不适用场合</p>
<ul>
<li><p>数据间关系</p>
</li>
<li><p>含有多项操作的事务</p>
</li>
<li><p>查询数据</p>
</li>
<li><p>操作关键字集合</p>
</li>
</ul>
<h3 id="第9章-文档数据库"><a href="#第9章-文档数据库" class="headerlink" title="第9章 文档数据库"></a>第9章 文档数据库</h3><h4 id="文档数据库和关系型数据库的对比"><a href="#文档数据库和关系型数据库的对比" class="headerlink" title="文档数据库和关系型数据库的对比"></a>文档数据库和关系型数据库的对比</h4><table>
<thead>
<tr>
<th style="text-align:left">Oracle</th>
<th style="text-align:left">MongoDB</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">数据库实例</td>
<td style="text-align:left">MongoDB实例</td>
</tr>
<tr>
<td style="text-align:left">模式</td>
<td style="text-align:left">数据库</td>
</tr>
<tr>
<td style="text-align:left">表</td>
<td style="text-align:left">集合</td>
</tr>
<tr>
<td style="text-align:left">行</td>
<td style="text-align:left">文档</td>
</tr>
<tr>
<td style="text-align:left">rowid</td>
<td style="text-align:left">_id</td>
</tr>
<tr>
<td style="text-align:left">join</td>
<td style="text-align:left">DBRef</td>
</tr>
</tbody>
</table>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li><p>一致性，为了在MongoDB数据库中确保一致性，可以配置副本集，也可以规定写入操作必须等待所写数据复制到全部或是给定数量的从节点后，才能返回。提升一致性会降低写入效率。可以配置以增加副本集的读取效率。</p>
</li>
<li><p>事务，只支持单文档级别的事务，即原子事务。</p>
</li>
<li><p>可用性，文档数据库试图用主从式数据复制技术来增强可用性。多个节点保有同一份数据，即使主节点故障，客户端也依然可以获取数据，应用程序一般不需要检测主节点是否可用。所有请求都由主节点处理，而其数据会复制到从节点。如果主节点故障，副本集中剩余的节点会在其自身范围内选举出新的主节点。副本集通常用于处理数据冗余、自动故障切换、灾难恢复等事项。</p>
</li>
<li><p>查询功能，文档数据库可以查询文档中的数据，而不用像键值数据库那样，必须根据关键字获取整个文档，然后再检视其内容。MongoDB还可以基于“内嵌子文档”来查询。</p>
</li>
<li><p>可扩展性，增加更多的“读取从节点”，将全部读取操作都引导至从节点上，这样可以扩展数据库应对频繁读取的能力了。如果想扩展写入能力，则可以把数据分片，分片操作根据特定字段来划分数据(该字段的选择很重要)，这些数据要移动到不同的节点中。为了让各分片负载保持均衡，需要在节点之间动态转移数据，向集群中加入更多节点，并提高可写入的节点数，就可以横向扩展写入能力。把每个分片都做成副本集可以提高读取效率。</p>
</li>
</ul>
<h4 id="适用案例-1"><a href="#适用案例-1" class="headerlink" title="适用案例"></a>适用案例</h4><ul>
<li><p>事件记录</p>
</li>
<li><p>内容管理系统和博客平台</p>
</li>
<li><p>网站分析和实时分析</p>
</li>
<li><p>电子商务应用程序</p>
</li>
</ul>
<h4 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h4><ul>
<li><p>包含多项操作的复杂事务</p>
</li>
<li><p>查询持续变化的聚合结构</p>
</li>
</ul>
<h3 id="第10章-列族数据库"><a href="#第10章-列族数据库" class="headerlink" title="第10章 列族数据库"></a>第10章 列族数据库</h3><table>
<thead>
<tr>
<th style="text-align:left">关系型数据库</th>
<th style="text-align:left">Cassandra</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">数据库实例</td>
<td style="text-align:left">集群</td>
</tr>
<tr>
<td style="text-align:left">数据库</td>
<td style="text-align:left">键空间</td>
</tr>
<tr>
<td style="text-align:left">表</td>
<td style="text-align:left">列族</td>
</tr>
<tr>
<td style="text-align:left">行</td>
<td style="text-align:left">行</td>
</tr>
<tr>
<td style="text-align:left">列</td>
<td style="text-align:left">列</td>
</tr>
</tbody>
</table>
<h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><ul>
<li><p>一致性，Cassandra收到写入请求后，会先将待写入数据记录到“提交日志”中，然后将其写入内存中一个名为“内存表”的结构中。写入操作在写入“提交日志”和“内存表”后就算成功了。写入请求成批堆积在内存中，并定期写入一种叫做“SSTable”的结构中，该结构中的缓存一旦写入数据库，就不会再向其继续写入了。若其数据变动，则需新写一张SSTable。无用的SSTable可由“压缩”操作回收。</p>
</li>
<li><p>事务，Cassandra没有传统意义上的事务，它的写入操作在行级别的原子的。</p>
</li>
<li><p>可用性，Cassandra具备高可用性，因为集群中没有主节点，减少操作请求的一致性即可提示集群的可用性。可用性受制于 R+W&gt;N 这一公式。W是成功执行写入操作所需的最小节点数，R是顺利执行读取操作所需获取的最小应答节点数，N是参与数据复制的节点数。</p>
</li>
<li><p>查询功能，Cassandra没有功能丰富的查询语言。在列族插入数据后，每行中的数据都会按照列名排序。如果一列的获取次数比其他列更加频繁，可以考虑将其值用作行健以提高性能。</p>
</li>
<li><p>基本查询，有GET、SET和DEL。</p>
</li>
<li><p>高级查询和索引编订，Cassandra列族可以用关键字以外的其他列当索引。这些索引以位映射图的形式出现，在列中频繁出现重复值的情况下效果较好。</p>
</li>
<li><p>Cassandra查询语言(CQL)，提供查询功能，但未包含SQL的全部功能。</p>
</li>
<li><p>可扩展性，由于没有主节点，所以只要向Cassandra集群中新增节点就能改善其服务能力。</p>
</li>
</ul>
<h4 id="适用案例-2"><a href="#适用案例-2" class="headerlink" title="适用案例"></a>适用案例</h4><ul>
<li><p>事件记录</p>
</li>
<li><p>内容管理系统和博客平台</p>
</li>
<li><p>计数器</p>
</li>
<li><p>限期使用</p>
</li>
</ul>
<h4 id="不适用场合-1"><a href="#不适用场合-1" class="headerlink" title="不适用场合"></a>不适用场合</h4><ul>
<li><p>需要以“ACID事务”执行写入和读取操作的系统。</p>
</li>
<li><p>根据查询结构聚合数据的场景。</p>
</li>
<li><p>开发早期、原型期和技术初探期。开发初期无法确定查询模式的变化情况，查询模式一旦变化，列族的设计也要随之修改。注意，关系型数据库改变数据模式的成本很高，但查询模式的修改成本较低，Cassandra则相反。</p>
</li>
</ul>
<h3 id="第11章-图数据库"><a href="#第11章-图数据库" class="headerlink" title="第11章 图数据库"></a>第11章 图数据库</h3><h4 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h4><ul>
<li><p>一致性，由于图数据库操作互相连接的节点，所以大部分图数据库通常不支持把节点分布在不同服务器上。图数据库通过事务来保证一致性，它们不允许出现“悬挂关系”：所有关系必须具备起始节点和终止节点，而且在删除节点前，必须先移除其上的关系。</p>
</li>
<li><p>事务，Neo4J是兼容ACID事务的数据库，修改节点或向现有节点新增关系前，必须先启动事务。</p>
</li>
<li><p>可用性，Neo4J从1.8开始，支持“副本从节点”，这些从节点可以处理写入操作，向其写入后，它会先将所写数据同步至当前主节点，然后主节点再同步至其他从节点。也可以配合ZooKeeper来记录每个丛节点和当前主节点中最新的事务ID。</p>
</li>
<li><p>查询功能，图数据库可以使用Gremlin等查询语言，Neo4J还可以使用Cypher语言来查询图。</p>
</li>
<li><p>可扩展性，图数据库要运用分片技术比较难，因为它并不是面向聚合的，而是面向关系的。由于任何节点都有可能关联其他节点，因此把相关节点放在同一台机器上，遍历图时比较方便，放在多台机器上性能不好。扩展图数据库一般有三种方式：</p>
</li>
</ul>
<ol>
<li>给服务器配置足量内存，使之完全可以容纳“工作集”中的全部节点和关系。只有在这些内存量的数值比较合理时，这项技术才有用。</li>
<li>增加仅能读取数据的从节点，即可改善数据的读取能力，所有写入操作仍由主节点负责。</li>
<li>若数据集太大，导致多节点复制不大现实，可采用“领域特定知识”在应用程序端对其分片，比如按照地理位置分片等。</li>
</ol>
<h4 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h4><ul>
<li><p>互联数据</p>
</li>
<li><p>安排运输路线、分派货物和基于位置的服务</p>
</li>
<li><p>推荐引擎</p>
</li>
</ul>
<h4 id="不适用的场合"><a href="#不适用的场合" class="headerlink" title="不适用的场合"></a>不适用的场合</h4><ul>
<li><p>更新全部或某个子集内实体的场合</p>
</li>
<li><p>涉及整张图的操作</p>
</li>
</ul>
<h3 id="第12章-模式迁移"><a href="#第12章-模式迁移" class="headerlink" title="第12章 模式迁移"></a>第12章 模式迁移</h3><ul>
<li><p>若要迁移关系型数据库等“强模式”的数据库，可将历次模式变更及其数据迁移操作保存于“版本控制序列”中。</p>
</li>
<li><p>因程序代码要依照“隐含模式”来访问无模式数据库的数据，故其数据迁移仍需谨慎处理。</p>
</li>
<li><p>无模式数据库亦可借用强模式数据库的迁移技术。</p>
</li>
<li><p>无模式数据库可使用“增量迁移”技术更新数据，以便在不影响应用程序读取数据的前提下，修改数据的隐含模式。</p>
</li>
</ul>
<h3 id="第13章-混合持久化"><a href="#第13章-混合持久化" class="headerlink" title="第13章 混合持久化"></a>第13章 混合持久化</h3><ul>
<li><p>混合持久化旨在使用不同数据库技术处理多种数据存储需求。</p>
</li>
<li><p>混合持久化既可为企业中多个程序所用，也可以运用在单个应用程序中。</p>
</li>
<li><p>将数据访问封装成服务，可以减少数据库变动对系统其它部分的影响。</p>
</li>
<li><p>新增数据库技术会让编程和操作更复杂，所以要权衡引入新数据库带来的好处和引入它带来的复杂度的利弊。</p>
</li>
</ul>
<h3 id="第14章-超越NoSQL"><a href="#第14章-超越NoSQL" class="headerlink" title="第14章 超越NoSQL"></a>第14章 超越NoSQL</h3><ul>
<li><p>文件系统</p>
</li>
<li><p>事件溯源</p>
</li>
<li><p>内存映像</p>
</li>
<li><p>版本控制</p>
</li>
<li><p>XML数据库</p>
</li>
<li><p>对象数据量</p>
</li>
</ul>
<h3 id="第15章-选择合适的数据库"><a href="#第15章-选择合适的数据库" class="headerlink" title="第15章 选择合适的数据库"></a>第15章 选择合适的数据库</h3><ul>
<li><p>通过使用更符合应用程序需求的数据库来改善程序员的工作效率。</p>
</li>
<li><p>以能处理大数据量、降低延迟且增进数据吞吐量的某种技术组合来改善数据访问性能。</p>
</li>
<li><p>在决定使用某个NoSQL技术之前，一定要测试其是否如预期般改善了程序员工作效率和数据访问性能。</p>
</li>
<li><p>用服务来封装数据库，即能在需求变更或技术成熟后改换其所封装的数据库技术。可将应用程序各部分划分到不同服务中，以便为既有程序引入NoSQL数据库。</p>
</li>
<li><p>大部分应用程序，尤其是“非战略性的”应用程序，应该继续使用关系型数据库技术，至少在NoSQL技术环节尚未更加成熟时是如此。</p>
</li>
</ul>

        <!-- <h3>看了文章如果觉得喜欢的话可以捐赠哦！支付宝二维码：</h3>
        <img src="/assets/images/post_imgs/code_alipay.png" width=300 height=300> -->
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/读书笔记/">读书笔记</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NoSQL/">NoSQL</a></li></ul>

      
        
	<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '4010e28e5153ab82b468',
        clientSecret: '217df2318bd891ba87b82dae5d67d7ae77bc1f17',
        id: md5(location.href),
        repo: 'nullcc-blog-comments',
        owner: 'nullcc',
        admin: 'nullcc',
        distractionFreeMode: 'true'
    })
    gitalk.render('gitalk-container')
</script>


      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/05/09/koa2中controller实现类似sleep的延迟功能/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          koa2中controller实现类似sleep的延迟功能
        
      </div>
    </a>
  
  
    <a href="/2017/05/08/深入理解JavaScript中的this关键字/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">深入理解JavaScript中的this关键字</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
      <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一部分"><span class="nav-number">1.</span> <span class="nav-text">第一部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第1章-为什么使用NoSQL"><span class="nav-number">1.1.</span> <span class="nav-text">第1章 为什么使用NoSQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第2章-聚合数据模型"><span class="nav-number">1.2.</span> <span class="nav-text">第2章 聚合数据模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第3章-数据模型详解"><span class="nav-number">1.3.</span> <span class="nav-text">第3章 数据模型详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#图数据库"><span class="nav-number">1.3.1.</span> <span class="nav-text">图数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无模式数据库"><span class="nav-number">1.3.2.</span> <span class="nav-text">无模式数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#物化视图"><span class="nav-number">1.3.3.</span> <span class="nav-text">物化视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构建数据存储模型"><span class="nav-number">1.3.4.</span> <span class="nav-text">构建数据存储模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第4章-分布式模型"><span class="nav-number">1.4.</span> <span class="nav-text">第4章 分布式模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单一服务器"><span class="nav-number">1.4.1.</span> <span class="nav-text">单一服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分片"><span class="nav-number">1.4.2.</span> <span class="nav-text">分片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主从复制"><span class="nav-number">1.4.3.</span> <span class="nav-text">主从复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对等复制"><span class="nav-number">1.4.4.</span> <span class="nav-text">对等复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结合分片和复制技术"><span class="nav-number">1.4.5.</span> <span class="nav-text">结合分片和复制技术</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第5章-一致性"><span class="nav-number">1.5.</span> <span class="nav-text">第5章 一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#更新一致性"><span class="nav-number">1.5.1.</span> <span class="nav-text">更新一致性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读取一致性"><span class="nav-number">1.5.2.</span> <span class="nav-text">读取一致性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#放宽“一致性”约束"><span class="nav-number">1.5.3.</span> <span class="nav-text">放宽“一致性”约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#放宽“持久性”约束"><span class="nav-number">1.5.4.</span> <span class="nav-text">放宽“持久性”约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#仲裁"><span class="nav-number">1.5.5.</span> <span class="nav-text">仲裁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第6章-版本戳"><span class="nav-number">1.6.</span> <span class="nav-text">第6章 版本戳</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第7章-Map-reduce-映射-化简"><span class="nav-number">1.7.</span> <span class="nav-text">第7章 Map-reduce(映射-化简)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第8章-键值数据库"><span class="nav-number">1.8.</span> <span class="nav-text">第8章 键值数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#键值数据库和关系型数据库的对比"><span class="nav-number">1.8.1.</span> <span class="nav-text">键值数据库和关系型数据库的对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是“键值数据库”"><span class="nav-number">1.8.2.</span> <span class="nav-text">什么是“键值数据库”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#键值数据库特性"><span class="nav-number">1.8.3.</span> <span class="nav-text">键值数据库特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#适用案例"><span class="nav-number">1.8.4.</span> <span class="nav-text">适用案例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第9章-文档数据库"><span class="nav-number">1.9.</span> <span class="nav-text">第9章 文档数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文档数据库和关系型数据库的对比"><span class="nav-number">1.9.1.</span> <span class="nav-text">文档数据库和关系型数据库的对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特性"><span class="nav-number">1.9.2.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#适用案例-1"><span class="nav-number">1.9.3.</span> <span class="nav-text">适用案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不适用场合"><span class="nav-number">1.9.4.</span> <span class="nav-text">不适用场合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第10章-列族数据库"><span class="nav-number">1.10.</span> <span class="nav-text">第10章 列族数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特性-1"><span class="nav-number">1.10.1.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#适用案例-2"><span class="nav-number">1.10.2.</span> <span class="nav-text">适用案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不适用场合-1"><span class="nav-number">1.10.3.</span> <span class="nav-text">不适用场合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第11章-图数据库"><span class="nav-number">1.11.</span> <span class="nav-text">第11章 图数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特性-2"><span class="nav-number">1.11.1.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#适用场合"><span class="nav-number">1.11.2.</span> <span class="nav-text">适用场合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不适用的场合"><span class="nav-number">1.11.3.</span> <span class="nav-text">不适用的场合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第12章-模式迁移"><span class="nav-number">1.12.</span> <span class="nav-text">第12章 模式迁移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第13章-混合持久化"><span class="nav-number">1.13.</span> <span class="nav-text">第13章 混合持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第14章-超越NoSQL"><span class="nav-number">1.14.</span> <span class="nav-text">第14章 超越NoSQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第15章-选择合适的数据库"><span class="nav-number">1.15.</span> <span class="nav-text">第15章 选择合适的数据库</span></a></li></ol></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2023 张先森的代码小屋 All Rights Reserved.
        
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>













  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>

  <!-- 百度统计 -->
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c3ffa09eef07ac510ef2ab126054b1cd";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
    
</body>
</html>
