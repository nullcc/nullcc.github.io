<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Redis中的底层数据结构(2)——简单动态字符串(sds) | 张先森的代码小屋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="Redis数据结构">
  
  
  
  
  <meta name="description" content="本文将详细说明Redis中简单动态字符串(sds)的实现。 在Redis源码（这里使用3.2.11版本）中，sds的实现在sds.h和sds.c中。">
<meta name="keywords" content="Redis,数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis中的底层数据结构(2)——简单动态字符串(sds)">
<meta property="og:url" content="https://nullcc.github.io/2017/11/10/Redis中的底层数据结构(2)——简单动态字符串(sds)/index.html">
<meta property="og:site_name" content="张先森的代码小屋">
<meta property="og:description" content="本文将详细说明Redis中简单动态字符串(sds)的实现。 在Redis源码（这里使用3.2.11版本）中，sds的实现在sds.h和sds.c中。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://nullcc.github.io/assets/images/post_imgs/redis_data_structure_2.png">
<meta property="og:image" content="https://nullcc.github.io/assets/images/post_imgs/redis_data_structure_3.png">
<meta property="og:updated_time" content="2022-04-15T03:41:13.018Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis中的底层数据结构(2)——简单动态字符串(sds)">
<meta name="twitter:description" content="本文将详细说明Redis中简单动态字符串(sds)的实现。 在Redis源码（这里使用3.2.11版本）中，sds的实现在sds.h和sds.c中。">
<meta name="twitter:image" content="https://nullcc.github.io/assets/images/post_imgs/redis_data_structure_2.png">
  
    <link rel="alternate" href="/atom.xml" title="张先森的代码小屋" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="124px" height="124px" alt="Hike News" src=" /css/images/logo.jpg">
              </a>
            
          </h1>
          
          
            <div class="site-description">明镜止水</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-Redis中的底层数据结构(2)——简单动态字符串(sds)" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      Redis中的底层数据结构(2)——简单动态字符串(sds)
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/11/10/Redis中的底层数据结构(2)——简单动态字符串(sds)/" class="article-date">
	  <time datetime="2017-11-09T16:00:00.000Z" itemprop="datePublished">十一月 10, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/源码分析/">源码分析</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文将详细说明Redis中简单动态字符串(sds)的实现。</p>
<p>在Redis源码（这里使用3.2.11版本）中，sds的实现在<code>sds.h</code>和<code>sds.c</code>中。</p>
<a id="more"></a>
<h2 id="sds字符串和C原生字符串的对比"><a href="#sds字符串和C原生字符串的对比" class="headerlink" title="sds字符串和C原生字符串的对比"></a>sds字符串和C原生字符串的对比</h2><p>Redis并没有直接使用C语言的原生字符串，而是有一个专用的字符串实现：sds。sds相比于C语言原生字符串有很多优势：</p>
<ol>
<li><p>sds获取字符串长度的效率高。要想获取C语言原生字符串的长度，需要遍历整个字符串对字符个数计数，直到遇到一个<code>\0</code>为止，时间复杂度为O(n)。sds在头部保存了<code>len</code>用来表示字符串的实际长度，获取sds字符串长度的时间复杂度为O(1)。</p>
</li>
<li><p>sds可以避免缓冲区溢出。一个简单的例子，字符串拼接，对C语言原生字符串str1和str2来说，把str2拼接到str1后，如果没有为str1申请好足够的内存，直接拼接可能造成str1后的内存区域被覆盖从而导致不可预知的后果。sds字符串在拼接时，会自动检查空间是否足够，如果不够会自动按照一定的规则进行分配，因此无需担心溢出问题。</p>
</li>
<li><p>sds的内存分配策略可以有效降低修改字符串时内存重分配的开销。在<code>sdsMakeRoomFor</code>函数中有这么一段代码（只截取一小部分）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...other code...</span></span><br><span class="line"><span class="comment">// 扩充后的长度小于sds最大预分配长度时，把newlen加倍以防止短期内再扩充</span></span><br><span class="line"><span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)  </span><br><span class="line">  newlen *= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">// 否则直接加上sds最大预分配长度</span></span><br><span class="line">  newlen += SDS_MAX_PREALLOC;</span><br><span class="line"><span class="comment">// ...other code...</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面这段代码表示，在对一个sds字符串进行扩充时，Redis会认为这个字符串还有进一步被扩充的可能性，因此会根据一定规则来预先分配一部分空间来避免短期内再次申请内存分配。另外sds字符串在缩短内容时，也不会立即释放多出来的空间，sds字符串在<code>alloc</code>属性中标识了占用的总空间大小，在需要的时候，Redis会进行释放。</p>
<p>4.sds是二进制安全的。C原生字符串的结尾是<code>\0</code>，也就是说它在字符串内容中不能包含<code>\0</code>，如果包含了会导致字符串被截断，因此C原生字符串只能用来保存文本数据，无法保存图片等包含<code>\0</code>的数据。sds字符串使用<code>len</code>属性来标识字符串长度而不是<code>\0</code>，所以其内容可以是任意的二进制数据。</p>
<h2 id="sds头文件详解"><a href="#sds头文件详解" class="headerlink" title="sds头文件详解"></a>sds头文件详解</h2><p>sds的定义表明sds实际上是一个<code>char *</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">char</span> *sds;</span><br></pre></td></tr></table></figure>
<p>但这还不足以说明sds是什么，源码中还定义了五种sds header的类型：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 注意: sdshdr5这种类型从未被使用, 我们仅仅直接访问它的flags。</span></span><br><span class="line"><span class="comment"> * 这里记录的是type为5的sds的布局。</span></span><br><span class="line"><span class="comment"> * __attribute__ ((__packed__))表示结构体字节对齐，这是GNU C特有的语法 */</span></span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr5 </span>&#123;</span><br><span class="line">    unsigned <span class="keyword">char</span> flags;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr8 </span>&#123;</span><br><span class="line">    uint8_t len;  <span class="comment">// 已使用的字符串长度</span></span><br><span class="line">    uint8_t alloc;  <span class="comment">// 分配的内存空间大小，不包括头部和空终止符</span></span><br><span class="line">    unsigned <span class="keyword">char</span> flags;  <span class="comment">// 3个最低有效位表示类型，5个最高有效位未使用</span></span><br><span class="line">    <span class="keyword">char</span> buf[];  <span class="comment">// 字符数组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr16 </span>&#123;</span><br><span class="line">    uint16_t len;</span><br><span class="line">    uint16_t alloc;</span><br><span class="line">    unsigned <span class="keyword">char</span> flags;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr32 </span>&#123;</span><br><span class="line">    uint32_t len;</span><br><span class="line">    uint32_t alloc;</span><br><span class="line">    unsigned <span class="keyword">char</span> flags;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr64 </span>&#123;</span><br><span class="line">    uint64_t len;</span><br><span class="line">    uint64_t alloc;</span><br><span class="line">    unsigned <span class="keyword">char</span> flags;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SDS类型值，一共5种类型 */</span></span><br><span class="line">#define SDS_TYPE_5  0</span><br><span class="line">#define SDS_TYPE_8  1</span><br><span class="line">#define SDS_TYPE_16 2</span><br><span class="line">#define SDS_TYPE_32 3</span><br><span class="line">#define SDS_TYPE_64 4</span><br><span class="line">#define SDS_TYPE_MASK 7  // sds类型掩码 0b00000111，因为flags中只有3个最低有效位表示类型</span><br><span class="line">#define SDS_TYPE_BITS 3  // 表示sds类型的比特位数，前面有提到：3个最低有效位表示类型</span><br></pre></td></tr></table></figure>
<p>除了<code>sdshdr5</code>不被使用以外，可以观察到其他四种类型的头部中<code>len</code>和<code>alloc</code>域的类型都不同，不同类型的头部支持的字符串长度不同，这是为了空间效率才这么做的，后面会有详细分析。</p>
<p>根据sds header的定义，来看看一个头部类型为sdshdr8的sds字符串的内存布局：</p>
<p><img src="/assets/images/post_imgs/redis_data_structure_2.png" alt="Redis的sds内存布局1"></p>
<p><code>sdshdr8</code>中的<code>len</code>表示sds字符串的实际长度，也就是buf字符数组的长度，<code>alloc</code>表示分配给字符串的空间大小，注意这个大小不包含头部和结尾的终止符。也就是说<code>alloc</code>是大于或等于<code>len</code>的，当<code>alloc</code>等于<code>len</code>时，内存布局就如上图所示，如果当<code>alloc</code>大于<code>len</code>，在字符串和和结尾终止符(\0)之间，会用<code>\0</code>填充，下面是一个<code>len</code>等于12，<code>alloc</code>等于15的sds字符串的内存布局示意图：</p>
<p><img src="/assets/images/post_imgs/redis_data_structure_3.png" alt="Redis的sds内存布局2"></p>
<p>先看几个在sds实现中很常用的宏：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从sds获取其header起始位置的指针，并声明一个sh变量赋值给它，获得方式是sds的地址减去头部大小 */</span></span><br><span class="line">#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从sds获取其header起始位置的指针，作用和上面一个定义差不多，只不过不赋值给sh变量 */</span></span><br><span class="line">#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取type为5的sds的长度，由于其flags的5个最高有效位表示字符串长度，所以直接把flags右移3位即是其字符串长度</span></span><br><span class="line">#define SDS_TYPE_5_LEN(f) ((f)&gt;&gt;SDS_TYPE_BITS)</span><br></pre></td></tr></table></figure>
<p><code>sdslen</code>函数获取一个sds的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> inline size_t <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 通过sds字符指针获得header类型的方法是，先向低地址方向偏移1个字节的位置，得到flags字段，</span></span><br><span class="line"><span class="comment">       然后取flags的最低3个bit得到header的类型。 */</span></span><br><span class="line">    unsigned <span class="keyword">char</span> flags = s[-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;  <span class="comment">// 操作：0b00000??? &amp; 0b00000111，根据sds类型获取其字符串长度</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>,s)-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdsavail</code>函数获取一个sds的空闲空间，计算方式是：已分配的空间 - 字符串长度大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> inline size_t <span class="title">sdsavail</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    unsigned <span class="keyword">char</span> flags = s[-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;  <span class="comment">// 同上，获取sds类型</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;  <span class="comment">// SDS_TYPE_5未被使用，直接返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);  <span class="comment">// 从sds获取其header起始位置的指针</span></span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            <span class="keyword">return</span> sh-&gt;alloc - sh-&gt;len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdssetlen</code>函数设置sds的字符串长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> inline <span class="keyword">void</span> <span class="title">sdssetlen</span><span class="params">(sds s, size_t newlen)</span> </span>&#123;</span><br><span class="line">    unsigned <span class="keyword">char</span> flags = s[-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;  <span class="comment">// 同上，获取sds类型</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:  <span class="comment">// SDS_TYPE_5的sds</span></span><br><span class="line">            &#123;</span><br><span class="line">                unsigned <span class="keyword">char</span> *fp = ((unsigned <span class="keyword">char</span>*)s)-<span class="number">1</span>;     <span class="comment">// fp是sdshdr5的flags的指针</span></span><br><span class="line">                *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS);  <span class="comment">// 把newlen右移SDS_TYPE_BITS位再和SDS_TYPE_5合成即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            SDS_HDR(<span class="number">8</span>,s)-&gt;len = newlen;  <span class="comment">// 直接改写header中的len</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            SDS_HDR(<span class="number">16</span>,s)-&gt;len = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            SDS_HDR(<span class="number">32</span>,s)-&gt;len = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            SDS_HDR(<span class="number">64</span>,s)-&gt;len = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdsinclen</code>函数增加sds的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> inline <span class="keyword">void</span> <span class="title">sdsinclen</span><span class="params">(sds s, size_t inc)</span> </span>&#123;</span><br><span class="line">    unsigned <span class="keyword">char</span> flags = s[-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;  <span class="comment">// 同上，获取sds类型</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            &#123;</span><br><span class="line">                unsigned <span class="keyword">char</span> *fp = ((unsigned <span class="keyword">char</span>*)s)-<span class="number">1</span>;         <span class="comment">// fp是sdshdr5的flags的指针</span></span><br><span class="line">                unsigned <span class="keyword">char</span> newlen = SDS_TYPE_5_LEN(flags)+inc;  <span class="comment">// 计算出newlen</span></span><br><span class="line">                *fp = SDS_TYPE_5 | (newlen &lt;&lt; SDS_TYPE_BITS);      <span class="comment">// 同sdssetlen</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            SDS_HDR(<span class="number">8</span>,s)-&gt;len += inc;  <span class="comment">// 直接增加header中的len</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            SDS_HDR(<span class="number">16</span>,s)-&gt;len += inc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            SDS_HDR(<span class="number">32</span>,s)-&gt;len += inc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            SDS_HDR(<span class="number">64</span>,s)-&gt;len += inc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdsalloc</code>函数获取sds容量，sdsalloc() = sdsavail() + sdslen()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> inline size_t <span class="title">sdsalloc</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    unsigned <span class="keyword">char</span> flags = s[-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;  <span class="comment">// 同上，获取sds类型</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:  <span class="comment">// 其他type直接返回header的alloc属性</span></span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>,s)-&gt;alloc;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>,s)-&gt;alloc;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>,s)-&gt;alloc;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>,s)-&gt;alloc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdssetalloc</code>函数设置sds容量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> inline <span class="keyword">void</span> <span class="title">sdssetalloc</span><span class="params">(sds s, size_t newlen)</span> </span>&#123;</span><br><span class="line">    unsigned <span class="keyword">char</span> flags = s[-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;  <span class="comment">// 同上，获取sds类型</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="comment">/* Nothing to do, this type has no total allocation info. */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:  <span class="comment">// 其他type直接设置header的alloc属性</span></span><br><span class="line">            SDS_HDR(<span class="number">8</span>,s)-&gt;alloc = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            SDS_HDR(<span class="number">16</span>,s)-&gt;alloc = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            SDS_HDR(<span class="number">32</span>,s)-&gt;alloc = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            SDS_HDR(<span class="number">64</span>,s)-&gt;alloc = newlen;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是<code>sds.h</code>中声明的函数原型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, size_t initlen)</span></span>;  <span class="comment">// 创建一个长度为initlen的sds，使用init指向的字符数组来初始化数据</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span></span>;  <span class="comment">// 内部调用sdsnewlen，创建一个sds</span></span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span></span>;            <span class="comment">// 返回一个空的sds</span></span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;       <span class="comment">// 拷贝一个sds并返回这个拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span></span>;           <span class="comment">// 释放一个sds</span></span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, size_t len)</span></span>;  <span class="comment">// 使一个sds的长度增长到一个指定的值，末尾未使用的空间用0填充</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, size_t len)</span></span>;  <span class="comment">// 连接一个sds和一个二进制安全的数据t，t的长度为len</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span>;  <span class="comment">// 连接一个sds和一个二进制安全的数据t，内部调用sdscatlen</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span></span>;  <span class="comment">// 连接两个sds</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, size_t len)</span></span>;  <span class="comment">// 把二进制安全的数据t复制到一个sds的内存中，覆盖原来的字符串，t的长度为len</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span>;  <span class="comment">// 把二进制安全的数据t复制到一个sds的内存中，覆盖原来的字符串，内部调用sdscpylen</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过fmt指定个格式来格式化字符串 */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span>;</span><br><span class="line">#ifdef __GNUC__</span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function">    <span class="title">__attribute__</span><span class="params">((format(printf, <span class="number">2</span>, <span class="number">3</span>)</span>))</span>;</span><br><span class="line">#else</span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdscatfmt</span><span class="params">(sds s, <span class="keyword">char</span> <span class="keyword">const</span> *fmt, ...)</span></span>;  <span class="comment">// 将格式化后的任意数量个字符串追加到s的末尾</span></span><br><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span></span>;  <span class="comment">// 删除sds两端由cset指定的字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;  <span class="comment">// 通过区间[start, end]截取字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span></span>;  <span class="comment">// 根据字符串占用的空间来更新len</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span></span>;  <span class="comment">// 把字符串的第一个字符设置为'\0'，把字符串设置为空字符串，但是并不释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(<span class="keyword">const</span> sds s1, <span class="keyword">const</span> sds s2)</span></span>;  <span class="comment">// 比较两个sds的相等性</span></span><br><span class="line">sds *sdssplitlen(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> len, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count);  <span class="comment">// 使用分隔符sep对s进行分割，返回一个sds数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span></span>;  <span class="comment">// 释放sds数组tokens中的count个sds</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span></span>;  <span class="comment">// 将sds所有字符转换为小写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span></span>;  <span class="comment">// 将sds所有字符转换为大写</span></span><br><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;  <span class="comment">// 将长整型转换为字符串</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatrepr</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *p, size_t len)</span></span>;  <span class="comment">// 将长度为len的字符串p以带引号的格式追加到s的末尾</span></span><br><span class="line">sds *sdssplitargs(<span class="keyword">const</span> <span class="keyword">char</span> *line, <span class="keyword">int</span> *argc); <span class="comment">// 将一行文本分割成多个参数，参数的个数存在argc</span></span><br><span class="line"><span class="function">sds <span class="title">sdsmapchars</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to, size_t setlen)</span></span>;  <span class="comment">// 将字符串s中，出现存在from中指定的字符，都转换成to中的字符，from与to有位置关系</span></span><br><span class="line"><span class="function">sds <span class="title">sdsjoin</span><span class="params">(<span class="keyword">char</span> **argv, <span class="keyword">int</span> argc, <span class="keyword">char</span> *sep)</span></span>;  <span class="comment">// 使用分隔符sep将字符数组argv拼接成一个字符串</span></span><br><span class="line"><span class="function">sds <span class="title">sdsjoinsds</span><span class="params">(sds *argv, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *sep, size_t seplen)</span></span>;  <span class="comment">// 和sdsjoin类似，不过拼接的是一个sds数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 暴露出来作为用户API的低级函数 */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, size_t addlen)</span></span>;  <span class="comment">// 为指定的sds扩充大小，扩充的大小为addlen</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsIncrLen</span><span class="params">(sds s, <span class="keyword">int</span> incr)</span></span>;  <span class="comment">// 根据incr增加或减少sds的字符串长度</span></span><br><span class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span></span>;  <span class="comment">// 移除一个sds的空闲空间</span></span><br><span class="line"><span class="function">size_t <span class="title">sdsAllocSize</span><span class="params">(sds s)</span></span>;  <span class="comment">// 获取一个sds的总大小（包括header、字符串、末尾的空闲空间和隐式项目）</span></span><br><span class="line"><span class="keyword">void</span> *sdsAllocPtr(sds s);  <span class="comment">// 获取一个sds确切的内存空间的指针（一般的sds引用都是一个指向其字符串的指针）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 导出供外部程序调用的sds的分配/释放函数 */</span></span><br><span class="line"><span class="keyword">void</span> *sds_malloc(size_t size);  <span class="comment">// sds分配器的包装函数，内部调用s_malloc</span></span><br><span class="line"><span class="keyword">void</span> *sds_realloc(<span class="keyword">void</span> *ptr, size_t size);  <span class="comment">// sds分配器的包装函数，内部调用s_realloc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sds_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;  <span class="comment">// sds释放器的包装函数，内部调用s_free</span></span><br></pre></td></tr></table></figure>
<h2 id="sds实现详解"><a href="#sds实现详解" class="headerlink" title="sds实现详解"></a>sds实现详解</h2><p>下面列举了一部分是<code>sds.c</code>中的函数定义，由于<code>sds.c</code>代码量较多（超过1500行），其中有一些函数是帮助函数，或测试代码，这里只列举比较重要的函数详细解释。</p>
<p><code>sdsHdrSize</code>函数获取sds header的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> inline <span class="keyword">int</span> <span class="title">sdsHdrSize</span><span class="params">(<span class="keyword">char</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type&amp;SDS_TYPE_MASK) &#123;  <span class="comment">// 获取sds类型</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> sizeof(struct sdshdr5);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> sizeof(struct sdshdr8);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> sizeof(struct sdshdr16);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> sizeof(struct sdshdr32);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> sizeof(struct sdshdr64);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdsReqType</code>函数根据字符串大小判断sds类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> inline <span class="keyword">char</span> <span class="title">sdsReqType</span><span class="params">(size_t string_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_5;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_16;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1l</span>l&lt;&lt;<span class="number">32</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_32;</span><br><span class="line">    <span class="keyword">return</span> SDS_TYPE_64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdsnewlen</code>函数使用init指针指向的数据和initlen的长度创建一个新的sds字符串。如果init指针是NULL，字符串会被初始化为长度为initlen，内容全为0字节。 sds字符串总是以’\0’字符结尾的，所以即使你创建了如下的sds字符串：<br>  mystring = sdsnewlen(“abc”,3);<br>由于这个字符串在结尾隐式包含了一个’\0’，所以你可以使用printf()函数打印它。然而，sds字符串是二进制安全的，并且可以在中间包含’\0’字符，因为在sds字符串header中保存了字符串长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, size_t initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);  <span class="comment">// 使用初始长度判断该创建哪种类型的sds字符串</span></span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">     * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="comment">/* 空字符串一般在创建后都会追加数据进去（完全可能大于32个字节），使用type 8的字符串类型要优于type 5 */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);  <span class="comment">// 获取header长度</span></span><br><span class="line">    unsigned <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line"></span><br><span class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>);  <span class="comment">// 为sds字符串header申请内存空间，大小为：头部大小+初始化长度大小+1（其中1是为'\0'留的）</span></span><br><span class="line">    <span class="keyword">if</span> (!init)  <span class="comment">// 初始数据指针为NULL</span></span><br><span class="line">        memset(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>);  <span class="comment">// 把整个sds的内容都设置为0</span></span><br><span class="line">    <span class="keyword">if</span> (sh == NULL) <span class="keyword">return</span> NULL;  <span class="comment">// 申请内存失败返回NULL</span></span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen;  <span class="comment">// 字符串指针</span></span><br><span class="line">    fp = ((unsigned <span class="keyword">char</span>*)s)-<span class="number">1</span>;  <span class="comment">// flags指针</span></span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;  <span class="comment">// 根据sds类型设置header中的数据</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        memcpy(s, init, initlen);  <span class="comment">// 将初始化数据指针init指向的数据拷贝到字符串中</span></span><br><span class="line">    s[initlen] = <span class="string">'\0'</span>;  <span class="comment">// 设置最后一个字节为'\0'</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdsempty</code>函数创建一个空sds(字符串长度为0)字符串。即使在这种情况下，字符串也总是有一个隐式的’\0’结束符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">""</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdsnew</code>函数使用一个以’\0’为结束符的C字符串创建一个新的sds字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    size_t initlen = (init == NULL) ? <span class="number">0</span> : strlen(init);  <span class="comment">// 初始化数据指针为NULL时，字符串长度为0</span></span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdsdup</code>函数复制一个sds字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(s, sdslen(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdsfree</code>函数释放一个sds字符串，如果该字符串是NULL则什么都不做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == NULL) <span class="keyword">return</span>;</span><br><span class="line">    s_free((<span class="keyword">char</span>*)s-sdsHdrSize(s[-<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdsupdatelen</code>函数使用通过strlen()获取的sds字符串长度来设置sds字符串的长度，所以只考虑到第一个空字符前的字符串长度。当sds字符串被手动修改的时候这个函数很有用，比如下面的例子：<br>  s = sdsnew(“foobar”);<br>  s[2] = ‘\0’;<br>  sdsupdatelen(s);<br>  printf(“%d\n”, sdslen(s));<br>上面的代码输出是”2”，但是如果我们注释掉调用sdsupdatelen()的那行代码，输出则是’6’，因为字符串被强行修改了，但字符串的逻辑长度还是6个字节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> reallen = strlen(s);  <span class="comment">// 获取字符串的真实长度（会取第一个终止符'\0'之前的字符串长度）</span></span><br><span class="line">    sdssetlen(s, reallen);  <span class="comment">// 重新设置sds的字符串长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdsclear</code>函数就地修改一个sds字符串为空（长度为0）。然而，所有当前的缓冲区都不会被释放，而是设置成空闲空间，所以下一次追加操作可以使用原来的空闲空间而不需要分配空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    sdssetlen(s, <span class="number">0</span>);  <span class="comment">// 设置sds字符串的长度为0</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">'\0'</span>;  <span class="comment">// 设置字符串首地址为终止符'\0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdsMakeRoomFor</code>函数扩充sds字符串的空闲空间，调用此函数后，可以保证在原sds字符串后面扩充了addlen个字节的空间，外加1个字节的终止符。注意：这个函数不会改变调用sdslen()返回的字符串长度，仅仅改变了空闲空间的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, size_t addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    size_t avail = sdsavail(s);  <span class="comment">// 获取sds字符串的空闲空间大小</span></span><br><span class="line">    size_t len, newlen;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[-<span class="number">1</span>] &amp; SDS_TYPE_MASK;  <span class="comment">// 获取sds字符串类型</span></span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前空闲空间大于addlen，就不做扩充操作，直接返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    len = sdslen(s);  <span class="comment">// sds字符串当前长度</span></span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);  <span class="comment">// sds字符串header指针</span></span><br><span class="line">    newlen = (len+addlen);  <span class="comment">// 扩充后的新长度</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)  <span class="comment">// 扩充后的长度小于sds最大预分配长度时，把newlen加倍以防止短期内再扩充</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 否则直接加上sds最大预分配长度</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    type = sdsReqType(newlen);  <span class="comment">// 获取新长度下的sds字符串类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 不要使用type 5：由于用户向字符串追加数据时，type 5的字符串无法保存空闲空间，所以</span></span><br><span class="line"><span class="comment">     * 每次追加数据时都要调用sdsMakeRoomFor() */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;  <span class="comment">// 比较短的字符串一律用type 8</span></span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type);  <span class="comment">// 计算sds字符串header长度</span></span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;  <span class="comment">// 字符串类型不变的情况下</span></span><br><span class="line">        newsh = s_realloc(sh, hdrlen+newlen+<span class="number">1</span>);  <span class="comment">// 在原header指针上重新分配新的大小</span></span><br><span class="line">        <span class="keyword">if</span> (newsh == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;  <span class="comment">// 更新字符串指针</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 一旦header大小变化，需要把字符串前移，并且不能使用realloc */</span></span><br><span class="line">        newsh = s_malloc(hdrlen+newlen+<span class="number">1</span>);  <span class="comment">// 新开辟一块内存</span></span><br><span class="line">        <span class="keyword">if</span> (newsh == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">        memcpy((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);  <span class="comment">// 把原始sds字符串的内容复制到新的内存区域</span></span><br><span class="line">        s_free(sh);  <span class="comment">// 释放原始sds字符串的头指针指向的内存</span></span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;  <span class="comment">// 更新sds字符串指针</span></span><br><span class="line">        s[-<span class="number">1</span>] = type;  <span class="comment">// 更新flags字节信息</span></span><br><span class="line">        sdssetlen(s, len);  <span class="comment">// 更新sds字符串header中的len</span></span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, newlen);  <span class="comment">// 更新sds字符串header中的alloc</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdsRemoveFreeSpace</code>函数重新分配sds字符串的空间，保证结尾没有空闲空间。其中包含的字符串不变，但下一次进行字符串连接操作时需要一次空间重新分配。调用此函数后，原来作为参数传入的sds字符串的指针不再是有效的，所有引用必须被替换为函数返回的新指针。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[-<span class="number">1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line">    size_t len = sdslen(s);  <span class="comment">// 字符串真正的长度</span></span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);  <span class="comment">// 获取sds字符串header指针</span></span><br><span class="line"></span><br><span class="line">    type = sdsReqType(len);  <span class="comment">// 计算字符串的新type</span></span><br><span class="line">    hdrlen = sdsHdrSize(type);  <span class="comment">// 计算字符串的新header大小</span></span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;  <span class="comment">// 字符串类型不变</span></span><br><span class="line">        newsh = s_realloc(sh, hdrlen+len+<span class="number">1</span>);  <span class="comment">// realloc，大小更新为：header大小+真实字符串大小+1</span></span><br><span class="line">        <span class="keyword">if</span> (newsh == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;  <span class="comment">// 更新sds字符串指针</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 字符串类型改变</span></span><br><span class="line">        newsh = s_malloc(hdrlen+len+<span class="number">1</span>);  <span class="comment">// 新开辟一块内存</span></span><br><span class="line">        <span class="keyword">if</span> (newsh == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">        memcpy((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);  <span class="comment">// 复制数据到新内存中</span></span><br><span class="line">        s_free(sh);  <span class="comment">// 释放原始的sds字符串内存</span></span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen; <span class="comment">// 更新sds字符串指针</span></span><br><span class="line">        s[-<span class="number">1</span>] = type;  <span class="comment">// 更新flags</span></span><br><span class="line">        sdssetlen(s, len);  <span class="comment">// 更新sds字符串header中的len</span></span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, len);  <span class="comment">// 更新sds字符串header中的alloc</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdsAllocSize</code>函数返回指定sds字符串的分配空间大小，包括:<br>  1) sds header大小。<br>  2) 字符串本身的大小。<br>  3) 末尾的空闲空间大小（如果有的话）。<br>  4) 隐式包含的终止符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_t <span class="title">sdsAllocSize</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    size_t alloc = sdsalloc(s);  <span class="comment">// 获取sds header的alloc</span></span><br><span class="line">    <span class="keyword">return</span> sdsHdrSize(s[-<span class="number">1</span>])+alloc+<span class="number">1</span>;  <span class="comment">// header大小+alloc（字符串大小+空闲空间大小）+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdsAllocPtr</code>函数返回sds分配空间的首地址（一般来说sds字符串的指针是其字符串缓冲区的首地址）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *sdsAllocPtr(sds s) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*) (s-sdsHdrSize(s[-<span class="number">1</span>]));  <span class="comment">// 字符串缓冲区的首地址减去header大小即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdsIncrLen</code>函数取决于’incr’参数，此函数增加sds字符串的长度或减少剩余空闲空间的大小。同时也将在新字符串的末尾设置终止符。此函数用来修正调用sdsMakeRoomFor()函数之后字符串的长度，在当前字符串后追加数据这些需要设置字符串新长度的操作之后。注意：可以使用一个负的增量值来右对齐字符串。使用sdsIncrLen()和sdsMakeRoomFor()函数可以用来满足如下模式，从内核中直接复制一部分字节到一个sds字符串的末尾，且无须把数据先复制到一个中间缓冲区中：<br>  oldlen = sdslen(s);<br>  s = sdsMakeRoomFor(s, BUFFER_SIZE);<br>  nread = read(fd, s+oldlen, BUFFER_SIZE);<br>  … check for nread &lt;= 0 and handle it …<br>  sdsIncrLen(s, nread);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsIncrLen</span><span class="params">(sds s, <span class="keyword">int</span> incr)</span> </span>&#123;</span><br><span class="line">    unsigned <span class="keyword">char</span> flags = s[-<span class="number">1</span>];</span><br><span class="line">    size_t len;</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;  <span class="comment">// 判断sds字符串类型</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            unsigned <span class="keyword">char</span> *fp = ((unsigned <span class="keyword">char</span>*)s)-<span class="number">1</span>;  <span class="comment">// flags指针</span></span><br><span class="line">            unsigned <span class="keyword">char</span> oldlen = SDS_TYPE_5_LEN(flags); <span class="comment">// 原始字符串大小</span></span><br><span class="line">            <span class="keyword">assert</span>((incr &gt; <span class="number">0</span> &amp;&amp; oldlen+incr &lt; <span class="number">32</span>) || (incr &lt; <span class="number">0</span> &amp;&amp; oldlen &gt;= (unsigned <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            *fp = SDS_TYPE_5 | ((oldlen+incr) &lt;&lt; SDS_TYPE_BITS);  <span class="comment">// 更新flags中字符串大小的比特位</span></span><br><span class="line">            len = oldlen+incr;  <span class="comment">// 更新header的len</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);  <span class="comment">// 获取sds字符串的header指针</span></span><br><span class="line">            <span class="keyword">assert</span>((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (unsigned <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            len = (sh-&gt;len += incr);  <span class="comment">// 更新header的len</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            <span class="keyword">assert</span>((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (unsigned <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            len = (sh-&gt;len += incr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            <span class="keyword">assert</span>((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= (unsigned <span class="keyword">int</span>)incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (unsigned <span class="keyword">int</span>)(-incr)));</span><br><span class="line">            len = (sh-&gt;len += incr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            <span class="keyword">assert</span>((incr &gt;= <span class="number">0</span> &amp;&amp; sh-&gt;alloc-sh-&gt;len &gt;= (uint64_t)incr) || (incr &lt; <span class="number">0</span> &amp;&amp; sh-&gt;len &gt;= (uint64_t)(-incr)));</span><br><span class="line">            len = (sh-&gt;len += incr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: len = <span class="number">0</span>; <span class="comment">/* Just to avoid compilation warnings. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    s[len] = <span class="string">'\0'</span>;  <span class="comment">// 设置终止符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdsgrowzero</code>函数增长一个sds字符串到一个指定长度。扩充出来的不是原来字符串的空间会被设置为0。如果指定的长度比当前长度小，不做任何操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, size_t len)</span> </span>&#123;</span><br><span class="line">    size_t curlen = sdslen(s);  <span class="comment">// 当前字符串长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= curlen) <span class="keyword">return</span> s;  <span class="comment">// 设置的长度小于当前长度，直接返回原始sds字符串指针</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len-curlen);  <span class="comment">// 扩充sds</span></span><br><span class="line">    <span class="keyword">if</span> (s == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure added region doesn't contain garbage */</span></span><br><span class="line">    <span class="comment">/* 确保新增的区域不包含垃圾数据 */</span></span><br><span class="line">    memset(s+curlen,<span class="number">0</span>,(len-curlen+<span class="number">1</span>)); <span class="comment">/* also set trailing \0 byte */</span></span><br><span class="line">    sdssetlen(s, len);  <span class="comment">// 更新sds字符串header中的len</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdscatlen</code>函数向指定的sds字符串’s’尾部追加由’t’指向的二进制安全的字符串，长度’len’字节。调用此函数后，原来作为参数传入的sds字符串的指针不再是有效的，所有引用必须被替换为函数返回的新指针。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, size_t len)</span> </span>&#123;</span><br><span class="line">    size_t curlen = sdslen(s);  <span class="comment">// 当前字符串长度</span></span><br><span class="line"></span><br><span class="line">    s = sdsMakeRoomFor(s,len);  <span class="comment">// 扩充len字节</span></span><br><span class="line">    <span class="keyword">if</span> (s == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">    memcpy(s+curlen, t, len);  <span class="comment">// 追加数据到原字符串末尾</span></span><br><span class="line">    sdssetlen(s, curlen+len);  <span class="comment">// 更新sds字符串header中的len</span></span><br><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;  <span class="comment">// 设置终止符</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdscat</code>函数追加指定的C字符串到sds字符串’s’的尾部。调用此函数后，原来作为参数传入的sds字符串的指针不再是有效的，所有引用必须被替换为函数返回的新指针。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, strlen(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdscatsds</code>函数追加指定的sds字符串’t’到已经存在的sds字符串’s’末尾。调用此函数后，原来作为参数传入的sds字符串的指针不再是有效的，所有引用必须被替换为函数返回的新指针。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, sdslen(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdscpylen</code>函数把由’t’指向的二进制安全的字符串复制到sds字符串’s’的内存空间中，长度为’len’，覆盖原来的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, size_t len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sdsalloc(s) &lt; len) &#123;</span><br><span class="line">        s = sdsMakeRoomFor(s,len-sdslen(s));  <span class="comment">// 原sds总空间不足就扩充</span></span><br><span class="line">        <span class="keyword">if</span> (s == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(s, t, len);  <span class="comment">// 将t指向的数据直接覆盖s</span></span><br><span class="line">    s[len] = <span class="string">'\0'</span>;  <span class="comment">// 设置终止符</span></span><br><span class="line">    sdssetlen(s, len);  <span class="comment">// 更新sds字符串header中的len</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sdscpy</code>函数和sdscpylen()函数类似，但是’t’指向的必须是一个以’\0’结尾的字符串，所以可以用strlen()获取该字符串长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscpylen(s, t, strlen(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        <!-- <h3>看了文章如果觉得喜欢的话可以捐赠哦！支付宝二维码：</h3>
        <img src="/assets/images/post_imgs/code_alipay.png" width=300 height=300> -->
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/源码分析/">源码分析</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>

      
        
	<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '4010e28e5153ab82b468',
        clientSecret: '217df2318bd891ba87b82dae5d67d7ae77bc1f17',
        id: md5(location.href),
        repo: 'nullcc-blog-comments',
        owner: 'nullcc',
        admin: 'nullcc',
        distractionFreeMode: 'true'
    })
    gitalk.render('gitalk-container')
</script>


      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/11/10/谈谈IO中的同步、异步、阻塞、非阻塞和IO多路复用/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          谈谈I/O中的同步、异步、阻塞、非阻塞和I/O多路复用
        
      </div>
    </a>
  
  
    <a href="/2017/11/10/Redis中的底层数据结构(1)——双端链表/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Redis中的底层数据结构(1)——双端链表</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
      <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#sds字符串和C原生字符串的对比"><span class="nav-number">1.</span> <span class="nav-text">sds字符串和C原生字符串的对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sds头文件详解"><span class="nav-number">2.</span> <span class="nav-text">sds头文件详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sds实现详解"><span class="nav-number">3.</span> <span class="nav-text">sds实现详解</span></a></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2023 张先森的代码小屋 All Rights Reserved.
        
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>













  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>

  <!-- 百度统计 -->
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c3ffa09eef07ac510ef2ab126054b1cd";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
    
</body>
</html>
