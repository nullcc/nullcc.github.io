<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Redis中的底层数据结构(3)——字典(dict) | 张先森的代码小屋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="Redis数据结构">
  
  
  
  
  <meta name="description" content="本文将详细说明Redis中字典的实现。 在Redis源码（这里使用3.2.11版本）中，字典的实现在dict.h和dict.c中。">
<meta name="keywords" content="Redis,数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis中的底层数据结构(3)——字典(dict)">
<meta property="og:url" content="https://nullcc.github.io/2017/11/15/Redis中的底层数据结构(3)——字典(dict)/index.html">
<meta property="og:site_name" content="张先森的代码小屋">
<meta property="og:description" content="本文将详细说明Redis中字典的实现。 在Redis源码（这里使用3.2.11版本）中，字典的实现在dict.h和dict.c中。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://nullcc.github.io/assets/images/post_imgs/redis_data_structure_4.png">
<meta property="og:updated_time" content="2022-04-15T03:41:13.019Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis中的底层数据结构(3)——字典(dict)">
<meta name="twitter:description" content="本文将详细说明Redis中字典的实现。 在Redis源码（这里使用3.2.11版本）中，字典的实现在dict.h和dict.c中。">
<meta name="twitter:image" content="https://nullcc.github.io/assets/images/post_imgs/redis_data_structure_4.png">
  
    <link rel="alternate" href="/atom.xml" title="张先森的代码小屋" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="124px" height="124px" alt="Hike News" src=" /css/images/logo.jpg">
              </a>
            
          </h1>
          
          
            <div class="site-description">明镜止水</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-Redis中的底层数据结构(3)——字典(dict)" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      Redis中的底层数据结构(3)——字典(dict)
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2017/11/15/Redis中的底层数据结构(3)——字典(dict)/" class="article-date">
	  <time datetime="2017-11-14T16:00:00.000Z" itemprop="datePublished">十一月 15, 2017</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/源码分析/">源码分析</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文将详细说明Redis中字典的实现。</p>
<p>在Redis源码（这里使用3.2.11版本）中，字典的实现在<code>dict.h</code>和<code>dict.c</code>中。</p>
<a id="more"></a>
<h2 id="Redis字典概述"><a href="#Redis字典概述" class="headerlink" title="Redis字典概述"></a>Redis字典概述</h2><h3 id="1-Redis字典的数据结构示意图："><a href="#1-Redis字典的数据结构示意图：" class="headerlink" title="1.Redis字典的数据结构示意图："></a>1.Redis字典的数据结构示意图：</h3><p><img src="/assets/images/post_imgs/redis_data_structure_4.png" alt="Redis的字典"></p>
<h3 id="2-Redis字典概述"><a href="#2-Redis字典概述" class="headerlink" title="2.Redis字典概述"></a>2.Redis字典概述</h3><p>dict的type属性是一个dictType类型的结构体指针，dictType结构体包含了字典的哈希函数、复制key、复制value、销毁key、销毁value和比较两个key的函数指针。ht[2]维护了两个dictht，ht[0]和ht[1]。ht[0]主要负责保存字典哈希表的散列数组内容，即一堆dictEntry。ht[1]用于rehash，rehash的内容在之后会详细说明。dictht的<code>table</code>是一个dictEntry指针的数组，这里面的每一个元素都是一个dictEntry，当有新的key-value时，先用哈希函数计算散列值，再将散列值映射到散列数组中，然后用dictEntry包装key-value pair，放入散列数组相应的槽中，如果有多个key的散列值相同，它们将在散列数组中位于同一个槽中，相邻的dictEntry的<code>next</code>指针链接起来，形成一个dictEntry链表，这个链表的头节点保存在散列数组的相应槽中。</p>
<h3 id="3-Redis字典的哈希函数"><a href="#3-Redis字典的哈希函数" class="headerlink" title="3.Redis字典的哈希函数"></a>3.Redis字典的哈希函数</h3><p><code>dict.c</code>源码中提供了三种哈希函数，分别是：</p>
<p>1). <code>dictIntHashFunction</code>: Thomas Wang’s 32 bit Mix哈希算法，对一个无符号整型数进行一系列的移位运算，效率较高。<br><br>2). <code>dictGenHashFunction</code>: Austin Appleby的MurmurHash2算法。<br><br>3). <code>dictGenCaseHashFunction</code>: 一个对大小写不敏感的哈希函数（基于djb哈希算法）。<br><br>有兴趣的同学可以直接阅读<code>dict.c</code>的hash functions部分。</p>
<h3 id="4-Rehash过程"><a href="#4-Rehash过程" class="headerlink" title="4.Rehash过程"></a>4.Rehash过程</h3><p>由于一个字典哈希表的散列数组具有一个初始的大小，这在<code>dict.h</code>中有定义：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define DICT_HT_INITIAL_SIZE     4</span><br></pre></td></tr></table></figure></p>
<p>之后如果向该字典中添加更多的key-value pair，就需要扩充散列数组的大小，另外如果一个字典原来有很多key，之后又删除了一部分key，为了节省内存，也会对该字典进行缩容。这就需要进行rehash。rehash将字典原来的key重新计算散列值并映射到一个新的散列数组（大小发生改变）上。rehash赋予字典动态扩容/缩容的能力。</p>
<p>Redis处于非rehash时，字典中的key都保存在ht[0]的散列数组中，当某一时刻需要进行rehash时，会在ht[1]上扩大或缩小散列数组的大小，接着把ht[0]里的所有key重新计算散列值并映射到ht[1]的散列数组中。当完成所有key的rehash后，将ht[0]和ht[1]对调，原来的ht[1]经过rehash成为了新的ht[0]。</p>
<p>Redis的rehash还有一个值得注意的特点，由于rehash可能比较耗时，导致Redis无法处理其他事情，因此Redis不会一次性一个字典做全量rehash，而是把rehash操作分摊到很多时间点上，比如在字典中查找、新增、删除key-value pair时，执行一步rehash过程，这可以称为增量rehash。在后面列出的代码中将会看到这是如何实现的。</p>
<h2 id="字典中的数据结构"><a href="#字典中的数据结构" class="headerlink" title="字典中的数据结构"></a>字典中的数据结构</h2><p>以下是<code>dict.h</code>中的字典相关的结构体代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 保存key-value对的结构体 */</span></span><br><span class="line">typedef struct dictEntry &#123;</span><br><span class="line">    <span class="keyword">void</span> *key;         <span class="comment">// 字典键</span></span><br><span class="line">    union &#123;            <span class="comment">// value是一个联合，只能存放下列类型值的其中一个</span></span><br><span class="line">        <span class="keyword">void</span> *val;     <span class="comment">// 空类型指针一枚</span></span><br><span class="line">        uint64_t u64;  <span class="comment">// 无符号整型一枚</span></span><br><span class="line">        int64_t s64;   <span class="comment">// 有符号整型一枚</span></span><br><span class="line">        <span class="keyword">double</span> d;      <span class="comment">// 双精度浮点数一枚</span></span><br><span class="line">    &#125; v;</span><br><span class="line">    struct dictEntry *next;  <span class="comment">// 指向下一个键值对节点的指针</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字典操作的方法 */</span></span><br><span class="line">typedef struct dictType &#123;</span><br><span class="line">    <span class="function">unsigned <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;     <span class="comment">// 哈希函数指针，使用key来计算哈希值</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);  <span class="comment">// 复制key的函数指针</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);  <span class="comment">// 复制value的函数指针</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);  <span class="comment">// 比较两个key的函数指针</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);  <span class="comment">// 销毁key的函数指针</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);  <span class="comment">// 销毁value的函数指针</span></span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这是我们的哈希表结构。每个字典都有两个这样的结构，因为</span></span><br><span class="line"><span class="comment"> * 我们实现了从旧哈希表迁移数据到新哈希表的增量rehash。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 哈希表结构 */</span></span><br><span class="line">typedef struct dictht &#123;</span><br><span class="line">    dictEntry **table;       <span class="comment">// 散列数组</span></span><br><span class="line">    unsigned <span class="keyword">long</span> size;      <span class="comment">// 散列数组长度</span></span><br><span class="line">    unsigned <span class="keyword">long</span> sizemask;  <span class="comment">// 散列数组长度掩码 = 散列数组长度-1</span></span><br><span class="line">    unsigned <span class="keyword">long</span> used;      <span class="comment">// 散列数组中已经被使用的节点数量</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字典结构 */</span></span><br><span class="line">typedef struct dict &#123;</span><br><span class="line">    dictType *type;  <span class="comment">// 字典类型</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;  <span class="comment">// 私有数据</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];    <span class="comment">// 一个字典中有两个哈希表，原因如上述</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx;  <span class="comment">// 数据rehash的当前索引位置</span></span><br><span class="line">    <span class="keyword">int</span> iterators;   <span class="comment">// 当前使用的迭代器数量</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果safe被设置成1则表示这是一个安全的迭代器，这意味着你可以在迭代字典时调用</span></span><br><span class="line"><span class="comment"> * dictAdd、dictFind等一些函数。否则这是一个不安全的迭代器，只能在迭代时调用</span></span><br><span class="line"><span class="comment"> * dictNext()函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 字典迭代器 */</span></span><br><span class="line">typedef struct dictIterator &#123;</span><br><span class="line">    dict *d;                       <span class="comment">// 字典指针</span></span><br><span class="line">    <span class="keyword">long</span> index;                    <span class="comment">// 散列数组的当前索引值</span></span><br><span class="line">    <span class="keyword">int</span> table, safe;               <span class="comment">// 哈希表编号（0／1）和安全标志</span></span><br><span class="line">    dictEntry *entry, *nextEntry;  <span class="comment">// 当前键值对结构体指针，下一个键值对结构体指针</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;         <span class="comment">// 字典的指纹</span></span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure>
<p>以下是<code>dict.h</code>中的函数原型，宏部分只列出了<code>DICT_HT_INITIAL_SIZE</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 散列数组的初始大小 */</span></span><br><span class="line">#define DICT_HT_INITIAL_SIZE     4</span><br><span class="line"></span><br><span class="line">#define dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)  // 获取指定key的哈希值</span><br><span class="line">#define dictGetKey(he) ((he)-&gt;key)                        // 获取指定节点的key</span><br><span class="line">#define dictGetVal(he) ((he)-&gt;v.val)                      // 获取指定节点的value</span><br><span class="line">#define dictGetSignedIntegerVal(he) ((he)-&gt;v.s64)         // 获取指定节点的value，值为signed int</span><br><span class="line">#define dictGetUnsignedIntegerVal(he) ((he)-&gt;v.u64)       // 获取指定节点的value，值为unsigned int</span><br><span class="line">#define dictGetDoubleVal(he) ((he)-&gt;v.d)                  // 获取指定节点的value，值为double</span><br><span class="line">#define dictSlots(d) ((d)-&gt;ht[0].size+(d)-&gt;ht[1].size)    // 获取字典中哈希表的总长度，总长度=哈希表1散列数组长度+哈希表2散列数组长度</span><br><span class="line">#define dictSize(d) ((d)-&gt;ht[0].used+(d)-&gt;ht[1].used)     // 获取字典中哈希表已被使用的节点数量，已被使用的节点数量=哈希表1散列数组已被使用的节点数量+哈希表2散列数组已被使用的节点数量</span><br><span class="line">#define dictIsRehashing(d) ((d)-&gt;rehashidx != -1)         // 字典当前是否正在进行rehash操作</span><br><span class="line"></span><br><span class="line"><span class="comment">/* API */</span></span><br><span class="line">dict *dictCreate(dictType *type, <span class="keyword">void</span> *privDataPtr);  <span class="comment">// 创建一个字典</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, unsigned <span class="keyword">long</span> size)</span></span>;          <span class="comment">// 扩充字典大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span>;           <span class="comment">// 向字典中添加键值对</span></span><br><span class="line">dictEntry *dictAddRaw(dict *d, <span class="keyword">void</span> *key);            <span class="comment">// 向字典中添加一个只有key的dictEntry</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span>;       <span class="comment">// 设置/替换指定key的value（key不存在就设置key-value，存在则替换value）</span></span><br><span class="line">dictEntry *dictReplaceRaw(dict *d, <span class="keyword">void</span> *key);        <span class="comment">// 和dictReplace，设置/替换指定key（只设置key）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;             <span class="comment">// 根据key删除字典中的一个key-value对</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDeleteNoFree</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;       <span class="comment">// 根据key删除字典中的一个key-value对，但并不释放相应的key和value</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictRelease</span><span class="params">(dict *d)</span></span>;                            <span class="comment">// 释放一个字典</span></span><br><span class="line">dictEntry * dictFind(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key);       <span class="comment">// 根据key在字典中查找一个key-value对</span></span><br><span class="line"><span class="keyword">void</span> *dictFetchValue(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key);       <span class="comment">// 根据key从字典中获取它对应的value</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span><span class="params">(dict *d)</span></span>;                              <span class="comment">// 重新计算并设置字典的哈希数组大小，调整到能包含所有元素的最小大小</span></span><br><span class="line">dictIterator *dictGetIterator(dict *d);               <span class="comment">// 获取一个字典的普通（非安全）迭代器</span></span><br><span class="line">dictIterator *dictGetSafeIterator(dict *d);           <span class="comment">// 获取一个字典的安全迭代器</span></span><br><span class="line">dictEntry *dictNext(dictIterator *iter);              <span class="comment">// 获取迭代器的下一个key-value对</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span></span>;         <span class="comment">// 释放字典迭代器</span></span><br><span class="line">dictEntry *dictGetRandomKey(dict *d);                 <span class="comment">// 随机获取字典中的一个key-value对</span></span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGetSomeKeys</span><span class="params">(dict *d, dictEntry **des, unsigned <span class="keyword">int</span> count)</span></span>;  <span class="comment">// 从字典中随机取样count个key-value对</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictGetStats</span><span class="params">(<span class="keyword">char</span> *buf, size_t bufsize, dict *d)</span></span>;  <span class="comment">// 获取字典状态</span></span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGenHashFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> len)</span></span>;  <span class="comment">// 一种哈希算法</span></span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGenCaseHashFunction</span><span class="params">(<span class="keyword">const</span> unsigned <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span>;  <span class="comment">// 对大小写不敏感的哈希算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEmpty</span><span class="params">(dict *d, <span class="keyword">void</span>(callback)</span><span class="params">(<span class="keyword">void</span>*)</span>)</span>;  <span class="comment">// 清空字典数据并调用回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEnableResize</span><span class="params">(<span class="keyword">void</span>)</span></span>;                     <span class="comment">// 开启字典resize</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictDisableResize</span><span class="params">(<span class="keyword">void</span>)</span></span>;                    <span class="comment">// 禁用字典resize</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span></span>;                  <span class="comment">// 字典rehash</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span></span>;     <span class="comment">// 在ms时间内rehash，超过则停止</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictSetHashFunctionSeed</span><span class="params">(unsigned <span class="keyword">int</span> initval)</span></span>;  <span class="comment">// 设置rehash函数种子</span></span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGetHashFunctionSeed</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 获取rehash函数种子</span></span><br><span class="line"><span class="function">unsigned <span class="keyword">long</span> <span class="title">dictScan</span><span class="params">(dict *d, unsigned <span class="keyword">long</span> v, dictScanFunction *fn, <span class="keyword">void</span> *privdata)</span></span>;  <span class="comment">// 遍历整个字典，每次访问一个元素都会调用fn操作其数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 哈希表类型 */</span></span><br><span class="line">extern dictType dictTypeHeapStringCopyKey;</span><br><span class="line">extern dictType dictTypeHeapStrings;</span><br><span class="line">extern dictType dictTypeHeapStringCopyKeyValue;</span><br></pre></td></tr></table></figure>
<h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><p>在实现部分，将会列出<code>dict.c</code>中比较重要的一些函数定义。</p>
<p>先看<code>dict.c</code>中的一些静态变量和静态函数声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* dictEnableResize()和dictDisableResize()函数允许我们在需要时启用/禁用哈希表的重新规划空间的</span></span><br><span class="line"><span class="comment"> * 功能。这对Redis来说非常重要，因为我们使用写时复制且不希望在有子进程进行保存操作时移动太多内存</span></span><br><span class="line"><span class="comment"> * 中的数据。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 需要注意的是即使dict_can_resize被设置为0，在某些情况下也会触发字典重新规划空间的操作：</span></span><br><span class="line"><span class="comment"> * 当一个哈希表中的元素个数和散列数组（桶）的比例大于dict_force_resize_ratio时，</span></span><br><span class="line"><span class="comment"> * 触发字典重新规划空间的操作。 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> dict_can_resize = <span class="number">1</span>;  <span class="comment">// 字典重新规划空间开关</span></span><br><span class="line"><span class="keyword">static</span> unsigned <span class="keyword">int</span> dict_force_resize_ratio = <span class="number">5</span>;  <span class="comment">// 字典被强制进行重新规划空间时的（元素个数/桶大小）比例</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">_dictExpandIfNeeded</span><span class="params">(dict *ht)</span></span>;  <span class="comment">// 判断字典是否需要扩容</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> unsigned <span class="keyword">long</span> <span class="title">_dictNextPower</span><span class="params">(unsigned <span class="keyword">long</span> size)</span></span>;  <span class="comment">// 字典扩容的大小（字典的容量都是2的整数次方大小），该函数返回大于或等于size的2的整数次方的数字最小的那个</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">_dictKeyIndex</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;  <span class="comment">// 返回指定key在散列数组中的索引值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">_dictInit</span><span class="params">(dict *ht, dictType *type, <span class="keyword">void</span> *privDataPtr)</span></span>;  <span class="comment">// 初始化一个字典</span></span><br></pre></td></tr></table></figure>
<p><code>_dictReset</code>函数重置一个已经被ht_init()函数初始化过的哈希表。注意：这个函数只应该被ht_destroy()函数调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">_dictReset</span><span class="params">(dictht *ht)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ht-&gt;table = NULL;</span><br><span class="line">    ht-&gt;size = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;sizemask = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictCreate</code>函数创建一个哈希表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dict *dictCreate(dictType *type, <span class="keyword">void</span> *privDataPtr)</span><br><span class="line">&#123;</span><br><span class="line">    dict *d = zmalloc(sizeof(*d));  <span class="comment">// 分配内存</span></span><br><span class="line"></span><br><span class="line">    _dictInit(d,type,privDataPtr);  <span class="comment">// 初始化哈希表</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_dictInit</code>函数初始化哈希表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">_dictInit</span><span class="params">(dict *d, dictType *type, <span class="keyword">void</span> *privDataPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">0</span>]);  <span class="comment">// 初始化第一个哈希表</span></span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);  <span class="comment">// 初始化第二个哈希表</span></span><br><span class="line">    d-&gt;type = type;         <span class="comment">// 初始化字典类型</span></span><br><span class="line">    d-&gt;privdata = privDataPtr;  <span class="comment">// 初始化私有数据</span></span><br><span class="line">    d-&gt;rehashidx = -<span class="number">1</span>;  <span class="comment">// 初始化rehash索引</span></span><br><span class="line">    d-&gt;iterators = <span class="number">0</span>;  <span class="comment">// 初始化字典迭代器</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictResize</code>函数重新计算并设置字典的哈希数组大小，调整到能包含所有元素的最小大小，保持已使用节点数量/桶大小的比率接近&lt;=1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minimal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;  <span class="comment">// 禁用字典resize或当前字典正在rehash时返回错误</span></span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;  <span class="comment">// 已使用节点的数量</span></span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)  <span class="comment">// 已使用节点数量小于散列数组的初始大小时，新空间大小设置为散列数组的初始大小</span></span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);  <span class="comment">// 扩充字典大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictExpand</code>函数扩充或创建哈希表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, unsigned <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictht n; <span class="comment">/* the new hash table */</span></span><br><span class="line">    unsigned <span class="keyword">long</span> realsize = _dictNextPower(size);  <span class="comment">// 计算一个合适的哈希表大小，大小为2的整数次方</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当字典正在进行rehash或字典哈希表中已使用节点数量大于size都返回错误 */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 新的空间大小和当前的相同，没必要进行rehash */</span></span><br><span class="line">    <span class="keyword">if</span> (realsize == d-&gt;ht[<span class="number">0</span>].size) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为新的哈希表分配空间然后初始化它的所有指针为NULL */</span></span><br><span class="line">    n.size = realsize;  <span class="comment">// 新哈希表散列数组长度</span></span><br><span class="line">    n.sizemask = realsize-<span class="number">1</span>;  <span class="comment">// 新哈希表散列数组长度掩码</span></span><br><span class="line">    n.table = zcalloc(realsize*sizeof(dictEntry*));  <span class="comment">// 新哈希表散列数组空间分配</span></span><br><span class="line">    n.used = <span class="number">0</span>;  <span class="comment">// 新哈希表已使用节点数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果d还未被初始化，就不需要rehash，直接把n赋值给字典的第一个哈希表。 */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == NULL) &#123;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 准备第二个哈希表用来进行增量rehash */</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;  <span class="comment">// 1号哈希表现在是被扩展了，数据会从0号哈希表被移动到1号哈希表</span></span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictRehash</code>函数分N步进行增量rehash。当旧哈希表中还有key没移动到新哈希表时，函数返回1，否则返回0。一次rehash过程包含把一个桶从旧哈希表移动到新哈希表（由于我们在同一个桶中使用链表形式保存key-value对，所以一个桶中可能有一个以上的key需要移动）。然而由于哈希表中可能有一部分是空的，并不能保证每一步能对至少一个桶进行rehash，因此我们规定一步中最多只能访问N*10个空桶，否则这么大量的工作可能会造成一段长时间的阻塞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">// 一步rehash中最多访问的空桶的次数</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;  <span class="comment">// 分n步进行rehash</span></span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 注意rehashidx不能越界，因为由于ht[0].used != 0，我们知道还有元素没有被rehash */</span></span><br><span class="line">        <span class="keyword">assert</span>(d-&gt;ht[<span class="number">0</span>].size &gt; (unsigned <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == NULL) &#123;  <span class="comment">// 遇到空桶了</span></span><br><span class="line">            d-&gt;rehashidx++;  <span class="comment">// rehashidx移动到下一个桶</span></span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 当前一次rehash过程遇到的空桶数量等于n*10则直接结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];  <span class="comment">// 获得当前桶中第一个key-value对的指针</span></span><br><span class="line">        <span class="comment">/* 把当前桶中所有的key从旧哈希表移动到新哈希表 */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;  <span class="comment">// 遍历桶中的key-value对链表</span></span><br><span class="line">            unsigned <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;  <span class="comment">// 链表中下一个key-value对的指针</span></span><br><span class="line">            <span class="comment">/* 获取key的哈希值并计算其在新哈希表中桶的索引值 */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];  <span class="comment">// 设置当前key-value对的next指针指向1号哈希表相应桶得地址</span></span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;  <span class="comment">// 将key-value对移动到1号哈希表中（rehash后的新表不会出现一个桶中有多个元素的情况）</span></span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;  <span class="comment">// 扣减0号哈希表已使用节点的数量</span></span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;  <span class="comment">// 增加1号哈希表已使用节点的数量</span></span><br><span class="line">            de = nextde;  <span class="comment">// 移动当前key-value对得指针到链表的下一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = NULL;  <span class="comment">// 当把一个桶中所有得key-value对都rehash以后，设置当前桶指向NULL</span></span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查我们已经对表中所有元素完成rehash操作 */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);  <span class="comment">// 释放0号哈希表的哈希数组</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];  <span class="comment">// 把1号哈希表置为0号</span></span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);  <span class="comment">// 重置1号哈希表</span></span><br><span class="line">        d-&gt;rehashidx = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 完成整个增量式rehash</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 还有元素没有被rehash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>timeInMilliseconds</code>函数获取当前时间戳，单位毫秒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">timeInMilliseconds</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    struct timeval tv;</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv,NULL);</span><br><span class="line">    <span class="keyword">return</span> (((<span class="keyword">long</span> <span class="keyword">long</span>)tv.tv_sec)*<span class="number">1000</span>)+(tv.tv_usec/<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictRehashMilliseconds</code>函数在ms时间内rehash，超过则停止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = timeInMilliseconds();  <span class="comment">// 起始时间</span></span><br><span class="line">    <span class="keyword">int</span> rehashes = <span class="number">0</span>; <span class="comment">// rehash次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(dictRehash(d,<span class="number">100</span>)) &#123;  <span class="comment">// 分100步rehash</span></span><br><span class="line">        rehashes += <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeInMilliseconds()-start &gt; ms) <span class="keyword">break</span>;  <span class="comment">// 超过规定时间则停止rehash</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rehashes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_dictRehashStep</code>函数这个函数会执行一步的rehash操作，只有在哈希表没有安全迭代器时才会使用。当在rehash过程中使用迭代器时，我们不能操作两个哈希表，否则有些元素会被遗漏或者被重复rehash。在字典的键查找或更新操作过程中，如果符合rehash条件，就会触发一次rehash，每次执行一步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">_dictRehashStep</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);  <span class="comment">// 没有迭代器在使用时，执行一次一步的rehash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictAdd</code>函数向目标哈希表添加一个key-value对。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *entry = dictAddRaw(d,key);  <span class="comment">// 先只添加key</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    dictSetVal(d, entry, val);  <span class="comment">// 设置value</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictAddRaw</code>函数是低级别的字典添加操作。此函数添加一个ket-value结构但并不设置value，然后返回这个结构给用户，这可以确保用户按照自己的意愿设置value。此函数还作为用户级别的API直接暴露出来，这主要是为了在散列值内存储非指针类型的数据，比如：<br>  entry = dictAddRaw(dict,mykey);<br>  if (entry != NULL) dictSetSignedIntegerVal(entry,1000);<br>返回值：<br>  如果key已经存在返回NULL。<br>  如果成功添加了key，函数返回hash结构供用户操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">dictEntry *dictAddRaw(dict *d, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);  <span class="comment">// 字典正在进行rehash时，执行一步增量式rehash过程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取key对应的索引值，当key已经存在时_dictKeyIndex函数返回-1，添加失败 */</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key)) == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为新的key-value对分配内存</span></span><br><span class="line"><span class="comment">     * 把新添加的元素放在顶部，这很类似数据库的做法：最近添加的元素有更高的访问频率。 */</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];  <span class="comment">// 如果字典正在rehash，直接把新元素添加到1号哈希表中</span></span><br><span class="line">    entry = zmalloc(sizeof(*entry));  <span class="comment">// 分配内存</span></span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];  </span><br><span class="line">    ht-&gt;table[index] = entry;  <span class="comment">// 把新元素插入哈希表相应索引下链表的头部</span></span><br><span class="line">    ht-&gt;used++;  <span class="comment">// 增加哈希表已使用元素数量</span></span><br><span class="line"></span><br><span class="line">    dictSetKey(d, entry, key);  <span class="comment">// 设置key</span></span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictReplace</code>函数向字典添加一个元素，不管指定的key是否存在。key不存在时，添加后函数返回1，否则返回0，dictReplace()函数此时只更新相应的value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *entry, auxentry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 尝试添加元素，如果key不存在dictAdd()函数调用成功，并返回1。 */</span></span><br><span class="line">    <span class="keyword">if</span> (dictAdd(d, key, val) == DICT_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* key已经存在，获取key-value对 */</span></span><br><span class="line">    entry = dictFind(d, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对key-value对设置新value并释放旧value的内存。需要注意的是这个先设置再释放的顺序很重要，</span></span><br><span class="line"><span class="comment">     * 因为新value很有可能和旧value完全是同一个东西。考虑引用记数的情况，你应该先增加引用记数（设置新value），</span></span><br><span class="line"><span class="comment">     * 再减少引用记数（释放旧value），这个顺序不能被颠倒。 */</span></span><br><span class="line">    auxentry = *entry;</span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line">    dictFreeVal(d, &amp;auxentry);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictReplaceRaw</code>函数是dictAddRaw()的简化版本，它总是返回指定key的key-value对结构，即使key已经存在不能被添加时（这种情况下会直接返回这个已经存在的key的key-value对结构）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dictEntry *dictReplaceRaw(dict *d, <span class="keyword">void</span> *key) &#123;</span><br><span class="line">    dictEntry *entry = dictFind(d,key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> entry ? entry : dictAddRaw(d,key);  <span class="comment">// key存在时返回它的key-value对结构，否则调用dictAddRaw</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictGenericDelete</code>函数查找并移除一个元素。<code>dictDelete</code>函数移除字典中的指定key，并释放相应的key和value。<code>dictDeleteNoFree</code>函数移除字典中的指定key，不释放相应的key和value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dictGenericDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> nofree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unsigned <span class="keyword">int</span> h, idx;</span><br><span class="line">    dictEntry *he, *prevHe;</span><br><span class="line">    <span class="keyword">int</span> table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> DICT_ERR;  <span class="comment">// 字典0号哈希表大小为0时直接返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);  <span class="comment">// 如果字典d正在rehash，执行一步的rehash过程</span></span><br><span class="line">    h = dictHashKey(d, key);  <span class="comment">// 计算key的hash值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;  <span class="comment">// 遍历0号和1号哈希表移除元素</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;  <span class="comment">// 获取key所在的哈希数组索引值</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];  <span class="comment">// 获取idx索引位置指向的第一个entry</span></span><br><span class="line">        prevHe = NULL;</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;  <span class="comment">// 遍历idx索引位置上的entry链表，移除key为指定值的元素</span></span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;  <span class="comment">// 找到该entry</span></span><br><span class="line">                <span class="comment">/* Unlink the element from the list */</span></span><br><span class="line">                <span class="keyword">if</span> (prevHe)</span><br><span class="line">                    prevHe-&gt;next = he-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    d-&gt;ht[table].table[idx] = he-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!nofree) &#123;  <span class="comment">// nofree标志表示是否需要释放这个entry的key和value</span></span><br><span class="line">                    dictFreeKey(d, he);  <span class="comment">// 释放key</span></span><br><span class="line">                    dictFreeVal(d, he);  <span class="comment">// 释放value</span></span><br><span class="line">                &#125;</span><br><span class="line">                zfree(he);  <span class="comment">// 释放enrty</span></span><br><span class="line">                d-&gt;ht[table].used--;  <span class="comment">// 减少已存在的key数量</span></span><br><span class="line">                <span class="keyword">return</span> DICT_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            prevHe = he;  <span class="comment">// 没找到则向后查找</span></span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 如果字典不是正在进行rehash，直接跳过对1号哈希表的搜索，因为只有在rehash过程中，</span></span><br><span class="line"><span class="comment">         * 添加的key-value才会直接写到1号哈希表中，其他时候都是直接写0号哈希表。 */</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_ERR; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDeleteNoFree</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_dictClear</code>函数销毁整个字典。<code>dictRelease</code>函数清空并释放字典。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">_dictClear</span><span class="params">(dict *d, dictht *ht, <span class="keyword">void</span>(callback)</span><span class="params">(<span class="keyword">void</span> *)</span>) </span>&#123;</span><br><span class="line">    unsigned <span class="keyword">long</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free all the elements */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht-&gt;size &amp;&amp; ht-&gt;used &gt; <span class="number">0</span>; i++) &#123;  <span class="comment">// 遍历整个哈希表</span></span><br><span class="line">        dictEntry *he, *nextHe;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callback &amp;&amp; (i &amp; <span class="number">65535</span>) == <span class="number">0</span>) callback(d-&gt;privdata);  <span class="comment">// 销毁私有数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((he = ht-&gt;table[i]) == NULL) <span class="keyword">continue</span>;  <span class="comment">// 跳过没有数据的桶</span></span><br><span class="line">        <span class="keyword">while</span>(he) &#123;  <span class="comment">// 遍历桶中的entry销毁数据</span></span><br><span class="line">            nextHe = he-&gt;next;</span><br><span class="line">            dictFreeKey(d, he);</span><br><span class="line">            dictFreeVal(d, he);</span><br><span class="line">            zfree(he);</span><br><span class="line">            ht-&gt;used--;  <span class="comment">// 递减哈希表中的元素数量</span></span><br><span class="line">            he = nextHe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 释放哈希表的哈希数组 */</span></span><br><span class="line">    zfree(ht-&gt;table);</span><br><span class="line">    <span class="comment">/* 重置整个哈希表 */</span></span><br><span class="line">    _dictReset(ht);</span><br><span class="line">    <span class="keyword">return</span> DICT_OK; <span class="comment">/* never fails */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictRelease</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">0</span>],NULL);</span><br><span class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">1</span>],NULL);</span><br><span class="line">    zfree(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictFind</code>函数查找字典key。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dictEntry *dictFind(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    unsigned <span class="keyword">int</span> h, idx, table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used + d-&gt;ht[<span class="number">1</span>].used == <span class="number">0</span>) <span class="keyword">return</span> NULL;  <span class="comment">// 0号和1号哈希表都没有元素，返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);  <span class="comment">// 如果字典正在rehash，执行一次一步rehash</span></span><br><span class="line">    h = dictHashKey(d, key);  <span class="comment">// 计算key的哈希值</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;  <span class="comment">// 在0号和1号哈希表种查找</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;  <span class="comment">// 计算索引值</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];  <span class="comment">// 获取哈希数组相应索引的第一个元素</span></span><br><span class="line">        <span class="keyword">while</span>(he) &#123;  <span class="comment">// 遍历元素链表，查找key</span></span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> NULL;  <span class="comment">// 如果字典不是正在进行rehash，直接跳过对1号哈希表的搜索，并返回NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictFetchValue</code>函数获取字典中指定key的value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *dictFetchValue(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key) &#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line"></span><br><span class="line">    he = dictFind(d,key);  <span class="comment">// 用key找到key-value entry</span></span><br><span class="line">    <span class="keyword">return</span> he ? dictGetVal(he) : NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictFingerprint</code>函数返回字典的指纹。字典的指纹是一个64位的数字，它表示字典在一个给定时间点的状态，其实就是一些字典熟悉的异或结果。当初始化了一个不安全的迭代器时，我们可以拿到字典的指纹，并且在迭代器被释放时检查这个指纹。如果两个指纹不同就表示迭代器的所有者在迭代过程中进行了被禁止的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dictFingerprint</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> integers[<span class="number">6</span>], hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    integers[<span class="number">0</span>] = (<span class="keyword">long</span>) d-&gt;ht[<span class="number">0</span>].table;  <span class="comment">// 0号哈希表</span></span><br><span class="line">    integers[<span class="number">1</span>] = d-&gt;ht[<span class="number">0</span>].size;          <span class="comment">// 0号哈希表的大小</span></span><br><span class="line">    integers[<span class="number">2</span>] = d-&gt;ht[<span class="number">0</span>].used;          <span class="comment">// 0号哈希表中元素数量</span></span><br><span class="line">    integers[<span class="number">3</span>] = (<span class="keyword">long</span>) d-&gt;ht[<span class="number">1</span>].table;  <span class="comment">// 1号哈希表</span></span><br><span class="line">    integers[<span class="number">4</span>] = d-&gt;ht[<span class="number">1</span>].size;          <span class="comment">// 1号哈希表的大小</span></span><br><span class="line">    integers[<span class="number">5</span>] = d-&gt;ht[<span class="number">1</span>].used;          <span class="comment">// 1号哈希表中元素数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 我们对N个整形数计算hash值的方法是连续地把上一个数字的hash值和下一个数相加，形成一个新值，</span></span><br><span class="line"><span class="comment">     * 再对这个新值计算hash值，以此类推。像这样：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Result = hash(hash(hash(int1)+int2)+int3) ...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 用这种方式计算一组整型的hash值时，不同的计算顺序会有不同的结果。 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">        hash += integers[j];</span><br><span class="line">        <span class="comment">/* 使用Tomas Wang's 64 bit integer哈希算法 */</span></span><br><span class="line">        hash = (~hash) + (hash &lt;&lt; <span class="number">21</span>); <span class="comment">// hash = (hash &lt;&lt; 21) - hash - 1;</span></span><br><span class="line">        hash = hash ^ (hash &gt;&gt; <span class="number">24</span>);</span><br><span class="line">        hash = (hash + (hash &lt;&lt; <span class="number">3</span>)) + (hash &lt;&lt; <span class="number">8</span>); <span class="comment">// hash * 265</span></span><br><span class="line">        hash = hash ^ (hash &gt;&gt; <span class="number">14</span>);</span><br><span class="line">        hash = (hash + (hash &lt;&lt; <span class="number">2</span>)) + (hash &lt;&lt; <span class="number">4</span>); <span class="comment">// hash * 21</span></span><br><span class="line">        hash = hash ^ (hash &gt;&gt; <span class="number">28</span>);</span><br><span class="line">        hash = hash + (hash &lt;&lt; <span class="number">31</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictGetIterator</code>函数获取一个字典的不安全迭代器。<code>dictGetSafeIterator</code>函数获取一个字典的安全迭代器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dictIterator *dictGetIterator(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    dictIterator *iter = zmalloc(sizeof(*iter));  <span class="comment">// 为迭代器分配空间</span></span><br><span class="line"></span><br><span class="line">    iter-&gt;d = d;</span><br><span class="line">    iter-&gt;table = <span class="number">0</span>;  <span class="comment">// 迭代的是0号哈希表</span></span><br><span class="line">    iter-&gt;index = -<span class="number">1</span>;</span><br><span class="line">    iter-&gt;safe = <span class="number">0</span>;  <span class="comment">// 0表示不安全</span></span><br><span class="line">    iter-&gt;entry = NULL;</span><br><span class="line">    iter-&gt;nextEntry = NULL;</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dictIterator *dictGetSafeIterator(dict *d) &#123;</span><br><span class="line">    dictIterator *i = dictGetIterator(d);</span><br><span class="line"></span><br><span class="line">    i-&gt;safe = <span class="number">1</span>;  <span class="comment">// 1表示安全</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictNext</code>函数获取迭代器的下一个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">dictEntry *dictNext(dictIterator *iter)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry == NULL) &#123;  <span class="comment">// 当前桶的entry链表已经迭代完毕</span></span><br><span class="line">            dictht *ht = &amp;iter-&gt;d-&gt;ht[iter-&gt;table];  <span class="comment">// 获取迭代器的哈希表指针</span></span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index == -<span class="number">1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;  <span class="comment">// 刚开始迭代0号哈希表时</span></span><br><span class="line">                <span class="keyword">if</span> (iter-&gt;safe)</span><br><span class="line">                    iter-&gt;d-&gt;iterators++;  <span class="comment">// 如果是安全的迭代器，就将当前使用的迭代器数量+1</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    iter-&gt;fingerprint = dictFingerprint(iter-&gt;d);  <span class="comment">// 不安全迭代器需要设置字典指纹</span></span><br><span class="line">            &#125;</span><br><span class="line">            iter-&gt;index++;  <span class="comment">// 移动到下一个桶</span></span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index &gt;= (<span class="keyword">long</span>) ht-&gt;size) &#123;  <span class="comment">// 迭代器的当前索引值超过哈希表大小</span></span><br><span class="line">                <span class="keyword">if</span> (dictIsRehashing(iter-&gt;d) &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;  <span class="comment">// 字典正在rehash且当前是0号哈希表时</span></span><br><span class="line">                    iter-&gt;table++;  <span class="comment">// 开始迭代1号哈希表</span></span><br><span class="line">                    iter-&gt;index = <span class="number">0</span>;  <span class="comment">// 设置开始迭代索引为0</span></span><br><span class="line">                    ht = &amp;iter-&gt;d-&gt;ht[<span class="number">1</span>];  <span class="comment">// 更新哈希表指针</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;  <span class="comment">// 如果字典不在rehash且迭代结束，就跳出并返回NULL，表示没有下一个元素了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            iter-&gt;entry = ht-&gt;table[iter-&gt;index];  <span class="comment">// 获取当前桶上的第一个元素</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            iter-&gt;entry = iter-&gt;nextEntry;  <span class="comment">// 获取当前桶中entry的下一个entry</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry) &#123;</span><br><span class="line">            <span class="comment">/* 保存nextEntry指针，因为迭代器用户有可能会删除当前entry */</span></span><br><span class="line">            iter-&gt;nextEntry = iter-&gt;entry-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> iter-&gt;entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictReleaseIterator</code>函数释放字典迭代器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(iter-&gt;index == -<span class="number">1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>)) &#123;  <span class="comment">// 如果当前迭代器时初始化状态且是0号哈希表</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;safe)  <span class="comment">// 释放安全迭代器时需要递减当前使用的迭代器数量（安全迭代器只能有一个）</span></span><br><span class="line">            iter-&gt;d-&gt;iterators--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">assert</span>(iter-&gt;fingerprint == dictFingerprint(iter-&gt;d));  <span class="comment">// 迭代器的字典指纹和实时的字典指纹不符时报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictGetRandomKey</code>函数从哈希表中随机返回一个entry。适用于实现随机算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">dictEntry *dictGetRandomKey(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    dictEntry *he, *orighe;</span><br><span class="line">    unsigned <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">int</span> listlen, listele;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> NULL;  <span class="comment">// 字典没有元素时直接返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);  <span class="comment">// 字典在rehash过程中，执行一次一步的rehash</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) &#123;  <span class="comment">// 字典正在rehash</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* 我们知道0-rehashidx-1之间的索引范围内没有元素 */</span></span><br><span class="line">            h = d-&gt;rehashidx + (random() % (d-&gt;ht[<span class="number">0</span>].size +</span><br><span class="line">                                            d-&gt;ht[<span class="number">1</span>].size -</span><br><span class="line">                                            d-&gt;rehashidx));</span><br><span class="line">            he = (h &gt;= d-&gt;ht[<span class="number">0</span>].size) ? d-&gt;ht[<span class="number">1</span>].table[h - d-&gt;ht[<span class="number">0</span>].size] :</span><br><span class="line">                                      d-&gt;ht[<span class="number">0</span>].table[h];</span><br><span class="line">        &#125; <span class="keyword">while</span>(he == NULL);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 字典不在rehash时，随机生成一个索引值，直到此索引值上有entry</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            h = random() &amp; d-&gt;ht[<span class="number">0</span>].sizemask;</span><br><span class="line">            he = d-&gt;ht[<span class="number">0</span>].table[h];</span><br><span class="line">        &#125; <span class="keyword">while</span>(he == NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 我们找到了一个非空的桶，但它是一个链表结构，所以我们要从链表中随机获取一个元素。</span></span><br><span class="line"><span class="comment">     * 唯一明智的方式是计算链表长度并随机选择一个索引值。*/</span></span><br><span class="line">    listlen = <span class="number">0</span>;</span><br><span class="line">    orighe = he;</span><br><span class="line">    <span class="keyword">while</span>(he) &#123;  <span class="comment">// 计算链表长度</span></span><br><span class="line">        he = he-&gt;next;</span><br><span class="line">        listlen++;</span><br><span class="line">    &#125;</span><br><span class="line">    listele = random() % listlen;</span><br><span class="line">    he = orighe;</span><br><span class="line">    <span class="keyword">while</span>(listele--) he = he-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> he;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictGetSomeKeys</code>函数对字典进行随机采样，从一些随机位置返回一些key。此函数并不保证返回’count’中指定个数的key，并且也不保证不会返回重复的元素，不过函数会尽力做到返回’count’个key和尽量返回重复的key。函数返回指向dictEntry数组的指针。这个数组的大小至少能容纳’count’个元素。函数返回保存在’des’中entry的数量，如果哈希表中的元素小于’count’个，或者在一个合理的时间内没有找到指定个数的元素，这个数字可能会比入参’count’要小。需要注意的是，此函数并不适合当你需要一个数量刚好的采样集合的情况，但当你仅仅需要进行“采样”时来进行一些统计计算时，还是适用的。用函数来获取N个随机key要比执行N次dictGetRandomKey()要快。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">dictGetSomeKeys</span><span class="params">(dict *d, dictEntry **des, unsigned <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    unsigned <span class="keyword">long</span> j;  <span class="comment">// 字典内部的哈希表编号，0或1</span></span><br><span class="line">    unsigned <span class="keyword">long</span> tables;  <span class="comment">// 哈希表数量</span></span><br><span class="line">    unsigned <span class="keyword">long</span> stored = <span class="number">0</span>, maxsizemask;  <span class="comment">// 获取到的随机key数量，掩码</span></span><br><span class="line">    unsigned <span class="keyword">long</span> maxsteps;  <span class="comment">// 最大步骤数，考虑到开销问题，超过这个值就放弃继续获取随机key</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) &lt; count) count = dictSize(d);</span><br><span class="line">    maxsteps = count*<span class="number">10</span>;  <span class="comment">// 最大步骤数为需要获取的key的数量的10倍</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 运行count次一步rehash操作 */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dictIsRehashing(d))</span><br><span class="line">            _dictRehashStep(d);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tables = dictIsRehashing(d) ? <span class="number">2</span> : <span class="number">1</span>;  <span class="comment">// 字典rehash过程中就有两个哈希表要采样，正常情况下是1个</span></span><br><span class="line">    maxsizemask = d-&gt;ht[<span class="number">0</span>].sizemask;</span><br><span class="line">    <span class="keyword">if</span> (tables &gt; <span class="number">1</span> &amp;&amp; maxsizemask &lt; d-&gt;ht[<span class="number">1</span>].sizemask)  <span class="comment">// rehash过程中如果1号哈希表比0号哈希表搭则使用1号哈希表的掩码</span></span><br><span class="line">        maxsizemask = d-&gt;ht[<span class="number">1</span>].sizemask;  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取一个随机索引值 */</span></span><br><span class="line">    unsigned <span class="keyword">long</span> i = random() &amp; maxsizemask;</span><br><span class="line">    unsigned <span class="keyword">long</span> emptylen = <span class="number">0</span>;  <span class="comment">// 迄今为止的连续空entry数量</span></span><br><span class="line">    <span class="keyword">while</span>(stored &lt; count &amp;&amp; maxsteps--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; tables; j++) &#123;</span><br><span class="line">            <span class="comment">/* 和dict.c中的rehash一样： 由于ht[0]正在进行rehash，那里并没有密集的有元素的桶</span></span><br><span class="line"><span class="comment">             * 需要访问，我们可以跳过ht[0]中位于0到idx-1之间的桶，idx是字典的数据rehash的当前索引位置</span></span><br><span class="line"><span class="comment">             * 这个位置以前的桶中的数据都已经被移动到ht[1]了。 */</span></span><br><span class="line">            <span class="keyword">if</span> (tables == <span class="number">2</span> &amp;&amp; j == <span class="number">0</span> &amp;&amp; i &lt; (unsigned <span class="keyword">long</span>) d-&gt;rehashidx) &#123;</span><br><span class="line">                <span class="comment">/* 此外，在rehash过程中，如果我们获取的随机索引值i大于ht[1]的大小，则ht[0]</span></span><br><span class="line"><span class="comment">                 * 和ht[1]都已经没有可用元素让我们获取，此时我们可以直接跳过。</span></span><br><span class="line"><span class="comment">                 * （这一版发生在字典空间从大表小的情况下）。 */</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt;= d-&gt;ht[<span class="number">1</span>].size) i = d-&gt;rehashidx;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= d-&gt;ht[j].size) <span class="keyword">continue</span>;  <span class="comment">//获取的随机索引值i超出范围，直接开始下一次循环</span></span><br><span class="line">            dictEntry *he = d-&gt;ht[j].table[i];  <span class="comment">// 获取到一个entry</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 计算连续遇到的空桶的数量，如果到达'count'就跳到其他位置去获取（'count'最小值为5） */</span></span><br><span class="line">            <span class="keyword">if</span> (he == NULL) &#123;</span><br><span class="line">                emptylen++;</span><br><span class="line">                <span class="keyword">if</span> (emptylen &gt;= <span class="number">5</span> &amp;&amp; emptylen &gt; count) &#123;</span><br><span class="line">                    i = random() &amp; maxsizemask;  <span class="comment">// 重新获取随机值i</span></span><br><span class="line">                    emptylen = <span class="number">0</span>;  <span class="comment">// 重置连续遇到的空桶的数量</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 遇到了非空桶</span></span><br><span class="line">                emptylen = <span class="number">0</span>;  <span class="comment">// 重置连续遇到的空桶的数量</span></span><br><span class="line">                <span class="keyword">while</span> (he) &#123;</span><br><span class="line">                    <span class="comment">/* 把桶中entry链表中的所有元素加入到结果数组中 */</span></span><br><span class="line">                    *des = he;</span><br><span class="line">                    des++;</span><br><span class="line">                    he = he-&gt;next;</span><br><span class="line">                    stored++;</span><br><span class="line">                    <span class="keyword">if</span> (stored == count) <span class="keyword">return</span> stored;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i = (i+<span class="number">1</span>) &amp; maxsizemask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stored;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictScan</code>函数用于迭代字典中的所有元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unsigned <span class="keyword">long</span> <span class="title">dictScan</span><span class="params">(dict *d,</span></span></span><br><span class="line"><span class="function"><span class="params">                       unsigned <span class="keyword">long</span> v,</span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanFunction *fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *privdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictht *t0, *t1;</span><br><span class="line">    <span class="keyword">const</span> dictEntry *de;</span><br><span class="line">    unsigned <span class="keyword">long</span> m0, m1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) &#123;</span><br><span class="line">        t0 = &amp;(d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = de-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t0 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        t1 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Make sure t0 is the smaller and t1 is the bigger table */</span></span><br><span class="line">        <span class="keyword">if</span> (t0-&gt;size &gt; t1-&gt;size) &#123;</span><br><span class="line">            t0 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">            t1 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line">        m1 = t1-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = de-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Iterate over indices in larger table that are the expansion</span></span><br><span class="line"><span class="comment">         * of the index pointed to by the cursor in the smaller table */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">            de = t1-&gt;table[v &amp; m1];</span><br><span class="line">            <span class="keyword">while</span> (de) &#123;</span><br><span class="line">                fn(privdata, de);</span><br><span class="line">                de = de-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Increment bits not covered by the smaller mask */</span></span><br><span class="line">            v = (((v | m0) + <span class="number">1</span>) &amp; ~m0) | (v &amp; m0);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Continue while bits covered by mask difference is non-zero */</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (v &amp; (m0 ^ m1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set unmasked bits so incrementing the reversed cursor</span></span><br><span class="line"><span class="comment">     * operates on the masked bits of the smaller table */</span></span><br><span class="line">    v |= ~m0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Increment the reverse cursor */</span></span><br><span class="line">    v = rev(v);</span><br><span class="line">    v++;</span><br><span class="line">    v = rev(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是一些私有函数的实现：</p>
<p><code>_dictExpandIfNeeded</code>函数判断字典是否需要扩容，如果需要则扩容，否则什么也不做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">_dictExpandIfNeeded</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 正在进行增量式rehash，直接返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果哈希表为空（散列数组大小为0），把它的大小扩容到初始状态（散列数组的初始大小） */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果元素数量和散列数组的比值达到或超过1:1，且我们允许调整哈希表的大小（全局变量dict_can_resize为1）</span></span><br><span class="line"><span class="comment">     * 或者虽然我们不允许调整哈希表大小（全局变量dict_can_resize为0），但是元素数量/散列数组的值</span></span><br><span class="line"><span class="comment">     * 已经超过安全阈值（全局变量dict_force_resize_ratio），我们把哈希表大小调整为当前已使用桶数量的两倍。 */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_dictNextPower</code>函数返回大于且最接近size的2的正整数次方的数字，因为哈希表的大小一定是2的正整数次方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> unsigned <span class="keyword">long</span> <span class="title">_dictNextPower</span><span class="params">(unsigned <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unsigned <span class="keyword">long</span> i = DICT_HT_INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= LONG_MAX) <span class="keyword">return</span> LONG_MAX;   <span class="comment">// 防止size溢出</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_dictKeyIndex</code>函数计算一个给定key在字典中的索引值。如果key已经存在，返回-1。需要注意的是如果哈希表正在进行rehash，返回的总是1号哈希表（新哈希表）的索引值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unsigned <span class="keyword">int</span> h, idx, table;</span><br><span class="line">    dictEntry *he;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果需要，扩容字典 */</span></span><br><span class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 计算key的哈希值*/</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;  <span class="comment">// 计算key的索引值</span></span><br><span class="line">        <span class="comment">/* 遍历当前桶的entry链表查找指定的key是否已经存在 */</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];  <span class="comment">// 桶中第一个元素</span></span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))  <span class="comment">// 找到此key说明已存在，返回-1</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            he = he-&gt;next;  <span class="comment">// 下一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;  <span class="comment">// 字典不在rehash，只查看0号哈希表即可，跳过1号哈希表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictEmpty</code>函数清空字典数据并调用回调函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEmpty</span><span class="params">(dict *d, <span class="keyword">void</span>(callback)</span><span class="params">(<span class="keyword">void</span>*)</span>) </span>&#123;</span><br><span class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">0</span>],callback);  <span class="comment">// 清空0号哈希表，并调用回调函数</span></span><br><span class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">1</span>],callback);  <span class="comment">// 清空1号哈希表，并调用回调函数</span></span><br><span class="line">    d-&gt;rehashidx = -<span class="number">1</span>;  <span class="comment">// 设置不在rehash过程中</span></span><br><span class="line">    d-&gt;iterators = <span class="number">0</span>;  <span class="comment">// 设置当前迭代器数量为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dictEnableResize</code>函数允许调整字典大小。<code>dictDisableResize</code>函数禁止调整字典大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictEnableResize</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    dict_can_resize = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictDisableResize</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    dict_can_resize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        <!-- <h3>看了文章如果觉得喜欢的话可以捐赠哦！支付宝二维码：</h3>
        <img src="/assets/images/post_imgs/code_alipay.png" width=300 height=300> -->
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/源码分析/">源码分析</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>

      
        
	<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '4010e28e5153ab82b468',
        clientSecret: '217df2318bd891ba87b82dae5d67d7ae77bc1f17',
        id: md5(location.href),
        repo: 'nullcc-blog-comments',
        owner: 'nullcc',
        admin: 'nullcc',
        distractionFreeMode: 'true'
    })
    gitalk.render('gitalk-container')
</script>


      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/11/16/Redis中的底层数据结构(4)——整数集合(intset)/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          Redis中的底层数据结构(4)——整数集合(intset)
        
      </div>
    </a>
  
  
    <a href="/2017/11/13/Redis的启动过程/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Redis的启动过程</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
      <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis字典概述"><span class="nav-number">1.</span> <span class="nav-text">Redis字典概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Redis字典的数据结构示意图："><span class="nav-number">1.1.</span> <span class="nav-text">1.Redis字典的数据结构示意图：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Redis字典概述"><span class="nav-number">1.2.</span> <span class="nav-text">2.Redis字典概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Redis字典的哈希函数"><span class="nav-number">1.3.</span> <span class="nav-text">3.Redis字典的哈希函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Rehash过程"><span class="nav-number">1.4.</span> <span class="nav-text">4.Rehash过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字典中的数据结构"><span class="nav-number">2.</span> <span class="nav-text">字典中的数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字典的实现"><span class="nav-number">3.</span> <span class="nav-text">字典的实现</span></a></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2022 张先森的代码小屋 All Rights Reserved.
        
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>













  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>

  <!-- 百度统计 -->
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c3ffa09eef07ac510ef2ab126054b1cd";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
    
</body>
</html>
