<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>深入理解Node.js异步编程 | 张先森的代码小屋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="jsnode">
  
  
  
  
  <meta name="description" content="本文将深入解析node.js的异步世界（本文比较长，请准备好瓜子和可乐）。">
<meta name="keywords" content="js,node">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Node.js异步编程">
<meta property="og:url" content="https://nullcc.github.io/2018/11/04/深入理解Node.js异步编程/index.html">
<meta property="og:site_name" content="张先森的代码小屋">
<meta property="og:description" content="本文将深入解析node.js的异步世界（本文比较长，请准备好瓜子和可乐）。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2022-04-15T03:41:13.035Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解Node.js异步编程">
<meta name="twitter:description" content="本文将深入解析node.js的异步世界（本文比较长，请准备好瓜子和可乐）。">
  
    <link rel="alternate" href="/atom.xml" title="张先森的代码小屋" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="124px" height="124px" alt="Hike News" src=" /css/images/logo.jpg">
              </a>
            
          </h1>
          
          
            <div class="site-description">明镜止水</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-深入理解Node.js异步编程" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      深入理解Node.js异步编程
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/11/04/深入理解Node.js异步编程/" class="article-date">
	  <time datetime="2018-11-03T16:00:00.000Z" itemprop="datePublished">十一月 4, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/编程语言/">编程语言</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文将深入解析node.js的异步世界（本文比较长，请准备好瓜子和可乐）。</p>
<a id="more"></a>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>为了保证文章内所列代码能够正确运行，建议安装babel： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-cli -g</span><br></pre></td></tr></table></figure>
<h2 id="写在阅读之前"><a href="#写在阅读之前" class="headerlink" title="写在阅读之前"></a>写在阅读之前</h2><p>开发者需要注意区分JavaScript和JavaScript运行时（宿主环境）这两个概念。严格来说，JavaScript单纯指这门编程语言，没有其他附加的含义。对于宿主环境，如果是Web前端开发，默认是浏览器，如果是Node.js，则指的是node.js运行时。不同的宿主环境有很大区别，比如浏览器和node.js的事件循环机制就有所区别。另外像<code>console</code>这个对象（没错，就是你经常用的console.log的那个console）也是由宿主环境提供的，它并不是JavaScript的一部分。</p>
<p>需要特别说明的是，本文的事件循环部分主要探讨的宿主环境是node.js，异步编程部分中的绝大多数内容都适用于目前常见的宿主环境，如浏览器、Node.js等。要注意的是虽然不同宿主环境有很多相似的地方，但是我们还是要注意区分他们的不同点。</p>
<h2 id="并发模型和事件循环"><a href="#并发模型和事件循环" class="headerlink" title="并发模型和事件循环"></a>并发模型和事件循环</h2><p>由于JavaScript是单线程运行的，因此它天生是异步的。试想如果一个单线程的程序是同步执行的，一旦有调用阻塞线程，线程就挂起了。对应到现实中的会发现，浏览器因为一个HTTP请求而无法响应用户操作。在使用JavaScript时（不论在哪个宿主环境），都要牢记它是单线程运行的，这个概念非常重要。</p>
<p>大部分使用node.js的人都被它的“异步非阻塞”特性所吸引，一些I/O密集型的应用在使用异步非阻塞的实现后，性能可以有很大的提升，而且应用所占用的资源还比原来采用同步方式编程的低得多。在语言级别，由于是单线程运行，所以完全不存在线程间同步这种麻烦事。</p>
<p>Node.js的并发模型基于事件循环(Event Loop)。下面是一个最简单的事件循环模型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (queue.waitForMessage()) &#123;</span><br><span class="line">  queue.processNextMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个无限while循环，当事件队列中有未处理的消息时，就取出一个消息来处理，否则就一直等待直到有队列中有消息。</p>
<p>为了解释Node.js的事件循环，这里直接引用我翻译的Node.js官方文档中对其事件循环的描述<a href="/2018/10/11/[译]深入理解Node.js的事件循环、定时器和process.nextTick/">(译)深入理解Node.js的事件循环、定时器和process.nextTick()</a>。</p>
<h2 id="JavaScript异步编程的几种常见模式"><a href="#JavaScript异步编程的几种常见模式" class="headerlink" title="JavaScript异步编程的几种常见模式"></a>JavaScript异步编程的几种常见模式</h2><ul>
<li>回调函数</li>
<li>Promise</li>
<li>Generation Function</li>
<li>async/await</li>
<li>Event</li>
</ul>
<h3 id="回调函数-callback"><a href="#回调函数-callback" class="headerlink" title="回调函数(callback)"></a>回调函数(callback)</h3><p>回调函数是最基本的一种异步调用模式，回调函数会在异步操作完成之后被调用。下面试一个简单的Node.js中异步读取文件的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readFileCallback.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'a.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> babel-node readFile.js</span></span><br><span class="line">foo</span><br><span class="line">file a content</span><br></pre></td></tr></table></figure>
<p><code>foo</code>被先打印出来，接着等文件读取完毕，打印出文件内容<code>file a content</code>，可以看到读取文件这个操作并不会阻塞当前进程。因为Node.js运行时直接从<code>fs.readFile</code>中返回，继续往下运行。</p>
<p>再看一个定时器的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timerCallback.js</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setTimeout(fn, <span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>运行这段代码会发现运行后控制台立即打印出2，接着在大约3000毫秒后，控制台打印出1。这个例子再次体现了Node.js的异步特性。</p>
<p>我们再来看看在同步模式中写代码的场景。假设用户想要读取一个文件，由于读取文件（内部是一个系统调用，需要陷入内核）是一个耗时操作（文件比较大或者使用机械硬盘的时候的尤其耗时），因此在同步模式下，这个读取操作会阻塞当前进程（假设目前没有使用多线程），当前进程将被挂起。当前进程的其他代码在该读取操作完成之前无法被执行，如果这个文件的读取需要耗费1秒，则当前进程就要被阻塞1秒，也就是说宝贵的CPU资源在程序运行的时候要被白白浪费1秒。不要小看这1秒，1秒的CPU资源在程序在运行的时候是非常宝贵的。</p>
<p>如果我们想要使用回调函数的方式<code>按顺序</code>读取两个文件，再打印出它们的内容就要嵌套使用回调函数了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nestReadFileCallback.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a file content: "</span> + data);</span><br><span class="line">  fs.readFile(<span class="string">'b.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"b file content: "</span> + data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> babel-node nestCallback.js</span></span><br><span class="line">a file content: file a content</span><br><span class="line">b file content: file b content</span><br></pre></td></tr></table></figure>
<p>这里为了达到<code>异步串行</code>执行的目的，我们使用了嵌套回调。代码开始有点不清爽了，想象一下如果多个异步调用需要按一定顺序串行执行，例如后一次异步调用依赖前一次异步调用的数据，代码会是这个样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// callback hell</span></span><br><span class="line">doSomethingAsync1(<span class="function">(<span class="params">err1, data1</span>) =&gt;</span> &#123;</span><br><span class="line">  doSomethingAsync2(data1, (err2, data2) =&gt; &#123;</span><br><span class="line">    doSomethingAsync3(data2, (err3, data3) =&gt; &#123;</span><br><span class="line">    	doSomethingAsync4(data3, (err4, data4) =&gt; &#123;</span><br><span class="line">    		doSomethingAsync5(data4, (err5, data5) =&gt; &#123;</span><br><span class="line">    		&#125;);</span><br><span class="line">    	&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果业务逻辑比较复杂，维护这种代码简直是噩梦，开发者把这种代码叫做callback hell（回调地狱）。那怎么办呢？我们可以使用Promise。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>ES 6中原生提供了Promise对象，Promise对象代表<code>某个未来才会知道结果的事件</code>(一般是一个异步操作)，换句话说，一个Pomise就是一个代表了异步操作最终完成或者失败的对象。Promise本质上是一个绑定了回调的对象，而不是像callback异步编程那样直接将回调传入函数内部。</p>
<p>Promise对外提供了统一的API，可供进一步处理。Promise的<code>最终</code>状态有两种：<code>fulfilled</code>和<code>rejected</code>，<code>fulfilled</code>表示Promise处于完成状态，<code>rejected</code>表示Promise处于被拒绝状态，这两种状态都是Promise的<code>已决议</code>状态，相反如果Promise还未被<code>决议</code>，它就处于<code>未决议</code>状态。</p>
<p>需要强调的一点是，Promise一经决议就无法改变其状态，这使得Promise和它的名字一样：君子一言驷马难追。</p>
<p>使用Promise对象可以用同步操作的流程写法来表达异步操作，避免了层层嵌套的异步回调，代码也更加清晰易懂，方便维护。用Promise重写读取文件的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseReadSingleFile.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> read = <span class="function"><span class="params">filename</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    	<span class="keyword">if</span> (err)&#123;</span><br><span class="line">    		reject(err);</span><br><span class="line">    	&#125;</span><br><span class="line">    	resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">read(<span class="string">'a.txt'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">"err: "</span> + err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果有多个异步操作需要串行执行，且后一个操作需要拿到前一个操作的结果，我们可以在Promise上使用链式调用(Promise chain)，下面是顺序读取两个文件的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseReadMultiFiles.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> read = <span class="function"><span class="params">filename</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    	<span class="keyword">if</span> (err)&#123;</span><br><span class="line">    		reject(err);</span><br><span class="line">    	&#125;</span><br><span class="line">    	resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(<span class="string">'a.txt'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="string">'b.txt'</span>); <span class="comment">// 注意这里：在then中返回一个Promise</span></span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">"err: "</span> + err);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">"err: "</span> + err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在可以大致总结一下用Promise写串行异步程序的基本模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func1()</span><br><span class="line">.then(<span class="function"><span class="params">result1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> func2(result1);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result2</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> func3(result2);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result3</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> func4(result3);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>then里的参数是可选的，这里的<code>.catch(errCallback)</code>其实是<code>then(null, errCallback)</code>的缩写形式。需要注意的是，如果想要在then的fulfilled中获取上一个Promise中的结果，上一个Promise中必要显式返回结果。</p>
<p>catch之后还可以继续链式调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// catch1.js</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Initial'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Something failed'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Do something'</span>); <span class="comment">// never reach here!</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'Catch error'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Do this whatever happened before'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> babel-node catch1.js</span></span><br><span class="line">Initial</span><br><span class="line">Catch error</span><br><span class="line">Do this whatever happened before</span><br></pre></td></tr></table></figure>
<p>一个Promise链式调用在遇到错误时会立即停止，此时如果在该出错的then之后有catch（不管这个catch是否紧跟在出错then之后），这个catch里的errCallback都会被调用，出错then和catch中间的所有then都会被忽略：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// catch2.js</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Initial'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Something failed'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Do this'</span>); <span class="comment">// never reach here!</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Skip this'</span>); <span class="comment">// never reach here!</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'Catch error'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Final'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> babel-node catch2.js</span></span><br><span class="line">Initial</span><br><span class="line">Catch error</span><br><span class="line">Final</span><br></pre></td></tr></table></figure>
<p>在实际编程中，如果我们将一系列异步操作使用Promise链串行执行，意味着这一串操作是一个整体。一旦整体操作中的某个步骤出错，都不应该继续执行下去了。此时我们可以把catch放在Promise链的最后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// catch3.js</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Initial'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Do something 1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Do something 2 failed'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Do something 2'</span>); <span class="comment">// never reach here!</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Do something 3'</span>); <span class="comment">// never reach here!</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">`Catch error: <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> babel-node catche.js</span></span><br><span class="line">Initial</span><br><span class="line">Do something 1</span><br><span class="line">Catch error: Error: Do something 2 failed</span><br></pre></td></tr></table></figure>
<p>这么做的好处显而易见，这符合软件工程中的<a href="https://www.martinfowler.com/ieeeSoftware/failFast.pdf" target="_blank" rel="noopener">Fail Fast</a>。</p>
<h4 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h4><p>将setTimeout函数Promise化。</p>
<p>解析：</p>
<p>setTimeout是一个旧式的异步API，它接受一个回调和一个时间参数。在ES 6以后写异步代码，强烈不建议直接调用旧式的异步API，应该把这些API都包装成Promise，并且永远不要在业务代码中直接调用这些旧式异步API。为什么不建议这么做？一个很重要的原因对异常的捕获会有问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setTimeoutError.js</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'This is an error!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  setTimeout(fn, <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err); <span class="comment">// never reach here!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里try/catch块无法捕获到<code>fn</code>中的异常。</p>
<p>参考代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timerPromise.js</span></span><br><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">delay(<span class="number">5000</span>)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'here'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure>
<p>运行这段代码，<code>hello</code>会被立即打印，<code>here</code>会在大约5000毫秒后被打印：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> babel-node timerPromise.js</span></span><br><span class="line">hello</span><br><span class="line">here</span><br></pre></td></tr></table></figure>
<p>回到刚才说到的异常捕获问题，将setTimeout包装成Promise后，我们就可以捕获到异常了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timerPromiseCatch.js</span></span><br><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">delay(<span class="number">5000</span>)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'This is an error!'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err); <span class="comment">// Error: This is an error!</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="Promise-API"><a href="#Promise-API" class="headerlink" title="Promise API"></a>Promise API</h4><h5 id="Promise-resolve-和-Promise-reject"><a href="#Promise-resolve-和-Promise-reject" class="headerlink" title="Promise.resolve() 和 Promise.reject()"></a>Promise.resolve() 和 Promise.reject()</h5><p>使用Promise.resolve()可以立即得到一个已经resolve的Promise，这里有两种情况，如果入参本身就是一个Promise，则Promise.resolve()原样返回这个Promise，如果入参是一个立即值（比如一个整型），那么Promise.resolve()会将这个立即值包装成Promise然后返回：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseResolve.js</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1); <span class="comment">// Promise &#123; 100 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p2); <span class="comment">// Promise &#123; 200 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="built_in">Promise</span>.resolve(p2);</span><br><span class="line"><span class="built_in">console</span>.log(p3); <span class="comment">// Promise &#123; 200 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 === p3); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>使用Promise.reject()则是可以立即得到一个已经reject的Promise，其使用方式和Promise.resolve()类似。</p>
<h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h5><p>Promise.all()接受一个Promise的数组，而且会<code>并行地</code>处理数组中的所有Promise：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseAll.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> read = <span class="function"><span class="params">filename</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    	<span class="keyword">if</span> (err)&#123;</span><br><span class="line">    		reject(err);</span><br><span class="line">    	&#125;</span><br><span class="line">    	resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = read(<span class="string">'a.txt'</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = read(<span class="string">'b.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> results = <span class="built_in">Promise</span>.all([p1, p2]);</span><br><span class="line">results</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// [ 'file a content', 'file b content' ]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Promise.all()会返回一个promise，这个promise会收到一个完成消息，这是一个由所有传入的promise的完成消息组成的数组，该数组中元素的顺序与传入时的元素顺序一致，与每个promise的完成时间无关。从Promise.all()返回的这个promise只有在所有的成员promise<code>完成</code>后才会完成。如果这些成员promise中有一个被拒绝的话，Promise.all()返回的promise就会立即被拒绝，并丢弃所有其他promise的全部结果。</p>
<p>看一个例子，如果其中某个promise决议后为拒绝状态：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseAllWithReject.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> read = <span class="function"><span class="params">filename</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    	<span class="keyword">if</span> (err)&#123;</span><br><span class="line">    		reject(err);</span><br><span class="line">    	&#125;</span><br><span class="line">    	resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = read(<span class="string">'a.txt'</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = read(<span class="string">'b.txt'</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'This is an error!'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> results = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br><span class="line">results</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// never reach here!</span></span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err); <span class="comment">// Error: This is an error!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>请记住为每个promise都关联一个拒绝处理函数。</p>
<p>刚才提到只有Promise.all()中的所有成员promise都已完成，其返回的promise的状态返回是已完成。也就是说，Promise.all()调用的完成时间取决于最慢完成的那个promise。一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseAllTime.js</span></span><br><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = delay(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = delay(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Time consuming: <span class="subst">$&#123;end - start&#125;</span>ms`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> babel-node promiseAllTime.js</span></span><br><span class="line">Time consuming: 5002ms</span><br></pre></td></tr></table></figure>
<p>简而言之，Promise.all()会协调所有promise的运行。</p>
<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h5><p>Promise.race()接收一个promise数组，这些promise之间是<code>竞争</code>关系，哪个先完成就返回哪个：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseRace.js</span></span><br><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  delay(<span class="number">1000</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> resolve(<span class="number">100</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  delay(<span class="number">5000</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> resolve(<span class="number">200</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// 100</span></span><br><span class="line">  <span class="keyword">const</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Time consuming: <span class="subst">$&#123;end - start&#125;</span>ms`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里p1和p2各延迟了1000ms和5000ms，分别返回100和200，使用Promise.race()只会得到先完成的p1的值，而p2会被丢弃。</p>
<p>Promise.race()的一种典型用法就是为一个可能耗时较长的异步操作设置一个超时，如果我们希望针对某个异步操作设置一个超时时间，如果超时了，就拒绝这个异步操作的状态，可以这么处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseRaceTimeout.js</span></span><br><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout = <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Time out!'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  delay(<span class="number">1000</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> resolve(<span class="number">100</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  delay(<span class="number">5000</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> resolve(<span class="number">200</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, timeout(<span class="number">3000</span>)]);</span><br><span class="line">p</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// 100</span></span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p_ = <span class="built_in">Promise</span>.race([p2, timeout(<span class="number">3000</span>)]);</span><br><span class="line">p_</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err); <span class="comment">// Error: Time out!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里p1需要1000ms才能完成，p2需要5000ms，超时定时器统一设置成了3000ms，因此<code>Promise.race([p1, timeout(3000)])</code>会得到已经完成的p1的值（100），<code>Promise.race([p2, timeout(3000)])</code>会得到一个超时的结果，在then的reject中可以拿到这个异常。当然，如果在超时定时器超时之前已经有promise被拒绝的话，Promise.race()会直接变成拒绝状态。</p>
<p>Promise API还有其他几个变体：</p>
<ul>
<li>Promise.none() 和Promise.all()相反，要求所有promise都要被拒绝，然后将拒绝转化成完成值。</li>
<li>Promise.any() 会忽略拒绝，只要有一个promise完成，整体的状态即为完成。</li>
<li>Promise.first() 只要第一个promise完成，它就会忽略后续promise的任何完成和拒绝。</li>
<li>Promise.last() 类似于Promise.first()，但条件变为只有最后一个promise完成胜出。</li>
</ul>
<p>对这个四个Promise API有兴趣的同学可以自己做做实验，这里不再深入讲解。</p>
<h5 id="then-和catch"><a href="#then-和catch" class="headerlink" title="then()和catch()"></a>then()和catch()</h5><p>刚才已经提到过，使用then()和catch()可以形成Promise调用链，这里快速总结一下它们的使用方法：</p>
<ul>
<li>p.then(fulfilled);</li>
<li>p.then(fulfilled, rejected);</li>
<li>p.catch(rejected); // 等价于 p.then(null, rejected);</li>
</ul>
<h4 id="包装旧式异步API"><a href="#包装旧式异步API" class="headerlink" title="包装旧式异步API"></a>包装旧式异步API</h4><p>可能项目中有一些遗留代码还在使用旧式异步API，如果我们要将这部分代码Promise化，最好是有比较好用的工具，下面的polyfill可以帮助你Promise化旧式异步API：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseWrapper.js</span></span><br><span class="line"><span class="keyword">const</span> promiseWrapper = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>); <span class="comment">// convert arguments to a real array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> cb = <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(data);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseWrapper.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> read = promiseWrapper(fs.readFile);</span><br><span class="line"></span><br><span class="line">read(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>read是经过Promise化的fs.readFile，调用read会返回一个Promise，一切和我们想象的一致。不过这样用有一个前提条件，原来的旧式异步API必须是<a href="http://nodejs.cn/api/errors.html#errors_error_first_callbacks" target="_blank" rel="noopener">error-first</a>的，好消息是大多数Node.js核心API都是error-first的。</p>
<h4 id="Promise的局限性"><a href="#Promise的局限性" class="headerlink" title="Promise的局限性"></a>Promise的局限性</h4><ol>
<li>不可取消。</li>
<li>不可打断。</li>
<li>一经决议就不可变。</li>
</ol>
<h3 id="迭代器-Iterator-和生成器-Generator"><a href="#迭代器-Iterator-和生成器-Generator" class="headerlink" title="迭代器(Iterator)和生成器(Generator)"></a>迭代器(Iterator)和生成器(Generator)</h3><p>ES 6中引入了生成器函数(Generator Function)。生成器函数用<code>function *</code>定义。它和普通函数相比有一些有意思的特性。</p>
<p>用一个简单的例子来展示生成器函数的工作方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generator.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">10</span> * (<span class="keyword">yield</span> <span class="string">'world'</span>);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = generator();</span><br><span class="line"><span class="keyword">let</span> res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'pause here'</span>);</span><br><span class="line"></span><br><span class="line">res = it.next(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 40, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> babel-node generator.js</span></span><br><span class="line">hello</span><br><span class="line">&#123; value: 'world', done: false &#125;</span><br><span class="line">pause here</span><br><span class="line">&#123; value: 40, done: true &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码段定义了一个生成器函数，这里重要的是它的执行流程：</p>
<ol>
<li>调用一个生成器函数（就像调用普通函数那样）并不会立即开始执行这个生成器内部的代码，而是返回一个它的迭代器。因此<code>generator();</code>实际上返回了一个迭代器。</li>
<li>接着<code>let res = it.next();</code>这行代码使生成器函数开始执行，打印<code>hello</code>。当遇到<code>yield</code>时，生成器会暂停，交出控制权。这里打印res会发现其内容为<code>{ value: &#39;world&#39;, done: false }</code>，value是生成器内部的yield出的值，如果yield后面没有东西，这个value就是<code>undefined</code>，<code>done</code>为<code>false</code>表示生成器还未执行完毕。</li>
<li><code>console.log(&#39;pause here&#39;);</code>这行代码是我们在生成器暂停期间插入的一段执行逻辑。刚才提到，在生成器暂停期间会交出控制权，因此控制权又回到外部。</li>
<li>语句<code>res = it.next(4);</code>将使生成器继续运行，直到遇到下一个yield，而且这次传入了4，通过<code>next()</code>传入的值会使得yield获取这个值，所以在生成器内部x的值就是40（10*4）。再次观察res为<code>{ value: 40, done: true }</code>，由于生成最终返回x，所value就是40，done也变为<code>true</code>了，说明生成器执行完毕。</li>
</ol>
<p>通过解析这段代码我们可以发现几个很有意思的事情：</p>
<ol>
<li>生成器内部可以通过yield主动交出控制权，使控制权回到调用方。</li>
<li>yield后面可以有值，有值得yield会将这个值<code>返回</code>出来。</li>
<li>可以通过<code>next()</code>将值传入生成器中，该值将作为对应yield的值。</li>
<li>调用<code>next()</code>后，会获得一个结果，这个结果包含两个值，<code>value</code>表示当前yield的执行结果（或者return的结果）<code>done</code>表示生成器执行状态的信息：true/false分别表示执行完毕和还未执行完毕。</li>
<li>生成器通过<code>yeild</code>和<code>next</code>使得外部和生成器内部的通信称为可能。</li>
</ol>
<p>看到这里可能有人要问了，这有什么用呢？和Promise相比有什么好处？请慢慢往下看。</p>
<p>还有一种场景，假设我们要获得一个无限的自然数序列，从小到大一次取出一个来用。由于自然数是无限的，我们不可能一次性用一个数组将它们都生成出来（时间上不允许，空间上也不允许），其实也没有必要。我们只需要在需要获取一个自然数的时候生成出一个就好了。这时使用生成器再合适不过：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// numberGenerator.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">numberGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = numberGenerator();</span><br><span class="line"><span class="keyword">let</span> res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br></pre></td></tr></table></figure>
<p>由于生成器里面是一个无限while循环，所以<code>done</code>一直是<code>false</code>。</p>
<p>使用生成器函数需要注意一点，在获得生成器函数的迭代器后，第一次调用其<code>next()</code>方法时不需要传参数（尽管你可以这么做）。因为此时还没遇到yield，传了也没意义。</p>
<h4 id="生成器函数的错误处理"><a href="#生成器函数的错误处理" class="headerlink" title="生成器函数的错误处理"></a>生成器函数的错误处理</h4><p>可以直接在生成器函数中使用try/catch捕获异常：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generatorCatchError.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> x = (<span class="keyword">yield</span> <span class="string">'world'</span>)();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err); <span class="comment">// TypeError: (intermediate value) is not a function</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = generator();</span><br><span class="line">it.next();</span><br><span class="line"><span class="keyword">const</span> res = it.next(<span class="string">'bar'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>由于上面的代码段中有异常，被catch捕获，没有显式调用return语句，所以默认返回值是undefined。</p>
<p>想停止一个生成器函数只需要调用其迭代器的<code>return</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generatorStop.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">numberGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = numberGenerator();</span><br><span class="line"><span class="keyword">let</span> res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">res = it.return(); <span class="comment">// stop generator</span></span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>回想Promise部分介绍的链式Promise，虽然避免了嵌套回调问题，但是一连串.then()也让人挺烦的，如果能真正像写同步代码那样写串行异步代码那该多好。实际上使用生成器函数已经可以做到这点。但是为了更好地理解后面的内容，这里还有几个准备工作要做。我们知道在生成器函数中yield一个值的时候，外部可以通过next()拿到这个值，刚才的代码中yield后面都是立即值，如果把这个值换成一个异步函数会怎样？</p>
<p>很自然地，我们会想让代码变成这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generatorReadFileBadExample.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generator</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> file1 = <span class="keyword">yield</span> fs.readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(file1); <span class="comment">// undefined</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = generator();</span><br><span class="line"><span class="keyword">let</span> res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: undefined, done: false &#125;</span></span><br><span class="line">res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>但很可惜的是，这样做并不奏效，为什么？</p>
<h4 id="小练习-1"><a href="#小练习-1" class="headerlink" title="小练习"></a>小练习</h4><p>思考一下为什么上面这段代码不能工作？</p>
<p>解析：</p>
<p>其实仔细思考yield的行为就会发现，<code>fs.readFile</code>是一个旧式的异步API，调用它会立即返回undefined，如果没有传入一个回调函数给它，我们无法获得任何信息。那么问题来了，如果还要在生成器函数里调用fs.readFile时传入回调函数，那不是又回到解放前了吗，我们可不想再直接去面对赤裸裸地回调函数。也就是说，将fs.readFile直接在生成器内部执行是不可能的了，那么只能将fs.readFile的执行放到生成器函数外部，换句话说，我们要将fs.readFile连同它的参数通过yield<code>传递</code>到外部去执行，我们需要包装一下fs.readFile。将一个函数和一堆参数绑定后塞入另一个新的函数里，叫函数的<a href="https://zh.wikipedia.org/zh/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="noopener">柯里化(currying)</a>，换一种更通俗易懂的讲法：我们把一堆参数固定到一个函数上。</p>
<p>由于在JavaScript中函数是一等对象，所以借助高阶函数的抽象功能，可以写一个帮助方法来对任意在最后一个参数上为回调函数的异步API进行柯里化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thunkify.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunkify = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line">readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>)(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// file a content</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们来尝试一下将柯里化后的旧式异步API和生成器函数结合使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generatorReadFile1.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunkify = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generator</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> file1 = <span class="keyword">yield</span> readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(file1); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">const</span> file2 = <span class="keyword">yield</span> readFile(<span class="string">'b.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(file2); <span class="comment">// undefined</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = generator();</span><br><span class="line"><span class="keyword">let</span> res = it.next();</span><br><span class="line">res.value(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// file a content</span></span><br><span class="line">&#125;);</span><br><span class="line">res = it.next();</span><br><span class="line">res.value(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// file b content</span></span><br><span class="line">&#125;);</span><br><span class="line">res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>第一次调用next()时，我们从其value中得到了柯里化后的fs.readFile，我们叫它readFile。readFile接受一个回调函数，因此只要传入回调我们就能获得异步调用的结果。很好，我们的第一步目的达到了。但是仔细一看，还是有问题：在生成器函数中我们打印file1和file2结果都是undefined，生成器函数在交出控制权后，控制权转移到外部，异步调用也在外部完成，异步调用的结果也在外面。没关系，我们可以通过<code>next(value)</code>将这个异步调用结果带回给生成器函数内部：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generatorReadFile2.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunkify = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> file1 = <span class="keyword">yield</span> readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'got '</span> + file1); <span class="comment">// got file a content</span></span><br><span class="line">  <span class="keyword">const</span> file2 = <span class="keyword">yield</span> readFile(<span class="string">'b.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'got '</span> + file2); <span class="comment">// got file b content</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = generator();</span><br><span class="line"><span class="keyword">let</span> res = it.next();</span><br><span class="line">res.value(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  res = it.next(data);</span><br><span class="line">  res.value(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    res = it.next(data);</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>非常好，我们成功地将异步调用的结果又传回给生成器函数，问题到这一步应该说已经基本解决了。说基本解决是因为调用方式还没有自动化，还需要手动一步步调用<code>res.value(cb)</code>，再次发挥JavaScript高阶函数的强大威力，写一个自动执行生成器函数的工具吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generatorAutoRunner.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunkify = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> file1 = <span class="keyword">yield</span> readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'got '</span> + file1); <span class="comment">// got file a content</span></span><br><span class="line">  <span class="keyword">const</span> file2 = <span class="keyword">yield</span> readFile(<span class="string">'b.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'got '</span> + file2); <span class="comment">// got file b content</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> run = <span class="function"><span class="params">g</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> it = g();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = it.next(data);</span><br><span class="line">    <span class="keyword">if</span> (res.done) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.value;</span><br><span class="line">    &#125;</span><br><span class="line">    res.value(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run(generator);</span><br></pre></td></tr></table></figure>
<p>自动运行生成器函数的原理很简单，在生成器函数的迭代器上执行next时，返回的是一个柯里化后的异步函数，我们需要调用这个异步函数，同时传入一个参数，这个参数是一个回调函数，它是自动执行的关键，该回调函数内部在获取到结果值的时候，需要调用next方法将这个结果值带回给生成器函数内部，如此循环下去直到结束。</p>
<h5 id="yield-语句"><a href="#yield-语句" class="headerlink" title="yield *语句"></a>yield *语句</h5><p>普通的yield语句后面跟一个异步操作，yield <em>语句后面可以跟另一个可迭代对象，在实际使用中yield </em>后面一般要跟另一个Generator函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunkify = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = thunkify(fs.readFile);</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(f1); <span class="comment">// file a content</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> f_ = <span class="keyword">yield</span> *anotherGenerator(); <span class="comment">//此处插入了另外一个异步流程</span></span><br><span class="line">  <span class="built_in">console</span>.log(f_); <span class="comment">// file c content</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> f3 = <span class="keyword">yield</span> readFile(<span class="string">'b.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(f3); <span class="comment">// file b content</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> anotherGenerator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">const</span> f = <span class="keyword">yield</span> readFile(<span class="string">'c.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> it = g();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">const</span> result = it.next(data);</span><br><span class="line">		<span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line">		result.value(next);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	next();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">run(generator);  <span class="comment">//自动执行</span></span><br></pre></td></tr></table></figure>
<p>在使用生成器函数作为异步控制流的时期，业界比较流行的自动执行的解决方案是co库：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// co1.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunkify = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> file1 = <span class="keyword">yield</span> readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'got '</span> + file1); <span class="comment">// got file a content</span></span><br><span class="line">  <span class="keyword">const</span> file2 = <span class="keyword">yield</span> readFile(<span class="string">'b.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'got '</span> + file2); <span class="comment">// got file b content</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>还可以直接利用co库并发地执行一系列操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// co2.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunkify = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> files = [<span class="string">'a.txt'</span>, <span class="string">'b.txt'</span>];</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">yield</span> files.map(<span class="function"><span class="params">file</span> =&gt;</span> readFile(file, <span class="string">'utf8'</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// [ 'file a content', 'file b content' ]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>还可以用yield并发地执行一个可迭代对象中的异步操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// coWithArray.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunkify = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> files = [<span class="string">'a.txt'</span>, <span class="string">'b.txt'</span>];</span><br><span class="line">  <span class="keyword">const</span> results = <span class="keyword">yield</span>* files.map(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFile(file, <span class="string">'utf8'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(results); <span class="comment">// [ 'file a content', 'file b content' ]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>直到ES 7中出现async/await之前，业界普遍都是采用co库的方案。</p>
<p>async和await是ES 7中的新语法，新到连ES 6都不支持，但是可以通过Babel一类的预编译器处理成ES 5的代码。目前比较一致的看法是async和await是js对异步的终极解决方案。要注意的一个点是，await只能用在async函数中，但async函数中未必一定要有await。</p>
<p>立即尝试看看：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async.js</span></span><br><span class="line"><span class="keyword">const</span> promiseWrapper = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>); <span class="comment">// convert arguments to a real array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> cb = <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(data);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = promiseWrapper(fs.readFile);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">	<span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'b.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(f1); <span class="comment">// file a content</span></span><br><span class="line">	<span class="built_in">console</span>.log(f2); <span class="comment">// file b content</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">asyncReadFile();</span><br></pre></td></tr></table></figure>
<p>如果不加<code>await</code>调用<code>async</code>函数，该异步函数将像旧式异步函数那样直接返回，也就是说，后面的代码不会等待该异步函数执行完毕，看一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async-without-await.js</span></span><br><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> demo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  delay(<span class="number">5000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - start&#125;</span>ms --- a`</span>);</span><br><span class="line">  <span class="keyword">await</span> delay(<span class="number">5000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - start&#125;</span>ms --- b`</span>);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">demo();</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0ms --- a</span><br><span class="line">5006ms --- b</span><br></pre></td></tr></table></figure>
<h3 id="使用事件进行异步编程"><a href="#使用事件进行异步编程" class="headerlink" title="使用事件进行异步编程"></a>使用事件进行异步编程</h3><p>除了回调函数、Promise、Generator、async/await这些异步方案以外，还有一种常见的异步方案：事件。在Node.js中使用事件编程十分简单，下面是一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event.js</span></span><br><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">'news'</span>, payload =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(payload.data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">'logout'</span>, payload =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`User logout: <span class="subst">$&#123;payload.data&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventEmitter.emit(<span class="string">'news'</span>, &#123; <span class="attr">data</span>: <span class="string">'Hello world!'</span>&#125;);</span><br><span class="line">eventEmitter.emit(<span class="string">'logout'</span>, &#123; <span class="attr">data</span>: <span class="string">'Foo'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>事件的一大特定是它的解耦能力，事件相比方法调用的耦合度要低一些。在一些业务场景下，模块之间可以通过事件来解耦。</p>
<h2 id="常用的异步编程库"><a href="#常用的异步编程库" class="headerlink" title="常用的异步编程库"></a>常用的异步编程库</h2><p><a href="https://github.com/caolan/async" target="_blank" rel="noopener">async</a><br><a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="noopener">bluebird</a><br><a href="https://github.com/tj/co" target="_blank" rel="noopener">co</a></p>
<h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p><a href="/2018/10/11/[译]深入理解Node.js的事件循环、定时器和process.nextTick/">(译)深入理解Node.js的事件循环、定时器和process.nextTick()</a><br><a href="https://www.martinfowler.com/ieeeSoftware/failFast.pdf" target="_blank" rel="noopener">Fail Fast</a><br><a href="http://nodejs.cn/api/errors.html#errors_error_first_callbacks" target="_blank" rel="noopener">error-first</a><br><a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">Promise/A+规范</a><br><a href="https://zh.wikipedia.org/zh/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="noopener">柯里化(currying)</a></p>

        <!-- <h3>看了文章如果觉得喜欢的话可以捐赠哦！支付宝二维码：</h3>
        <img src="/assets/images/post_imgs/code_alipay.png" width=300 height=300> -->
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/编程语言/">编程语言</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node/">node</a></li></ul>

      
        
	<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '4010e28e5153ab82b468',
        clientSecret: '217df2318bd891ba87b82dae5d67d7ae77bc1f17',
        id: md5(location.href),
        repo: 'nullcc-blog-comments',
        owner: 'nullcc',
        admin: 'nullcc',
        distractionFreeMode: 'true'
    })
    gitalk.render('gitalk-container')
</script>


      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/11/12/深入理解JavaScript的Prototype/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          深入理解JavaScript的Prototype
        
      </div>
    </a>
  
  
    <a href="/2018/10/28/AOP_in_JavaScript_and_TypeScript/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">AOP in JavaScript and TypeScript</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
      <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#准备工作"><span class="nav-number">1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#写在阅读之前"><span class="nav-number">2.</span> <span class="nav-text">写在阅读之前</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发模型和事件循环"><span class="nav-number">3.</span> <span class="nav-text">并发模型和事件循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript异步编程的几种常见模式"><span class="nav-number">4.</span> <span class="nav-text">JavaScript异步编程的几种常见模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回调函数-callback"><span class="nav-number">4.1.</span> <span class="nav-text">回调函数(callback)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise"><span class="nav-number">4.2.</span> <span class="nav-text">Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小练习"><span class="nav-number">4.2.1.</span> <span class="nav-text">小练习</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-API"><span class="nav-number">4.2.2.</span> <span class="nav-text">Promise API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Promise-resolve-和-Promise-reject"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">Promise.resolve() 和 Promise.reject()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Promise-all"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">Promise.all()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Promise-race"><span class="nav-number">4.2.2.3.</span> <span class="nav-text">Promise.race()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#then-和catch"><span class="nav-number">4.2.2.4.</span> <span class="nav-text">then()和catch()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#包装旧式异步API"><span class="nav-number">4.2.3.</span> <span class="nav-text">包装旧式异步API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise的局限性"><span class="nav-number">4.2.4.</span> <span class="nav-text">Promise的局限性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器-Iterator-和生成器-Generator"><span class="nav-number">4.3.</span> <span class="nav-text">迭代器(Iterator)和生成器(Generator)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生成器函数的错误处理"><span class="nav-number">4.3.1.</span> <span class="nav-text">生成器函数的错误处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小练习-1"><span class="nav-number">4.3.2.</span> <span class="nav-text">小练习</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#yield-语句"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">yield *语句</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#async-await"><span class="nav-number">4.4.</span> <span class="nav-text">async/await</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用事件进行异步编程"><span class="nav-number">4.5.</span> <span class="nav-text">使用事件进行异步编程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用的异步编程库"><span class="nav-number">5.</span> <span class="nav-text">常用的异步编程库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更多信息"><span class="nav-number">6.</span> <span class="nav-text">更多信息</span></a></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2023 张先森的代码小屋 All Rights Reserved.
        
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>













  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>

  <!-- 百度统计 -->
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c3ffa09eef07ac510ef2ab126054b1cd";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
    
</body>
</html>
