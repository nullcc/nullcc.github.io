<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张先森的代码小屋</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nullcc.github.io/"/>
  <updated>2022-08-11T10:02:50.244Z</updated>
  <id>https://nullcc.github.io/</id>
  
  <author>
    <name>nullcc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>领域驱动设计实践(1)-错误处理</title>
    <link href="https://nullcc.github.io/2022/08/04/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5(1)-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <id>https://nullcc.github.io/2022/08/04/领域驱动设计实践(1)-错误处理/</id>
    <published>2022-08-03T16:00:00.000Z</published>
    <updated>2022-08-11T10:02:50.244Z</updated>
    
    <content type="html"><![CDATA[<p>本文讨论了领域驱动设计实践下的错误处理。</p><a id="more"></a><p>在软件开发过程中，错误处理一直是个比较麻烦的事情。对于错误处理，我们经常需要考虑的问题是：</p><ul><li>在哪些地方可能出现错误</li><li>如何处理错误</li><li>失败、错误、异常有什么区别</li></ul><p>上一篇文章中以六边形架构为例介绍了领域驱动设计的一些基本概念，这里会沿用六边形架构的理念，所以还是再贴出来一次：</p><p><img src="/assets/images/post_imgs/domain_driven_hexagon.png" alt="领域驱动设计的六边形架构"></p><p>我们先看第一个问题：在哪些地方可能出现错误</p><h2 id="在哪些地方可能出现错误"><a href="#在哪些地方可能出现错误" class="headerlink" title="在哪些地方可能出现错误"></a>在哪些地方可能出现错误</h2><p>理论上每个地方都可能出错，不过我们最好不要把所有地方的错误都当成同一种错误处理。原因是错误层级不同。</p><p>我认为至少有三种错误层级，从里到外分别是：</p><ul><li>Domain Errors (领域错误)</li><li>Application Errors (应用错误)</li><li>Interface Errors (接口错误)</li></ul><p><img src="/assets/images/post_imgs/clean-architecture-errors.png" alt="三种错误级别"></p><p>对应到六边形架构的各个组件中就是：</p><ul><li>Domain Errors =&gt; Entity &amp; Value Object &amp; Domain Service</li><li>Application Errors =&gt; Application Service (&amp; Infrastructure?)</li><li>Interface Errors =&gt; Interface (Controller)</li></ul><p>Infrastructure 部分的错误比较特殊，由于 Infrastructure 中的 Adapters 实现了 Application Service 中声明的 Ports，它的错误经常以某种形式被包装（比如一个 Result，这里有一个 npm package <a href="https://github.com/badrap/result" target="_blank" rel="noopener">@badrap/result</a> 提供了这种能力 ），并由 Application Service 处理。因此 Infrastructure 中的错误一般都可以被转化为某种 Application Error。</p><p>Value Object 也需要特别说明一下，由于 Value Object 一般自带数据验证逻辑，在使用不符合要求的数据初始化 Value Object 时会直接导致参数错误，这种错误一般会被直接抛出，这符合 <a href="https://en.wikipedia.org/wiki/Fail-fast" target="_blank" rel="noopener">Fail-fast</a> 原则。</p><h2 id="如何处理错误"><a href="#如何处理错误" class="headerlink" title="如何处理错误"></a>如何处理错误</h2><p>在错误处理上，大致可以分为两种方式：</p><ol><li>try/catch</li><li>错误码</li></ol><p>不同语言对这两种错误处理方式有不同的方式和偏好，比如 C 语言就没有 try/catch，只能使用错误码。Rust 则彻底抛弃 try/catch 语法，使用 <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code>。这两种方式各有利弊，这里并不会深入讨论。下面只说我个人比较推荐的做法。</p><p>我们刚才一直在说错误，其实广义上的错误有两种：</p><ol><li>错误</li><li>异常</li></ol><p>错误一般指的是开发者可以预料到的非正常情况，比如支付时当前账号余额不足，当前账号被锁定无法支付等。应用程序可以从这种情况中恢复。错误比较多指的是业务相关的非正常情况。</p><p>异常则是那些无法预料但又确实有可能发生的情况，比如内存不足、磁盘空间不足、网络断开、数组索引超出合法范围、调用外部 API 时对方返回 500等。这类情况是应用无法处理和恢复的。</p><p>Domain Errors 都是第一种错误，开发者有能力处理好它们。比如支付时当前账号余额不足时，返回 Insufficient balance error 给 Application Service，由后者决定如何进一步处理这个错误。Application Service 可能会将这个 Domain Error 分类到一个更大的 Application Error 类别中并将其返回给 Interface (Controller)。Controller 会判断这个 Application Error 对应到哪个 HTTP Error Code (这里假设是一个 Web Server)。</p><p>Value Object 属于领域层，但 Value Object 中的参数验证中发生的错误一般不会以错误码的形式返回给上一层，而是直接抛出错误，由顶层组件去捕获(Web Server 一般都有一个顶层方法用于捕获从下层抛出且在中途未被捕获的异常)，此时可以对错误进行分类并对应到不同的 HTTP Error Code。</p><p>Application Errors 除了编排业务流还会和 Infrastructure 中的 Adapters 打交道，前者产生的错误是可预料的，后者则不一定，可以是可预料的也可以是不可预料的。比如有一个外部的 Account Service，我们在 Application Service 中需要向 Account Service 查询账号信息，然后才能继续执行。这个 Account Service 可能会返回 Account 相关的业务错误（比如未找到账号），也可能由于未知原因返回一个 500。对于开发者来说前一个错误是可以预料的，可以对应到一个 Domain Error。后一个错误则是不可预料的，但此时 Application Service 也要能够处理，比如可以返回一个 Unknown External Error 给 Controller，后者返回 500 给用户。Infrastructure 中的 Adapters 在内部可以使用 try/catch 处理具体实现，然后在 catch 块中对具体的出错信息进行判断，包装成某种业务错误。</p><p>Interface Errors 可以是根据从 Application Service 返回的错误映射到的相应的 HTTP Error Code，也可以是因为用户传入的 DTO 中的数据类型不正确直接返回 400 错误。如果是命令行程序，Interface Errors 还返回自定义的错误码。</p><p>这样从同心圆的内部到外部根据不同错误层级进行处理，我们就完成了错误处理的流程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讨论了领域驱动设计实践下的错误处理。&lt;/p&gt;
    
    </summary>
    
      <category term="领域驱动设计" scheme="https://nullcc.github.io/categories/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="领域驱动设计" scheme="https://nullcc.github.io/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计实践(0)-基础概念</title>
    <link href="https://nullcc.github.io/2022/07/19/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5(0)-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>https://nullcc.github.io/2022/07/19/领域驱动设计实践(0)-基础概念/</id>
    <published>2022-07-18T16:00:00.000Z</published>
    <updated>2022-08-11T05:38:06.890Z</updated>
    
    <content type="html"><![CDATA[<p>本文解释了领域驱动设计的一些基础概念。</p><a id="more"></a><h2 id="传统三层架构的开发困境"><a href="#传统三层架构的开发困境" class="headerlink" title="传统三层架构的开发困境"></a>传统三层架构的开发困境</h2><p>进入计算机行业有些年头了，在大大小小的项目中工作过，大部分后端项目使用的开发模式都是三层架构。三层架构将整个系统的分成三部分：</p><ul><li>UI (表现层)</li><li>BLL (业务逻辑层)</li><li>DAL (数据访问层)</li></ul><p>三层架构的一种常见实现方式如下图：</p><p><img src="/assets/images/post_imgs/ddd-in-action-0-1.png" alt="三层架构的常见实现方式"></p><p>在三层架构中，表现层的 Controller 负责和用户（用户可能是真人或机器）交互，负责验证请求数据的有效性并将数据包装成业务逻辑层容易处理的形式。业务逻辑层中的 Service 从 Controller 接收数据，然后处理业务逻辑，过程中可能会和数据访问层交互来获取数据，数据访问层使用 DAO 从持久化系统中获取和更新数据。一些和第三方系统的交互（比如集成的 SDK、邮件通知等）一般也会放在业务逻辑层的 Service 中。</p><p>三层架构对整个系统的切分方式很好理解，上手简单，但同时也存在不少缺点。随着项目的迭代，该架构中间的业务逻辑层会变得越来越厚，表现层和数据访问层相对于业务逻辑层是相当薄的一层。整个系统两头薄中间厚，显得很不协调。由于所有业务逻辑全都聚集在业务逻辑层，单个 Service 文件动辄上千行相当常见，多个程序员协作在同一个文件上，其实是很不利于增加新特性和维护的。除此之外，系统中还会出现大量业务对象，这些对象的名字都和业务相关，但内部除了一些属性和 getter setter 之外，几乎没有任何业务逻辑，我们称这些对象为贫血领域对象。这些对象的最大用处就是承载数据让业务逻辑层中的具体业务方法处理。如果有对接第三方系统的需求，业务逻辑层中还会出现各种外部 SDK 或对外部系统调用的封装，当这些东西和我们的核心业务逻辑混杂在一起时是不利于维护的。</p><p>这种实现方式不协调的地方不仅仅体现在代码体量和内部大量的贫血领域对象上，还体现在依赖关系上。基于三层架构的传统 MVC 开发方式中的依赖关系一般是这样的（-&gt;表示依赖方向）：用户接口层 -&gt; 应用层 -&gt; 领域层 -&gt; 基础设施层。举一个例子，我们一般在 Service 中调用 DAO 来进行数据操作，如从数据库读取或向数据库写入，依赖方向是 Service -&gt; DAO。如果之后出于性能优化目的我们希望先尝试访问缓存获取数据，如果没有再从数据库获取，则此时需要修改 Service。之前提到 Service 是承载业务逻辑的一层，而从数据源获取数据属于技术细节，技术细节不应该对业务逻辑造成影响。另一个例子是对外部服务的调用，例如一个业务操作中的一项数据来自于外部服务。简单的做法是直接在业务操作的方法中调用这个外部服务的 API（通过外部服务提供的 SDK 或自己的实现），这种做法的问题在于让业务逻辑直接依赖于外部服务，一旦外部服务的 API 发生变化，我们不得不修改业务逻辑中的相关方法。</p><p>对任何一个项目来说，业务组件的抽象程度都要高于负责具体实现的组件。以上两个例子的根本问题都在于让抽象程度高的业务组件直接依赖于抽象程度低的实现组件。虽然也能工作，但这会造成依赖的阻抗失调，导致灵活性受到限制。</p><p>为了解决这种依赖关系失调，我们需要改进依赖关系的建模方式。这就是依赖倒置原则(DIP)：</p><p><img src="/assets/images/post_imgs/dependency-inversion-principle.png" alt="依赖倒置原则"></p><h2 id="Clean-Architecture-与领域驱动设计"><a href="#Clean-Architecture-与领域驱动设计" class="headerlink" title="Clean Architecture 与领域驱动设计"></a>Clean Architecture 与领域驱动设计</h2><p>Robert C. Martin (Uncle Bob) 在 <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener">the-clean-architecture</a> 这篇文章中提到了 clean architecture 的概念。其中列出了几种架构选型，下面将一些重点信息引用并翻译如下：</p><blockquote><p>这些架构尽管在细节上可能有所不同，但却非常相似。它们的目标是一致的，即<code>关注点分离</code>。它们都通过将软件分层来实现这种分离，每种架构都至少有一层用于业务规则，另一层作为接口。</p><p>这些架构产生的系统具有这样的属性：</p><ol><li>独立于框架。架构不依赖于某些功能丰富的软件库的存在。这使你可以将这些框架用作工具，而不必使系统被它们所限制。</li><li>可测试的。可以在没有UI、数据库、Web 服务器或其他任何外部元素的情况下测试业务规则。</li><li>独立于UI。UI 可以被轻松更改，而无需更改系统的其余部分。例如，可以用控制台 UI 替换 Web UI，而无需更改业务规则。</li><li>独立于数据库。你可以将 Oracle 或 SQL Server 换成 Mongo、BigTable、CouchDB 或其他东西。你的业务规则不与数据库绑定。</li><li>独立于任何外部事物。事实上，你的业务规则根本不了解外部世界。</li></ol></blockquote><p>文章配了一张图来表达 Clean Architecture 的思想：</p><p><img src="/assets/images/post_imgs/the-clean-architecture.png" alt="the clean architecture"></p><p>另外，文中还提到了软件开发中依赖关系的一些规则：</p><blockquote><p>图中的每个同心圆表示软件中的一层，越往内部软件的层次越高，也越抽象。外圈是机制（实现），内圈是政策（规则）。</p><p>使这个架构工作的最重要的规则是依赖规则。该规则表示源代码依赖项只能指向同心圆的内部。内圈中的任何东西都对外圈中的事物一无所知。特别是，在外圈中声明的事物的名称不能被内圈中的代码提及。这包括函数、类、变量或任何其他命名的软件实体。</p><p>同样，在外圈中使用的数据格式也不应该被内圈使用，特别是如果这些格式是由外圈中的框架生成的。我们不希望外圈的任何东西影响内圈。</p></blockquote><p>上面的所有要点全都指向两个核心概念：软件的<code>隔离</code>和<code>抽象</code>。</p><p>文章中提到的架构选型中有一种叫作 Hexagonal Architecture (a.k.a. Ports and Adapters) (六边形架构，又叫端口和适配器)，该架构的示意图如下：</p><p><img src="/assets/images/post_imgs/domain_driven_hexagon.png" alt="domain driven hexagon"></p><p>之后的文章我都将以六边形架构为依据来讲解，先分析一下这幅图中的元素。</p><h3 id="Interface-amp-Infrastructure-接口与基础设施层"><a href="#Interface-amp-Infrastructure-接口与基础设施层" class="headerlink" title="Interface &amp; Infrastructure (接口与基础设施层)"></a>Interface &amp; Infrastructure (接口与基础设施层)</h3><p>最外层是接口和基础设施层。Controller 位于接口层，Controller 有很多种类型，包括但不限于 HTTP Controller, CLI Controller 和 Event Controller。Controller 的外部是各种调用方，Controller 主要负责和调用方通信，调用方可以是真实用户、外部服务或其他任何主动对当前系统产生影响（调用、消息推送等）的事物。</p><p>基础设施层包含各种 Adapters，比如 Repository Adapter 实现了如何从数据库中存取数据的细节。External Resources Adapters 实现了如何和外部资源沟通的细节。Microservices Adapters 实现了微服务间的通信细节等等。</p><h3 id="Boundary-Between-Interface-amp-Infrastructure-And-Core-接口与基础设施层与核心层之间的边界"><a href="#Boundary-Between-Interface-amp-Infrastructure-And-Core-接口与基础设施层与核心层之间的边界" class="headerlink" title="Boundary Between Interface &amp; Infrastructure And Core (接口与基础设施层与核心层之间的边界)"></a>Boundary Between Interface &amp; Infrastructure And Core (接口与基础设施层与核心层之间的边界)</h3><p>注意看接口与基础设施层和它相邻的一层核心层之间的边界，有三种组件：</p><ul><li>Queries (查询)</li><li>Commands (命令)</li><li>Ports (端口)</li></ul><p>对于外部任何事物对当前系统的主动调用或消息推送，可以分两种类型：Queries (查询)和 Commands (命令)。Queries 是读操作，一般是幂等的。Commands 是更新操作，会修改系统中的数据。Ports 是在核心层声明的抽象概念，需要由基础设施层中的各种 Adapters 实现。</p><p>部分不涉及业务逻辑的 Queries 可以直接跳过核心层使用 Repository Adapter 读取数据返回。</p><p>Controller 会对从外部进来的 DTO 进行简单的数据校验，这里的校验基本只是验证下数据类型，比如 age 需要是一个数字但用户传入一个字符串就会报错。校验通过后 Controller 会将数据包装成 Commands 对象。Commands 对象承载了具体 Use Case 需要的数据，它穿过接口与基础设施层与核心层的边界进入核心层。</p><p>核心层中的组件只能依赖 Ports，具体的实现在基础设施层对应的 Adapters 中。Adapters 在运行时通过依赖注入(DI)的方式进入核心层。</p><p>在一些项目的实现中，会在业务组件中直接调用具体实现，这相当于让抽象程度高的组件依赖抽象程度低的组件。此时如果技术细节变更时（比如换了一种数据数据库或外部服务接口变了），核心层也需要修改。如果在设计上实现依赖倒置，则一般只需要修改基础设施层（除非在核心层中定义的 Ports 本身发生变化）。这样的设计实现了业务逻辑和具体实现的解耦，在核心层 Ports 不变的情况下，外部的变更对核心层几乎没有影响。</p><h3 id="Core-核心层"><a href="#Core-核心层" class="headerlink" title="Core (核心层)"></a>Core (核心层)</h3><p>核心层的抽象程度比接口与基础设施层高，我们在这里定义业务规则。图中核心层内部还有三层：</p><ul><li>Application Services (应用服务)</li><li>Domain Services (领域服务)</li><li>Entities (实体)</li><li>Value Objects (值对象)</li></ul><h4 id="Application-Services-应用服务"><a href="#Application-Services-应用服务" class="headerlink" title="Application Services (应用服务)"></a>Application Services (应用服务)</h4><p>Application Services 是基于用例的，实际上就是一堆 Use Cases，它负责编排用例执行流程。Application Services 不包含任何领域特定的业务逻辑，它应该是相对较薄的一层。Application Services 通过使用 Ports 声明其为了编排用例需要的基础设施层的依赖。 Application Services 可能还会有一些 Ports 来声明它们与外部系统通信（比如发送 email）的规则，具体实现同样位于基础设施层的对应 Adapters 中。一般来说，正如六边形架构图中所展示的，所有与外部系统通信的抽象规则都定义在 Application Services 的 Ports 中。</p><p>Ports 还相当于一个防腐层(Anti-corruption layer, ACL)，由于我们核心层的抽象程度较高，让它们直接依赖于具体实现细节显然不合适。好的实践是，当核心层需要某种能力时，我们声明这种能力作为 Ports，外部的基础设施层的某个 Adapter 实现这个 Ports 的能力，然后在需要时我们将这个 Adapter 注入到核心层的 Application Services 中。在 Ports 声明的抽象规则不变的情况下，当我们想要替换具体实现时，只要换一个 Adapter 注入进去即可。</p><h4 id="Domain-Services-领域服务"><a href="#Domain-Services-领域服务" class="headerlink" title="Domain Services (领域服务)"></a>Domain Services (领域服务)</h4><p>Domain Services 被用于处理那些“领域中不属于实体或值对象的天然职责的那些重要的过程或转换”。Domain Services 是一种特定类型的领域层类，用于执行依赖于两个或更多实体的领域逻辑。如果有一些逻辑，将它们放在某个 Entities 中时会破坏它们的封装性，那就提取出来放到 Domain Services 中。</p><h4 id="Entities-实体"><a href="#Entities-实体" class="headerlink" title="Entities (实体)"></a>Entities (实体)</h4><p>Entities 是领域的核心，代表业务模型。Entities 封装了业务规则，表达特定模型具有的属性。相较于开篇提到的超大业务层中的贫血领域对象（几乎只有业务对象属性的 getter 和 setter）来说，在这里 Entities 是充血领域对象，不但包含了业务数据，还包含了业务操作。</p><p>Entities 具有唯一标识，常用的唯一表示可以是 UUID 这种业务无关的标识，在某些业务场景下，一些业务属性本身就具有唯一性，也可以拿来当做唯一表示，比如公民的身份证号。</p><p>当我们需要区分不同对象时，就需要引入 Entities 这个领域概念。一个实体是一个唯一的东西，它可以在一段时间内持续变化。我们可以对一个实体做出修改，但由于它的唯一标识是不变的，所以它还是它自己。另外，只要唯一标识不同，就算两个实体的所有其他属性都相等，它们也是不同的实体。</p><p>一般来说，具体的业务对象都可以被当成 Entities 看待，这些对象具有天然的唯一性且可以被修改。比如一个用户、一笔订单和一篇文章。</p><h4 id="Value-Objects-值对象"><a href="#Value-Objects-值对象" class="headerlink" title="Value Objects (值对象)"></a>Value Objects (值对象)</h4><p>Value Objects 和 Entities 经常被混淆。《实现领域驱动设计》一书中对值对象的解释是：</p><blockquote><p>当你决定对一个领域概念是否是一个值对象时，你需要考虑它是否拥有一下特性：</p><ul><li>它度量或者描述了领域中的一件东西。</li><li>它可以作为不变量。</li><li>它将不同的相关的属性组合成一个概念整体。</li><li>当度量和描述改变时，可以用另一个值对象予以替换。</li><li>它可以和其他值对象进行相等性比较。</li><li>它不会对协作对象造成副作用。</li></ul></blockquote><p>根据上述结束，很容易发现一些东西可以被定义成值对象：日期、颜色（如RGB值）、温度、金额（数量和货币类型的组合）等。</p><h2 id="在各个层中穿越"><a href="#在各个层中穿越" class="headerlink" title="在各个层中穿越"></a>在各个层中穿越</h2><p>要让整个系统运行起来，除了分层我们还需要让数据真正流动起来，这就涉及在不同层之间的数据流转。数据会在各层间穿越，这里的问题是数据以什么样的形式穿过各层。一般来说，我们需要在各层的边界上创建 DTO 来包装其他层穿越过来数据，只包装需要的数据字段。</p><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>考虑一个用户登录的场景，用户使用账号密码登录。先对这个场景进行规划：</p><ul><li>Epic: Authentication</li><li>Use Case: User login by username and password</li></ul><p>Authentication 可以作为一个 Module 存在，模块将同一个业务领域的 Use Case 组织起来，里面可以有不同的 Use Cases (Application Services)。在当前场景中，用户使用账号密码登录是一个 Use Case，用户通过第三方平台 OAuth 登录是一个 Use Case，用户使用人脸识别登录也是一个 Use Case。</p><p>对应到 DDD 中就是：</p><p>模块 Module (Epic): Authentication Module<br>应用服务 Application Service (Use Case): User login by username and password</p><p>再往里就来到领域层，这时可以有一个 User 业务对象，这个对象包含具体的业务逻辑，用户登录需要验证用户名和密码，可能还有额外的逻辑比如需要这个用户的状态是 active 的才能登录。总之这里都是一些业务规则。</p><p>我们从用户请求开始来看这个 Use Case，当用户登录的时候，客户端发送请求数据到服务端，请求数据会先到 router，会由某个 controller 来处理这个请求，controller 把数据取出来，包装成 Command 对象，传给 Module 中的 Application Service，这里可能会有一个叫作 UserLoginService 的应用服务在应用层面处理这个请求。应用层面的意思是它只负责编排整个 Use Case Flow 的过程，并不涉及具体的业务逻辑。</p><p>来看看 UserLoginService 在这里会有什么操作（为方便描述，这里省略错误处理部分）：</p><ol><li>基于 username 入参从数据库查询得到某个用户的信息</li><li>创建一个 User 业务对象，将从数据库查出的用户信息（用户名，密码hash，状态等）作为构造参数传入，初始化这个 User 对象。</li><li>调用 User 对象的 isValid 方法（传入用户的密码作为参数），验证用户有效性。</li><li>返回验证结果给 controller</li></ol><p>之后 controller 会包装数据并返回给客户端。</p><p>这里有一个问题，在从数据库中取出用户信息时，我们该怎么做？</p><p>用户登录这个 Use Case 是抽象的（因为 Use Case 只描述了一个用例，没有提到任何技术细节），它在软件中层次较高，而数据库操作是技术细节，抽象层次较低。如果我们在这个 UserLoginService 里直接初始化并使用一个 DAO 对象来从数据库查询数据会怎么样？这确实可以工作，但是当具体实现有变化时，比如我们换了一个 DAO 实现，我们就需要修改 UserLoginService。这对我们来说有点难受了，我们只是想换一个 DAO 实现就要动到 UserLoginService 吗？实际上 UserLoginService 根本不关心具体用的是哪个 DAO，只要有某个对象可以帮我查询到用户就好了。</p><p>比较好的做法是在应用服务级别声明一个 Repository Port。在基础设施层，我们编写一个 Repository Adapter 来实现这个接口，这里面就是具体技术细节了。在运行时，通过依赖注入的方式，注入一个实现到应用层以实现真正从数据库获取数据。</p><p>当外部数据库发生变化时，比如从 MySQL 换到 SQL Server，或者在真正查询数据库前先检查缓存，我们只要修改相应 Adapter 这个负责具体实现的组件，应用层以内几乎不用变。</p><p>让抽象程度高的组件直接依赖抽象程度低的组件的做法除了在开发上会引入强耦合外，还会导致测试变得困难。假设 UserLoginService 直接依赖一个基于 MySQL 的 DAO，当我们编写 UserLoginService 的单元测试时，还需要处理 MySQL 这个外部依赖。事实上，如果在这里将依赖倒置，我们可以传入一个 MockDAO，MockDAO 实现了普通 DAO 对象的全部方法，唯一不同是它直接返回 mock data 而不查询数据库，这可以帮助我们隔离掉 MySQL。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener">The Clean Architecture</a><br><a href="https://enterprisecraftsmanship.com/posts/domain-vs-application-services/" target="_blank" rel="noopener">domain-vs-application-services</a><br><a href="https://github.com/nullcc/domain-driven-hexagon/blob/master/README-zh_CN.md" target="_blank" rel="noopener">领域驱动的六边形架构</a><br><a href="https://book.douban.com/subject/25844633/" target="_blank" rel="noopener">实现领域驱动设计</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文解释了领域驱动设计的一些基础概念。&lt;/p&gt;
    
    </summary>
    
      <category term="领域驱动设计" scheme="https://nullcc.github.io/categories/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="领域驱动设计" scheme="https://nullcc.github.io/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>构建可观察的动态命令行程序</title>
    <link href="https://nullcc.github.io/2022/04/25/%E6%9E%84%E5%BB%BA%E5%8F%AF%E8%A7%82%E5%AF%9F%E7%9A%84%E5%8A%A8%E6%80%81%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
    <id>https://nullcc.github.io/2022/04/25/构建可观察的动态命令行程序/</id>
    <published>2022-04-24T16:00:00.000Z</published>
    <updated>2022-05-12T06:55:08.386Z</updated>
    
    <content type="html"><![CDATA[<p>本文讨论了构建可观察的动态命令行程序的一些实践。</p><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>有些时候我们会开发出具有如下特征的命令行程序：</p><pre><code>* 需要运行较长时间（几分钟至数小时，甚至数天），并有可能会放在持续集成系统中运行（例如Jenkins）* 参数较多，且可以灵活配置</code></pre><p>这种命令行程序在自动化测试领域很常见，例如用来批量生成某些数据、批量运行自动化测试用例等。这些程序的运行方式一般会从开发者在本地运行慢慢变成在持续集成系统中运行，从开发者主动触发运行慢慢变成定时地或被某些上游系统以调用持续集成系统API的方式自动运行。</p><h3 id="动态修改命令行程序的参数"><a href="#动态修改命令行程序的参数" class="headerlink" title="动态修改命令行程序的参数"></a>动态修改命令行程序的参数</h3><p>一般来说，一旦一个命令行程序开始运行，此时如果用户想修改某些参数，那就必须停掉正在运行的程序，修改参数后再重新运行这个程序。这在大部分情况下是没问题的，但如果用户希望在不停止程序运行的情况下动态地修改参数怎么办呢？有一些情形下我们希望具备这种能力，这里列举几个：</p><pre><code>1. 一个较大的自动化测试用例集已经运行了一段时间，此时用户发现原来的用例集不全，还需要再加入一些新用例。2. 一个数据准备程序已经运行了一段时间，此时用户希望加入一些新数据。3. 一个会向后端组件发送大量请求的命令行程序，刚开始时由于后端资源紧张并发数很低，之后后端资源充裕了想要提高并发数。</code></pre><p>上述情况下，最直接的做法肯定是停掉正在运行的程序重新运行，但这么做也是有成本的，需要花费更多时间重启程序、或者在最后需要聚合多份自动化测试报告。重启程序的成本根据实际情况或高或低，不过无论如何，成本确实存在。</p><h3 id="监控命令行程序"><a href="#监控命令行程序" class="headerlink" title="监控命令行程序"></a>监控命令行程序</h3><p>还有一种情形是用户希望看到长时间运行的命令行程序的状态，比如进度、成功率、并发数等信息。这些信息是动态的，传统方式下一般通过输出日志来实现。那还有没有其他的方式呢？能否把这些数据集成到 dashboard 里进行监控？</p><hr><h2 id="什么是可观察的动态命令行程序？"><a href="#什么是可观察的动态命令行程序？" class="headerlink" title="什么是可观察的动态命令行程序？"></a>什么是可观察的动态命令行程序？</h2><h3 id="可观察的命令行程序"><a href="#可观察的命令行程序" class="headerlink" title="可观察的命令行程序"></a>可观察的命令行程序</h3><p>有了上面的需求，很自然地会去思考如何解决。先来看观察命令行程序的可能方式：</p><pre><code>1. 输出日志/文件2. 将数据写到外部系统(数据库/信息收集系统)3. 在本地开放 HTTP API</code></pre><h4 id="1-输出日志-文件"><a href="#1-输出日志-文件" class="headerlink" title="1. 输出日志/文件"></a>1. 输出日志/文件</h4><p>这是最简单直接的方式，优点是一目了然，方便保留过程日志，缺点是不利于提供即时信息，对监控和集成不友好。</p><h4 id="2-将数据写到外部系统-数据库-信息收集系统"><a href="#2-将数据写到外部系统-数据库-信息收集系统" class="headerlink" title="2. 将数据写到外部系统(数据库/信息收集系统)"></a>2. 将数据写到外部系统(数据库/信息收集系统)</h4><p>这种方式的优点是既可以保留过程日志也可以提供实时信息，缺点是开销较大，而且引入了外部依赖。</p><h4 id="3-在本地开放-HTTP-API"><a href="#3-在本地开放-HTTP-API" class="headerlink" title="3. 在本地开放 HTTP API"></a>3. 在本地开放 HTTP API</h4><p>这种方式会在命令行运行的本地启动一个 HTTP Server，对外提供 HTTP API。优点是方便获取及时信息，对监控和集成友好，缺点是不利于保留过程日志。</p><h4 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h4><p>我们会比较希望既可以保留过程日志又可以监控即时信息，那么可以组合使用1和3，或者2和3。</p><h3 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h3><p>再来看可动态这个特性。一般来说，动态意味着可在运行时修改行为。对于命令行程序来说，有几种可能的方式：</p><pre><code>1. 通过一个配置文件，命令行程序定期去读，用来更新内部数据2. 监听消息队列3. 通过本地开放的 HTTP API</code></pre><h4 id="定期读配置文件"><a href="#定期读配置文件" class="headerlink" title="定期读配置文件"></a>定期读配置文件</h4><p>虽然可以达到目的，但不太方便，尤其在 Jenkins 上执行时，用户需要远程连接到执行机来修改配置。很多情况下用户是没有权限这样做的。</p><h4 id="监听消息队列"><a href="#监听消息队列" class="headerlink" title="监听消息队列"></a>监听消息队列</h4><p>监听消息队列需要引入外部依赖，成本较高。</p><h4 id="通过本地开放的-HTTP-API"><a href="#通过本地开放的-HTTP-API" class="headerlink" title="通过本地开放的 HTTP API"></a>通过本地开放的 HTTP API</h4><p>这种方式适用于本地和远程执行，也可以和上面提到的监控即时信息的做法相契合。</p><h4 id="如何选择？-1"><a href="#如何选择？-1" class="headerlink" title="如何选择？"></a>如何选择？</h4><p>综合来看，通过在本地开放 HTTP API 来提供可观察的即时数据和动态修改程序行为是一种比较靠谱的方式。</p><hr><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h3><p>通过在本地开放 HTTP API 来构建可观察的动态命令行程序有很多方式，这里我给出一个我觉得比较优雅的实现方式以供参考。</p><p>首先要说明的是，实现这个想法本身是框架无关的，可以基于任何框架去实现，甚至不用框架。不过既然有合适的工具，我们没理由置之不理，因此下面讨论的实现还是使用了框架来做。先简要介绍下这种方式，我使用了 <a href="https://nestjs.com" target="_blank" rel="noopener">nest.js</a> 这个框架，这是个类 Spring 的 TS/JS 框架，内建了依赖注入支持，还有不少官方和第三方的优质插件。</p><p>我创建了一个示例工程 <a href="https://github.com/nullcc/any-factory" target="_blank" rel="noopener">any-factory</a> 来展示如何实现。这个示例展示了一个工厂，我们可以通过命令行指定需要生成哪些产品，以及它们的个数。另外还提供了可选的 HTTP Server 来实时获取工厂内部数据和动态修改待生产的产品参数的能力。</p><p>先来看入口文件 <code>main.ts</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; NestFactory &#125; <span class="keyword">from</span> <span class="string">'@nestjs/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ConsoleLogger &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BootstrapConsole &#125; <span class="keyword">from</span> <span class="string">'nestjs-console'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DocumentBuilder, SwaggerModule &#125; <span class="keyword">from</span> <span class="string">'@nestjs/swagger'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppModule &#125; <span class="keyword">from</span> <span class="string">'./app.module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ExceptionInterceptor &#125; <span class="keyword">from</span> <span class="string">'@infrastructure/interceptors/exception.interceptor'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CustomBootstrapConsole <span class="keyword">extends</span> BootstrapConsole &#123;</span><br><span class="line">  <span class="keyword">async</span> create() &#123;</span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create(AppModule);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> appLogger = <span class="keyword">new</span> ConsoleLogger(<span class="string">'Any Factory'</span>);</span><br><span class="line">    <span class="keyword">const</span> config = <span class="keyword">new</span> DocumentBuilder()</span><br><span class="line">      .setTitle(<span class="string">'Any Factory'</span>)</span><br><span class="line">      .setDescription(<span class="string">'The any factory web API description'</span>)</span><br><span class="line">      .setVersion(<span class="string">'1.0'</span>)</span><br><span class="line">      .addTag(<span class="string">'Any Factory'</span>)</span><br><span class="line">      .build();</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">document</span> = SwaggerModule.createDocument(app, config);</span><br><span class="line">    SwaggerModule.setup(<span class="string">'docs'</span>, app, <span class="built_in">document</span>);</span><br><span class="line"></span><br><span class="line">    app.useGlobalInterceptors(<span class="keyword">new</span> ExceptionInterceptor());</span><br><span class="line"></span><br><span class="line">    app.enableShutdownHooks();</span><br><span class="line"></span><br><span class="line">    app.getHttpServer().on(<span class="string">'listening'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> port = app.getHttpServer().address().port;</span><br><span class="line">      appLogger.log(<span class="string">`Application is listening on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> app.listen(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> withServer = (): <span class="function"><span class="params">boolean</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> !!process.argv.find(<span class="function">(<span class="params">e</span>) =&gt;</span> e === <span class="string">'--with-server'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getBootstrap = (): <span class="function"><span class="params">BootstrapConsole</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (withServer()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomBootstrapConsole(&#123;</span><br><span class="line">      <span class="keyword">module</span>: AppModule,</span><br><span class="line">      withContainer: true, // This is the key that will give you access to the app container from the service cli</span><br><span class="line">      useDecorators: true,</span><br><span class="line">      contextOptions: &#123; logger: <span class="literal">false</span> &#125;,</span><br><span class="line">    &#125; <span class="keyword">as</span> <span class="built_in">any</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> BootstrapConsole(&#123;</span><br><span class="line">    <span class="keyword">module</span>: AppModule,</span><br><span class="line">    useDecorators: true,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const bootstrap = getBootstrap();</span><br><span class="line"></span><br><span class="line">bootstrap</span><br><span class="line">  .init()</span><br><span class="line">  .then(async (app) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> app.init();</span><br><span class="line">    <span class="keyword">await</span> bootstrap.boot();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>入口文件有几个值得一提的地方，首先是使用了 <a href="https://github.com/Pop-Code/nestjs-console" target="_blank" rel="noopener">nestjs-console</a> 这个 npm package，由于 nest.js 默认不提供命令行的使用方式，因此我们需要这个库来提供命令行的支持。我们实现了一个 <code>CustomBootstrapConsole</code> 类，该类在 <code>create</code> 方法里创建了一个 nest.js HTTP server，并内部配置了一个 swagger module，最后监听在<code>0</code>端口。这里有个小技巧，如果监听0端口，则操作系统会随机分配一个可用的端口号。这么做的好处是我们不需要显式指定监听的端口号，可以在机器上同时运行多个该程序而不用担心端口号冲突。</p><p><code>withServer</code> 方法用来判断是否需要启动一个 HTTP server：当命令行参数中存在 <code>--with-server</code> 选项时启动一个 HTTP server。</p><p><code>getBootstrap</code> 方法作为 <code>main.ts</code> 的入口方法，负责判断命令行程序的启动方式：带 HTTP Server 或者不带。注意看 <code>getBootstrap</code> 的实现，当 <code>withServer()</code> 为 true 时，我们创建了一个 <code>CustomBootstrapConsole</code> 实例，参数 <code>withContainer: true</code> 非常重要，它允许我们从 CLI 中访问 app container，在这里就是 <code>module: AppModule</code>。这个特性非常重要，它允许 CLI 和 我们的应用程序通信。这里我们倒不需要去追究它的实现方式。接着就是初始化了，这部分 nest.js 框架的方法会帮我们处理。</p><p>有一幅图帮助理解这个项目的基本结构：</p><p><img src="/assets/images/post_imgs/building-observable-and-dynamic-cli-app-0.png" alt="any-factory的基本结构"></p><p>接着看 <code>app.module.ts</code> 里的 <code>AppModule</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/app.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ConfigModule &#125; <span class="keyword">from</span> <span class="string">'nestjs-config'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MonitorModule &#125; <span class="keyword">from</span> <span class="string">'@modules/monitor/monitor.module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ProductionModule &#125; <span class="keyword">from</span> <span class="string">'@modules/production/production.module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    ConfigModule.load(path.resolve(__dirname, <span class="string">'config'</span>, <span class="string">'**/!(*.d).&#123;ts,js&#125;'</span>)),</span><br><span class="line">    MonitorModule,</span><br><span class="line">    ProductionModule,</span><br><span class="line">  ],</span><br><span class="line">  controllers: [],</span><br><span class="line">  providers: [],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123;&#125;</span><br></pre></td></tr></table></figure><p>抛开 nest.js 具体的使用细节不谈（尽管这也很重要，但目前它们对我们来说是手段而不是目的，故先避开），在 <code>AppModule</code> 中我们导入了3个 module: <code>ProductionModule</code>, <code>MonitorModule</code> 和 <code>ConfigModule</code>。<code>ProductionModule</code> 是这个项目的核心上下文，负责生产产品。<code>MonitorModule</code> 负责提供可观察、动态修改命令行程序的入口。<code>ConfigModule</code> 负责配置处理文件。为了保持示例的简单，这里只导入3个modules，但已足够说明问题了。</p><h3 id="生产模块"><a href="#生产模块" class="headerlink" title="生产模块"></a>生产模块</h3><p>接着来看 <code>ProductionModule</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/modules/production/production.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Module, Global &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CqrsModule &#125; <span class="keyword">from</span> <span class="string">'@nestjs/cqrs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ConsoleModule &#125; <span class="keyword">from</span> <span class="string">'nestjs-console'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ProduceProductCliController &#125; <span class="keyword">from</span> <span class="string">'./commands/produce-product/produce-product.cli.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ProduceProductService &#125; <span class="keyword">from</span> <span class="string">'./commands/produce-product/produce-product.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UpdateSchedulerService &#125; <span class="keyword">from</span> <span class="string">'../monitor/commands/update-scheduler/update-scheduler.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; productionServiceLoggerProvider &#125; <span class="keyword">from</span> <span class="string">'./providers/production.providers'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cliControllers = [ProduceProductCliController];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commandHandlers = [ProduceProductService, UpdateSchedulerService];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> customProviders = [productionServiceLoggerProvider];</span><br><span class="line"></span><br><span class="line"><span class="meta">@Global</span>()</span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  imports: [CqrsModule, ConsoleModule],</span><br><span class="line">  controllers: [],</span><br><span class="line">  providers: [...cliControllers, ...commandHandlers, ...customProviders],</span><br><span class="line">  exports: [...commandHandlers],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ProductionModule &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>production.module.ts</code> 这种模块文件本身没有任何逻辑，它只是一个模块的入口，负责组装模块。<code>imports</code> 字段指明该模块依赖两个外部模块 <code>CqrsModule</code> 和 <code>ConsoleModule</code>，稍后会解释其含义。<code>controllers</code> 字段本来是用来声明需要注入的 HTTP controllers，但在这里 ProductionModule 并不直接提供 HTTP API，所以是个空数组。我们稍后会看到这个字段在 MonitorModule 是有用的。在 <code>providers</code> 字段中声明了一些东西：</p><ul><li>cliControllers: 命令行相关的 controllers，即用户和应用程序核心之间的命令行控制器。</li><li>commandHandlers: 负责执行命令行控制器接收到的命令，cliControllers 是 commandHandlers 的直接用户。</li><li>customProviders: 一些自定义 providers，这里只有一个 logger。</li></ul><p>接着看 <code>produce-product.cli.controller.ts</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/modules/production/commands/produce-product/produce-product.cli.controller.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CommandBus &#125; <span class="keyword">from</span> <span class="string">'@nestjs/cqrs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Command, Console &#125; <span class="keyword">from</span> <span class="string">'nestjs-console'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ProduceProductCommand &#125; <span class="keyword">from</span> <span class="string">'./produce-product.command'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Production &#125; <span class="keyword">from</span> <span class="string">'@src/interface-adapters/interfaces/production/production.interface'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Console</span>()</span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ProduceProductCliController &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> readonly commandBus: CommandBus</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Command</span>(&#123;</span><br><span class="line">    command: <span class="string">'produce-products'</span>,</span><br><span class="line">    description: <span class="string">'Produce products'</span>,</span><br><span class="line">    options: [</span><br><span class="line">      &#123;</span><br><span class="line">        flags: <span class="string">'-s, --specs &lt;specs&gt;'</span>,</span><br><span class="line">        required: <span class="literal">true</span>,</span><br><span class="line">        fn: <span class="function">(<span class="params">value</span>) =&gt;</span> value.split(<span class="string">';'</span>),</span><br><span class="line">        description: <span class="string">'Product specs'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        flags: <span class="string">'-c, --concurrency &lt;concurrency&gt;'</span>,</span><br><span class="line">        required: <span class="literal">false</span>,</span><br><span class="line">        defaultValue: <span class="number">1</span>,</span><br><span class="line">        fn: <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">parseInt</span>(value),</span><br><span class="line">        description: <span class="string">'Concurrency of pipeline'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        flags: <span class="string">'--with-server'</span>,</span><br><span class="line">        required: <span class="literal">false</span>,</span><br><span class="line">        description:</span><br><span class="line">          <span class="string">'Will start a HTTP server to provide a way to inspect some internal data if specified'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">async</span> produceProducts(opts: Production): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> command = <span class="keyword">new</span> ProduceProductCommand(opts);</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.commandBus.execute(command);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Console()</code> 装饰器声明这是一个命令行控制器，另外在构造参数中有一个 <code>CommandBus</code>，这个东西来自 <code>@nestjs/cqrs</code> 这个 package，<a href="https://martinfowler.com/bliki/CQRS.html" target="_blank" rel="noopener">CQRS</a> 表示<code>命令查询职责分离</code>，也就是我们将读操作和写操作分开处理，这在微服务和领域驱动设计(DDD)的实践中有非常多的应用，由于这次的主题并不是关于 CQRS 的，这里只是顺带一提。简单来说在 CQRS 将写操作视为一种命令(command)，这里的 <code>CommandBus</code> 提供了一种执行命令的一致性方法。在 <code>produceProducts</code> 方法中，我们使用 <code>@Command()</code> 装饰器声明了一个命令，用来生产产品，里面的参数简单易懂，这里就不细说了。继续看这个方法的实现，我们使用方法入参 <code>opt</code> 实例化了一个 <code>ProduceProductCommand</code> 命令对象，这个对象其实只是一个命令信息的载体而已，没什么特别的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/modules/production/commands/produce-product/produce-product.command.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Command,</span><br><span class="line">  CommandProps,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@src/libs/ddd/domain/base-classes/command.base'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ProduceProductCommand <span class="keyword">extends</span> Command &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">props: CommandProps&lt;ProduceProductCommand&gt;</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.specs = props.specs;</span><br><span class="line">    <span class="keyword">this</span>.concurrency = props.concurrency;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  readonly specs: <span class="built_in">string</span>[];</span><br><span class="line"></span><br><span class="line">  readonly concurrency: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正有意思的地方是：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">this</span>.commandBus.execute(command);</span><br></pre></td></tr></table></figure><p>这就是上面提到的 <code>执行命令的一致性方法</code>。它的神奇之处在于在 <code>produceProducts</code> 方法中，我们不需要了解谁会负责处理这个 <code>ProduceProductCommand</code> 命令对象，我们只需要知道把这个命令对象传给 <code>this.commandBus</code> 的 <code>execute</code> 方法就行了。</p><p>那谁会来处理 <code>ProduceProductCommand</code> 命令对象呢？它是：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/modules/production/commands/produce-product/produce-product.service.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable, Inject &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CommandBus, CommandHandler &#125; <span class="keyword">from</span> <span class="string">'@nestjs/cqrs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ConfigService &#125; <span class="keyword">from</span> <span class="string">'nestjs-config'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Result &#125; <span class="keyword">from</span> <span class="string">'@libs/ddd/domain/utils/result.util'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Logger &#125; <span class="keyword">from</span> <span class="string">'@libs/ddd/domain/ports/logger.port'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CommandHandlerBase &#125; <span class="keyword">from</span> <span class="string">'@src/libs/ddd/domain/base-classes/command-handler.base'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ProduceProductCommand &#125; <span class="keyword">from</span> <span class="string">'./produce-product.command'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PipelineEntity &#125; <span class="keyword">from</span> <span class="string">'@modules/production/domain/entities/pipeline.entity'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Production &#125; <span class="keyword">from</span> <span class="string">'@modules/production/domain/value-objects/production.value-object'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Spec &#125; <span class="keyword">from</span> <span class="string">'@modules/production/domain/value-objects/spec.value-object'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Concurrency &#125; <span class="keyword">from</span> <span class="string">'@modules/production/domain/value-objects/concurrency.value-object'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Summary &#125; <span class="keyword">from</span> <span class="string">'@modules/production/domain/value-objects/summary.value-object'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; produceProductServiceLoggerSymbol &#125; <span class="keyword">from</span> <span class="string">'@modules/production/providers/production.providers'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="meta">@CommandHandler</span>(ProduceProductCommand)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ProduceProductService <span class="keyword">extends</span> CommandHandlerBase &#123;</span><br><span class="line">  <span class="keyword">private</span> pipelineEntity: PipelineEntity;</span><br><span class="line">  <span class="keyword">private</span> isRunning = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> readonly commandBus: CommandBus,</span></span><br><span class="line"><span class="params">    <span class="meta">@Inject</span>(produceProductServiceLoggerSymbol)</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> readonly logger: Logger,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> readonly config: ConfigService,</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> handle(</span><br><span class="line">    command: ProduceProductCommand,</span><br><span class="line">  ): <span class="built_in">Promise</span>&lt;Result&lt;<span class="built_in">boolean</span>, <span class="built_in">Error</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> specServer = <span class="keyword">this</span>.config.get(<span class="string">'app.specServer'</span>);</span><br><span class="line">    <span class="keyword">const</span> production = <span class="keyword">new</span> Production(&#123;</span><br><span class="line">      specs: command.specs.map(<span class="function">(<span class="params">spec</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> [name, count] = spec.split(<span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Spec(&#123;</span><br><span class="line">          name,</span><br><span class="line">          count: <span class="built_in">isNaN</span>(<span class="built_in">parseInt</span>(count)) ? <span class="number">1</span> : <span class="built_in">parseInt</span>(count),</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;),</span><br><span class="line">      concurrency: <span class="keyword">new</span> Concurrency(&#123;</span><br><span class="line">        n: command.concurrency,</span><br><span class="line">      &#125;),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.logger.log(<span class="string">`Spec server: <span class="subst">$&#123;specServer&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">this</span>.logger.log(</span><br><span class="line">      <span class="string">`Produces products: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(production.getRawProps(), <span class="literal">null</span>, <span class="number">2</span>)&#125;</span>`</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">const</span> result = PipelineEntity.create(&#123; production: production &#125;);</span><br><span class="line">    <span class="keyword">return</span> result.unwrap(</span><br><span class="line">      <span class="keyword">async</span> (pipeline) =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.isRunning = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.pipelineEntity = pipeline;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">this</span>.pipelineEntity.run();</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="literal">true</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">async</span> (error) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.err(error);</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isAvailable(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.isRunning;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getConcurrency(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.pipelineEntity.getConcurrency();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setConcurrency(value: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.logger.log(<span class="string">`Sets concurrency to: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">const</span> newConcurrency = <span class="keyword">new</span> Concurrency(&#123;</span><br><span class="line">      n: value,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.pipelineEntity.setConcurrency(newConcurrency);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSpecs(specs: <span class="built_in">string</span>[]) &#123;</span><br><span class="line">    <span class="keyword">this</span>.logger.log(<span class="string">`Adds specs: <span class="subst">$&#123;specs&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">const</span> additionalSpecs = specs.map(<span class="function">(<span class="params">spec</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> [name, count] = spec.split(<span class="string">':'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Spec(&#123;</span><br><span class="line">        name,</span><br><span class="line">        count: <span class="built_in">isNaN</span>(<span class="built_in">parseInt</span>(count)) ? <span class="number">1</span> : <span class="built_in">parseInt</span>(count),</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.pipelineEntity.addSpecs(additionalSpecs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSummary(): Summary &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.pipelineEntity.getSummary();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSpecs(): Spec[] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.pipelineEntity.getSpecs();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又是一长串代码，我们只看要点。下面的装饰器声明了这个类会负责处理 <code>ProduceProductCommand</code> 命令对象：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CommandHandler</span>(ProduceProductCommand)</span><br></pre></td></tr></table></figure><p>第二个重点是 <code>handle</code> 方法。如果你仔细看会发现这个方法已经碰到一点点业务的边了，但这还不是真正的业务逻辑，只是业务逻辑的组装。这个位置对应到领域驱动设计中是应用层(Appplicaiton Layer)。在这个方法中，我们先实例化了一个 <code>Production</code> 值对象(Value Object)，值对象不包含业务逻辑，它用来表示领域概念。比如在这里表示<code>生产</code>这个概念。需要注意的是，在这个建模过程中，我们始终紧密围绕生产这个核心上下文进行建模，以更好地表达领域语言。再往后看，出现了一个 <code>PipelineEntity</code>，<code>Production</code> 值对象作为 <code>PipelineEntity</code> 的 <code>create</code> 工厂方法的参数。<code>PipelineEntity</code> 是整个生产过程的核心，几乎所有业务逻辑都封装在这里面。<code>pipelineEntity.run()</code> 开始执行生产任务。</p><p>其他的一些方法，比如 <code>isAvailable</code>、<code>getConcurrency</code>、<code>setConcurrency</code> 等方法要么是维护一些简单的状态，要么只是 <code>pipelineEntity</code> 的代理，用来向外部提供一些方法以在可控的范围内获取/修改 <code>pipelineEntity</code> 的内部信息。</p><p>关于 <code>pipeline.entity.ts</code> 里的 <code>PipelineEntity</code> 只需要知道两点：</p><ul><li>PipelineEntity 是具体处理业务逻辑的地方。</li><li>PipelineEntity 会以一个给定的并发数从任务队列中取出产品规格进行生产，直到生产完全部产品。</li><li>我们可以通过 PipelineEntity 的 <code>setConcurrency</code> 方法设置并发数，通过 <code>addSpecs</code> 方法添加需要生产的产品规格和相应数量。</li></ul><h3 id="监控模块"><a href="#监控模块" class="headerlink" title="监控模块"></a>监控模块</h3><p><code>monitor.module.ts</code> 的代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/modules/monitor/monitor.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CqrsModule &#125; <span class="keyword">from</span> <span class="string">'@nestjs/cqrs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MonitorHttpController &#125; <span class="keyword">from</span> <span class="string">'./queries/monitor.http.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MonitorQueryHandler &#125; <span class="keyword">from</span> <span class="string">'./queries/monitor.query-handler'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UpdatePipelineHttpController &#125; <span class="keyword">from</span> <span class="string">'@modules/monitor/commands/update-pipeline/update-pipeline.http.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ProductionModule &#125; <span class="keyword">from</span> <span class="string">'@modules/production/production.module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> httpControllers = [MonitorHttpController, UpdatePipelineHttpController];</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  imports: [CqrsModule, ProductionModule],</span><br><span class="line">  controllers: [...httpControllers],</span><br><span class="line">  providers: [MonitorQueryHandler],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MonitorModule &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们将 <code>ProductionModule</code> 导入 <code>MonitorModule</code>，因为后者依赖前者。<code>controllers</code> 里是 <code>MonitorModule</code> 开放给外部的 HTTP API。<code>httpControllers</code> 中 <code>MonitorHttpController</code> 里放的是查询 controller，<code>UpdatePipelineHttpController</code> 放的是命令 controller。这里专门做了区分。<code>providers</code> 字段里是一个 <code>MonitorQueryHandler</code>，CQRS 将命令和查询分离，因此命令处理器和查询处理器也要分离。</p><p>先看 <code>monitor.http.controller.ts</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/modules/monitor/queries/monitor.http.controller.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Controller, HttpStatus, Get &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ApiTags, ApiOperation, ApiResponse &#125; <span class="keyword">from</span> <span class="string">'@nestjs/swagger'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MonitorQueryHandler &#125; <span class="keyword">from</span> <span class="string">'./monitor.query-handler'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; StatusHttpResponse &#125; <span class="keyword">from</span> <span class="string">'@modules/monitor/dtos/status.response.dto'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiTags</span>(<span class="string">'Monitor'</span>)</span><br><span class="line"><span class="meta">@Controller</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MonitorHttpController &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> readonly monitorQueryHandler: MonitorQueryHandler</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Get</span>(<span class="string">'/pipeline/status'</span>)</span><br><span class="line">  <span class="meta">@ApiOperation</span>(&#123; summary: <span class="string">'Get status of pipeline'</span> &#125;)</span><br><span class="line">  <span class="meta">@ApiResponse</span>(&#123;</span><br><span class="line">    status: HttpStatus.OK,</span><br><span class="line">    <span class="keyword">type</span>: StatusHttpResponse,</span><br><span class="line">  &#125;)</span><br><span class="line">  getStatus(): StatusHttpResponse &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatusHttpResponse(<span class="keyword">this</span>.monitorQueryHandler.getPipelineStatus());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MonitorHttpController</code> 很简单，暴露一个 endpoint <code>GET /pipeline/status</code>，内部直接调用 <code>MonitorQueryHandler</code> 的 <code>getPipelineStatus</code> 方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/modules/monitor/queries/monitor.query-handler.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ProduceProductService &#125; <span class="keyword">from</span> <span class="string">'@modules/production/commands/produce-product/produce-product.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ProductionStatus &#125; <span class="keyword">from</span> <span class="string">'@src/interface-adapters/interfaces/production/production-status.interface'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MonitorQueryHandler &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> readonly produceProductService: ProduceProductService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  getPipelineStatus(): ProductionStatus &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.produceProductService.isAvailable()) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125; <span class="keyword">as</span> ProductionStatus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      summary: <span class="keyword">this</span>.produceProductService.getSummary().getRawProps(),</span><br><span class="line">      concurrency: <span class="keyword">this</span>.produceProductService.getConcurrency(),</span><br><span class="line">      specs: <span class="keyword">this</span>.produceProductService</span><br><span class="line">        .getSpecs()</span><br><span class="line">        .map(<span class="function">(<span class="params">spec</span>) =&gt;</span> spec.getRawProps()),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MonitorQueryHandler</code> 里通过依赖注入的 <code>ProduceProductService</code> 获取 pipeline 状态。</p><p>接着再看 <code>update-pipeline.http.controller.ts</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/modules/monitor/commands/update-pipeline/update-pipeline.http.controller.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; ApiTags &#125; <span class="keyword">from</span> <span class="string">'@nestjs/swagger'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Controller, Patch, Body &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CommandBus &#125; <span class="keyword">from</span> <span class="string">'@nestjs/cqrs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UpdatePipelineHttpRequest &#125; <span class="keyword">from</span> <span class="string">'./update-pipeline.request.dto'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UpdatePipelineCommand &#125; <span class="keyword">from</span> <span class="string">'@modules/monitor/commands/update-pipeline/update-pipeline.command'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiTags</span>(<span class="string">'Monitor'</span>)</span><br><span class="line"><span class="meta">@Controller</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> UpdatePipelineHttpController &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> readonly commandBus: CommandBus</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Patch</span>(<span class="string">'/pipeline'</span>)</span><br><span class="line">  <span class="keyword">async</span> update(<span class="meta">@Body</span>() body: UpdatePipelineHttpRequest) &#123;</span><br><span class="line">    <span class="keyword">const</span> command = <span class="keyword">new</span> UpdatePipelineCommand(body);</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.commandBus.execute(command);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UpdatePipelineHttpController</code> 通过暴露一个 endpoint <code>PATCH /pipeline</code> 来动态更新命令行程序，它创建一个 <code>UpdatePipelineCommand</code> 实例，然后通过 <code>this.commandBus</code> 执行。</p><p>同样地，<code>UpdatePipelineCommand</code> 也是一个命令的信息载体：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/modules/monitor/commands/update-pipeline/update-pipeline.command.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Command,</span><br><span class="line">  CommandProps,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@libs/ddd/domain/base-classes/command.base'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> UpdatePipelineCommand <span class="keyword">extends</span> Command &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">props: CommandProps&lt;UpdatePipelineCommand&gt;</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.concurrency = props.concurrency;</span><br><span class="line">    <span class="keyword">this</span>.specs = props.specs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  readonly concurrency: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  readonly specs: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着会触发 <code>UpdatePipelineService</code> 的 <code>handle</code> 方法执行，这里也通过依赖注入的方式注入了一个 <code>ProduceProductService</code>实例，最后直接执行上面的 <code>setConcurrency</code> 和 <code>addSpecs</code> 方法来动态修改生产上下文中的参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/modules/monitor/commands/update-pipeline/update-pipeline.service.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Injectable, Scope, ConsoleLogger &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CommandBus, CommandHandler &#125; <span class="keyword">from</span> <span class="string">'@nestjs/cqrs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Result &#125; <span class="keyword">from</span> <span class="string">'@libs/ddd/domain/utils/result.util'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CommandHandlerBase &#125; <span class="keyword">from</span> <span class="string">'@libs/ddd/domain/base-classes/command-handler.base'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ProduceProductService &#125; <span class="keyword">from</span> <span class="string">'@modules/production/commands/produce-product/produce-product.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UpdatePipelineCommand &#125; <span class="keyword">from</span> <span class="string">'@modules/monitor/commands/update-pipeline/update-pipeline.command'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  scope: Scope.DEFAULT,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@CommandHandler</span>(UpdatePipelineCommand)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> UpdatePipelineService <span class="keyword">extends</span> CommandHandlerBase &#123;</span><br><span class="line">  <span class="keyword">private</span> logger = <span class="keyword">new</span> ConsoleLogger(UpdatePipelineService.name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> readonly commandBus: CommandBus,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> readonly produceProductService: ProduceProductService,</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> handle(</span><br><span class="line">    command: UpdatePipelineCommand,</span><br><span class="line">  ): <span class="built_in">Promise</span>&lt;Result&lt;<span class="built_in">boolean</span>, <span class="built_in">Error</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.produceProductService.isAvailable()) &#123;</span><br><span class="line">      <span class="keyword">return</span> Result.ok(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.produceProductService.setConcurrency(command.concurrency);</span><br><span class="line">    <span class="keyword">if</span> (command.specs) &#123;</span><br><span class="line">      <span class="keyword">this</span>.produceProductService.addSpecs(command.specs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们运行一下程序看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -g @nullcc/any-factory</span><br><span class="line">any-factory produce-products --specs=<span class="string">"a:10;b:20;c:30"</span> --concurrency=1 --with-server</span><br></pre></td></tr></table></figure><p>命令行中的日志：</p><p><img src="/assets/images/post_imgs/building-observable-and-dynamic-cli-app-1.png" alt="命令行中的日志"></p><p>HTTP Server swagger API：</p><p><img src="/assets/images/post_imgs/building-observable-and-dynamic-cli-app-2.png" alt="HTTP Server swagger API"></p><p>请求 pipeline 状态：</p><p><img src="/assets/images/post_imgs/building-observable-and-dynamic-cli-app-3.png" alt="请求 pipeline 状态"></p><p>修改 pipeline 参数：</p><p><img src="/assets/images/post_imgs/building-observable-and-dynamic-cli-app-4.png" alt="修改 pipeline 参数"></p><p>请求更新后的 pipeline 状态：</p><p><img src="/assets/images/post_imgs/building-observable-and-dynamic-cli-app-5.png" alt="请求更新后的 pipeline 状态"></p><p>现在可以更新一下可观察的动态命令行程序的基本结构图以给出一种通用结构：</p><p><img src="/assets/images/post_imgs/building-observable-and-dynamic-cli-app-6.png" alt="可观察的动态命令行程序"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在上面的实现中，我们在本地运行命令行程序时同时启动了一个 HTTP Server，对用户开放了一些 API，同时传统的日志记录形式还是可以继续使用（在文中和示例项目中没有展示出来）。在实现过程中，我们还通过模块化将不同上下文隔离开，它们之间可能会产生耦合，但都在我们的控制之中。例如虽然 MonitorModule 依赖于 ProductionModule，但后者的逻辑不会泄露到前者中。</p><p>上面除了讨论了如何构建可观察可修改的命令行程序以外，还应用了领域驱动设计的方法指导实现。当然，由于领域驱动设计是个相当大的主题，本文中无法详细描述。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://martinfowler.com/bliki/CQRS.html" target="_blank" rel="noopener">CQRS(命令查询职责分离)</a><br><a href="https://martinfowler.com/tags/domain%20driven%20design.html" target="_blank" rel="noopener">Domain Driven Design(领域驱动设计)</a><br><a href="https://github.com/nullcc/domain-driven-hexagon/blob/master/README-zh_CN.md" target="_blank" rel="noopener">DDD六边形架构(翻译)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讨论了构建可观察的动态命令行程序的一些实践。&lt;/p&gt;
    
    </summary>
    
      <category term="领域驱动设计" scheme="https://nullcc.github.io/categories/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="领域驱动设计" scheme="https://nullcc.github.io/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>基于 OpenResty 的插件化网关平台架构设计</title>
    <link href="https://nullcc.github.io/2021/07/09/%E5%9F%BA%E4%BA%8EOpenResty%E7%9A%84%E6%8F%92%E4%BB%B6%E5%8C%96%E7%BD%91%E5%85%B3%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>https://nullcc.github.io/2021/07/09/基于OpenResty的插件化网关平台架构设计/</id>
    <published>2021-07-08T16:00:00.000Z</published>
    <updated>2022-04-15T03:41:13.033Z</updated>
    
    <content type="html"><![CDATA[<p>本文详述了如何基于 OpenResty 设计一个插件化的架构。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OpenResty是一个基于 Nginx 与 Lua 的高性能 Web 平台，它在请求和响应的生命周期设计方面给我们提供了一种基于现有开源方案开发自己的插件化可扩展网关平台的可能性。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>我们不仅需要请求被正确地路由到相应的 upstream （这也是nginx作为反向代理最常用的一种方式），有时还关心请求和响应的一些细节。例如拒绝处理来自IP黑名单的请求、请求限流、鉴权、安全、动态加载SSL证书、日志收集、给请求的 header 打上 request id 以便追踪、请求/响应变换、mock、动态代理等等。甚至在一些测试场景中还会产生定制性很高的需求。</p><p>这些需求五花八门，如果能找到一种相对统一且优雅的处理方案，将提高开发和测试的效率。</p><h2 id="ngx-lua-module-中的请求生命周期"><a href="#ngx-lua-module-中的请求生命周期" class="headerlink" title="ngx-lua-module 中的请求生命周期"></a>ngx-lua-module 中的请求生命周期</h2><p>在真正描述我们的设计之前，需要了解 OpenResty 对请求生命周期的基本设计。ngx-lua-module 是 OpenResty 的一个核心 module 。它对一个 HTTP 请求的生命周期做了划分：</p><p><img src="/assets/images/post_imgs/luna-ngx-lua-module.png" alt="ngx-lua-module中的请求生命周期"></p><p>图中的星星和右边的一些图示是我自己加的，它们涉及到插件化的设计，之后会详细介绍。在划分出请求的生命周期后，我们获得了面向切编程(AOP)的能力，这是插件化的基础。</p><p>我们来具体看看图中请求生命周期的各个阶段（指令）。</p><h3 id="init-by-lua"><a href="#init-by-lua" class="headerlink" title="init_by_lua*"></a>init_by_lua*</h3><p>当 Nginx master 进程（如果有）加载 Nginx 配置文件时，在全局的 Lua 虚拟机上执行我们指定的代码。一般可以在这个阶段做一些全局性的工作。在我们等一下要讨论的插件化架构设计中，会在这个阶段读取应用程序配置文件以及注册插件。</p><h3 id="init-worker-by-lua"><a href="#init-worker-by-lua" class="headerlink" title="init_worker_by_lua*"></a>init_worker_by_lua*</h3><p>当 Nginx 开启 master 进程模式时， Nginx worker 进程启动时会执行指定的代码。如果关闭 master 模式，将在 init_by_lua_* 后直接运行。在这个阶段中可以创建一些定时器任务。</p><h3 id="ssl-certificate-by-lua"><a href="#ssl-certificate-by-lua" class="headerlink" title="ssl_certificate_by_lua*"></a>ssl_certificate_by_lua*</h3><p>这个阶段用来动态地加载SSL证书。这允许我们可以在建立连接前才设置证书和私钥，因此我们可以结合 SNI，针对不同的请求域名动态设置不同的证书和私钥。</p><h3 id="set-by-lua"><a href="#set-by-lua" class="headerlink" title="set_by_lua*"></a>set_by_lua*</h3><p>这个阶段允许我们使用 Lua 定义一些变量供后面的阶段使用。</p><h3 id="rewrite-by-lua"><a href="#rewrite-by-lua" class="headerlink" title="rewrite_by_lua*"></a>rewrite_by_lua*</h3><p>在重写阶段，我们可以修改对请求数据，比如修改URI、请求体和请求头等等。</p><h3 id="access-by-lua"><a href="#access-by-lua" class="headerlink" title="access_by_lua*"></a>access_by_lua*</h3><p>这个阶段一般用来检查请求的准入性，比如通过查询一些黑白名单来对请求进行拒绝和放行。</p><h3 id="content-by-lua"><a href="#content-by-lua" class="headerlink" title="content_by_lua*"></a>content_by_lua*</h3><p>这个阶段负责响应内容的生成，这个阶段可以说是灵活性最大的阶段。</p><h3 id="balancer-by-lua"><a href="#balancer-by-lua" class="headerlink" title="balancer_by_lua*"></a>balancer_by_lua*</h3><p>这个阶段负责处理负载均衡相关事宜。</p><h3 id="header-filter-by-lua"><a href="#header-filter-by-lua" class="headerlink" title="header_filter_by_lua*"></a>header_filter_by_lua*</h3><p>我们可以在这个阶段过滤响应头，比如动态地加入 Request ID。</p><h3 id="body-filter-by-lua"><a href="#body-filter-by-lua" class="headerlink" title="body_filter_by_lua*"></a>body_filter_by_lua*</h3><p>我们可以在这个阶段过滤响应体。需要注意的是，在进入这个阶段时，响应头已经全部发送给客户端，因此无法在该阶段修改响应头。</p><h3 id="log-by-lua"><a href="#log-by-lua" class="headerlink" title="log_by_lua*"></a>log_by_lua*</h3><p>日志阶段，可用供我们记录一些必要的信息。</p><p>关于这些指令的详细描述可以参考<a href="https://github.com/openresty/lua-nginx-module" target="_blank" rel="noopener">lua-nginx-module</a>，此处不再赘述。</p><h2 id="基本设计"><a href="#基本设计" class="headerlink" title="基本设计"></a>基本设计</h2><p>从一个比较高的视角来看，有了请求生命周期的阶段划分，我们可以将刚才描述的每个需求对应到一个或多个处理阶段中去。在实现时，针对每种需求（通用需求或特定需求都可以）设计一个插件，该插件只关心它需要关心的阶段。在网关收到针对某个 hostname 的请求时，框架应该先检查是否有针对该 host 的插件被注册，接着在请求的每个阶段一一调用这些插件中对应的指令方法（如果有的话）。</p><p>现在思路就比较明确了，我们来按顺序理一下整个过程：</p><ol><li>[<strong>init_by_lua*</strong>] Nginx master 进程加载 <code>nginx.conf</code> 启动并初始化，在 <code>init</code> 阶段读取插件配置，注册插件。</li><li>[<strong>init_worker_by_lua*</strong>] Nginx worker 进程启动并初始化，有些插件会在这个阶段注册定时器，定期执行某些操作。</li><li>[<strong>ssl_certificate_by_lua*</strong>] 如果是 HTTPS 请求，框架会调用与当前 hostname 关联的插件的 <code>ssl_certificate</code> 方法动态设置证书。</li><li>[<strong>set_by_lua*</strong>] 框架会调用与当前 hostname 关联的插件的 <code>set</code> 方法设置一些变量。</li><li>[<strong>rewrite_by_lua*</strong>] 框架会调用与当前 hostname 关联的插件的 <code>rewrite</code> 方法重写请求的数据。</li><li>[<strong>access_by_lua*</strong>] 框架会调用与当前 hostname 关联的插件的 <code>access</code> 方法判断请求准入性。</li><li>[<strong>content_by_lua*</strong>] 框架会调用与当前 hostname 关联的插件的 <code>content</code> 方法生成响应内容。</li><li>[<strong>balancer_by_lua*</strong>] 框架会调用与当前 hostname 关联的插件的 <code>balancer</code> 方法将请求转发到 upstream 。</li><li>[<strong>header_filter_by_lua*</strong>] 框架会调用与当前 hostname 关联的插件的 <code>header_filter</code> 方法过滤 response headers 。</li><li>[<strong>body_filter_by_lua*</strong>] 框架会调用与当前 hostname 关联的插件的 <code>body_filter</code> 方法过滤 response body 。至此，响应已经完全发送给客户端。</li><li>[<strong>log_by_lua*</strong>] 框架会调用与当前 hostname 关联的插件的 <code>log</code> 方法做一些日志相关的操作。</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>需要让这套逻辑生效，首先需要处理的是 <code>nginx.conf</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"># user  openresty;</span><br><span class="line">worker_processes  auto;</span><br><span class="line">worker_cpu_affinity auto;</span><br><span class="line"></span><br><span class="line">error_log  logs/error.log;</span><br><span class="line">pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">  use epoll;</span><br><span class="line">  worker_connections  65535;</span><br><span class="line">  multi_accept on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># environment variables</span><br><span class="line">env MYSQL_HOST;</span><br><span class="line">env MYSQL_PORT;</span><br><span class="line">env MYSQL_DB;</span><br><span class="line">env MYSQL_USER;</span><br><span class="line">env MYSQL_PASSWORD;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">  include    mime.types;</span><br><span class="line">  include    proxy.conf;</span><br><span class="line">  include    ../sites-enabled/*.conf;</span><br><span class="line">  include    ../sites-enabled/*/*.conf;</span><br><span class="line">  include    ../sites-enabled/*/*/*.conf;</span><br><span class="line"></span><br><span class="line">  resolver 8.8.8.8;</span><br><span class="line"></span><br><span class="line">  log_format   main &apos;$remote_addr - $remote_user [$time_local] $status &apos;</span><br><span class="line">  &apos;&quot;$request&quot; $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">  access_log   logs/access.log  main;</span><br><span class="line"></span><br><span class="line">  sendfile     on;</span><br><span class="line">  tcp_nopush   on;</span><br><span class="line">  tcp_nodelay on;</span><br><span class="line"></span><br><span class="line">  keepalive_timeout  65;</span><br><span class="line">  keepalive_disable none;</span><br><span class="line"></span><br><span class="line">  gzip on;</span><br><span class="line">  gzip_min_length 1k;</span><br><span class="line">  gzip_buffers 4 16k;</span><br><span class="line">  gzip_http_version 1.0;</span><br><span class="line">  gzip_comp_level 4;</span><br><span class="line">  gzip_types text/plain application/x-javascript text/css application/xml application/json;</span><br><span class="line">  gzip_vary on;</span><br><span class="line"></span><br><span class="line">  lua_socket_log_errors off;</span><br><span class="line"></span><br><span class="line">  # lua packages</span><br><span class="line">  lua_package_path   &quot;lualib/?.lua;/usr/local/openresty/nginx/lua/?.lua;/usr/local/openresty/nginx/plugins/?.lua;/usr/local/openresty/nginx/lualib/?.lua;;&quot;;</span><br><span class="line">  lua_package_cpath  &quot;lualib/?.so;/usr/local/openresty/nginx/lualib/?.so;;&quot;;</span><br><span class="line">  </span><br><span class="line">  lua_shared_dict ngx_cache 128m;</span><br><span class="line">  lua_shared_dict plugin_registry 4m;</span><br><span class="line"></span><br><span class="line">  lua_ssl_trusted_certificate &quot;/etc/ssl/certs/ca-bundle.crt&quot;;</span><br><span class="line"></span><br><span class="line">  init_by_lua_file         &quot;lua/directives/init.lua&quot;;</span><br><span class="line">  init_worker_by_lua_file  &quot;lua/directives/init_worker.lua&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只解释几个关键的地方：</p><ol><li>几个 MySQL 相关的环境变量用来连接数据库加载插件配置。</li><li>几个 <code>include ../sites-enabled/*.conf</code> 声明了 Nginx 启动时需要加载的具体站点的 conf 文件。</li><li><code>lua_package_path</code> 声明了搜索 lua 包的路径。</li><li><code>lua_package_cpath</code> 声明了搜索 so 库的路径。</li><li><code>lua_shared_dict plugin_registry 4m;</code> 声明了一个4M大小的共享内存，用来存放插件数据。</li><li><code>init_by_lua_file</code> 指定了在 <code>init</code> 阶段要调用的 Lua 脚本。</li><li><code>init_worker_by_lua_file</code> 指定了在 <code>init_worker</code> 阶段要调用的 Lua 脚本。</li></ol><p><code>lua/directives/init.lua</code> 负责加载插件配置，这里是从 MySQL 读取。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua/directives/init.lua</span></span><br><span class="line"><span class="keyword">local</span> runtime = <span class="built_in">require</span> <span class="string">"core.runtime"</span></span><br><span class="line"><span class="keyword">local</span> constants = <span class="built_in">require</span> <span class="string">"core.constants"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> app_plugins = runtime.load_app_plugin_conf_from_db()</span><br><span class="line">runtime.register_plugins(constants.PLUGIN_DIR, app_plugins)</span><br></pre></td></tr></table></figure><p><code>lua/directives/init_worker.lua</code> 中 <code>plugin_dispatch</code> 方法的第一个参数为 <code>nil</code>，意思是调用所有插件的 <code>init_worker</code> 方法。这里需要说明一下，除了 init 做初始化不涉及插件调用以及 init_worker 调用所有插件的 init_worker 方法以外，其他所有阶段都会调用 <code>runtime.plugin_dispatch</code> 方法来调用插件的相关方法，第一个参数为当前请求的 server name，第二个参数为当前的请求阶段。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua/directives/init_worker.lua</span></span><br><span class="line"><span class="keyword">local</span> phases = <span class="built_in">require</span> <span class="string">"core.phases"</span></span><br><span class="line"><span class="keyword">local</span> runtime = <span class="built_in">require</span> <span class="string">"core.runtime"</span></span><br><span class="line"><span class="keyword">local</span> uuid = <span class="built_in">require</span> <span class="string">"resty.jit-uuid"</span></span><br><span class="line"></span><br><span class="line">uuid.seed()</span><br><span class="line"></span><br><span class="line">runtime.plugin_dispatch(<span class="literal">nil</span>, phases.INIT_WORKER)</span><br></pre></td></tr></table></figure><p>共用的 nginx.conf 文件只需要描述这么多，在继续往下之前，我们先来看一个具体站点的 conf 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  listen       443 ssl;</span><br><span class="line">  server_name  api.foo.com;</span><br><span class="line">        </span><br><span class="line">  ssl_certificate      certs/test.crt;</span><br><span class="line">  ssl_certificate_key  certs/test.key;</span><br><span class="line"></span><br><span class="line">  ssl_certificate_by_lua_file &quot;lua/directives/ssl_certificate.lua&quot;;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    lua_code_cache on;</span><br><span class="line">    resolver 127.0.0.11;</span><br><span class="line"></span><br><span class="line">    rewrite_by_lua_file &quot;lua/directives/rewrite.lua&quot;;</span><br><span class="line">    access_by_lua_file &quot;lua/directives/access.lua&quot;;</span><br><span class="line">    content_by_lua_file &quot;lua/directives/content.lua&quot;;</span><br><span class="line">    header_filter_by_lua_file &quot;lua/directives/header_filter.lua&quot;;</span><br><span class="line">    body_filter_by_lua_file &quot;lua/directives/body_filter.lua&quot;;</span><br><span class="line">    log_by_lua_file &quot;lua/directives/log.lua&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个 server block 声明了一些信息：</p><ol><li>因为我们用到了 <code>ssl_certificate_by_lua_file</code> 来动态加载SSL证书，所以<code>ssl_certificate</code> 和 <code>ssl_certificate_key</code> 被设置成了一个基本的 crt 和 key 文件，如果不设置会报错。</li><li>在 <code>location /</code> block 中声明了各种 <code>*_by_lua_file</code> 对应的脚本。</li></ol><p>现在可以继续看其他指令的脚本文件了。</p><p><code>lua/directives/ssl_certificate.lua</code>:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ssl = <span class="built_in">require</span> <span class="string">"ngx.ssl"</span></span><br><span class="line"><span class="keyword">local</span> phases = <span class="built_in">require</span> <span class="string">"core.phases"</span></span><br><span class="line"><span class="keyword">local</span> runtime = <span class="built_in">require</span> <span class="string">"core.runtime"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> server_name, err = ssl.server_name()</span><br><span class="line">runtime.plugin_dispatch(server_name, phases.SSL_CERTIFICATE)</span><br></pre></td></tr></table></figure><p><code>lua/directives/rewrite.lua</code>:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua/directives/rewrite.lua</span></span><br><span class="line"><span class="keyword">local</span> phases = <span class="built_in">require</span> <span class="string">"core.phases"</span></span><br><span class="line"><span class="keyword">local</span> runtime = <span class="built_in">require</span> <span class="string">"core.runtime"</span></span><br><span class="line"></span><br><span class="line">runtime.plugin_dispatch(ngx.var.server_name, phases.REWRITE)</span><br></pre></td></tr></table></figure><p><code>lua/directives/set.lua</code>:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua/directives/set.lua</span></span><br><span class="line"><span class="keyword">local</span> phases = <span class="built_in">require</span> <span class="string">"core.phases"</span></span><br><span class="line"><span class="keyword">local</span> runtime = <span class="built_in">require</span> <span class="string">"core.runtime"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> runtime.plugin_dispatch(ngx.var.server_name, phases.SET)</span><br></pre></td></tr></table></figure><p><code>lua/directives/access.lua</code>:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua/directives/access.lua</span></span><br><span class="line"><span class="keyword">local</span> phases = <span class="built_in">require</span> <span class="string">"core.phases"</span></span><br><span class="line"><span class="keyword">local</span> runtime = <span class="built_in">require</span> <span class="string">"core.runtime"</span></span><br><span class="line"></span><br><span class="line">runtime.plugin_dispatch(ngx.var.server_name, phases.ACCESS)</span><br></pre></td></tr></table></figure><p><code>lua/directives/content.lua</code>:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua/directives/content.lua</span></span><br><span class="line"><span class="keyword">local</span> phases = <span class="built_in">require</span> <span class="string">"core.phases"</span></span><br><span class="line"><span class="keyword">local</span> runtime = <span class="built_in">require</span> <span class="string">"core.runtime"</span></span><br><span class="line"></span><br><span class="line">runtime.plugin_dispatch(ngx.var.server_name, phases.CONTENT)</span><br></pre></td></tr></table></figure><p><code>lua/directives/balancer</code>:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua/directives/balancer</span></span><br><span class="line"><span class="keyword">local</span> phases = <span class="built_in">require</span> <span class="string">"core.phases"</span></span><br><span class="line"><span class="keyword">local</span> runtime = <span class="built_in">require</span> <span class="string">"core.runtime"</span></span><br><span class="line"></span><br><span class="line">runtime.plugin_dispatch(ngx.var.server_name, phases.BALANCER)</span><br></pre></td></tr></table></figure><p><code>lua/directives/header_filter</code>:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua/directives/header_filter</span></span><br><span class="line"><span class="keyword">local</span> phases = <span class="built_in">require</span> <span class="string">"core.phases"</span></span><br><span class="line"><span class="keyword">local</span> runtime = <span class="built_in">require</span> <span class="string">"core.runtime"</span></span><br><span class="line"></span><br><span class="line">runtime.plugin_dispatch(ngx.var.server_name, phases.HEADER_FILTER)</span><br></pre></td></tr></table></figure><p><code>lua/directives/body_filter</code>:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua/directives/body_filter</span></span><br><span class="line"><span class="keyword">local</span> phases = <span class="built_in">require</span> <span class="string">"core.phases"</span></span><br><span class="line"><span class="keyword">local</span> runtime = <span class="built_in">require</span> <span class="string">"core.runtime"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Should concat response body chunk if it's not the end of response stream</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> chunk = ngx.<span class="built_in">arg</span>[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> end_of_resp_stream = ngx.<span class="built_in">arg</span>[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> end_of_resp_stream == <span class="literal">false</span> <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> ngx.ctx.response_body == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    ngx.ctx.response_body = chunk</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ngx.ctx.response_body = ngx.ctx.response_body .. chunk</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  ngx.ctx.end_of_resp_stream = <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">runtime.plugin_dispatch(ngx.var.server_name, phases.BODY_FILTER)</span><br></pre></td></tr></table></figure><p>关于 body_filter 阶段需要特别说明一下，由于 Nginx 从 updtream 获取 response body 并不是一次获取所有，而是分块 (chunked) 获取。并且每取得一个分块，Nginx 都会触发一次 body_filter 。为了灵活性最大化，这里设置了一个 <code>ngx.ctx.end_of_resp_stream</code> 上下文变量来让插件判断当前的响应数据传输是否已经结束。这样不管是想处理每个分块还是按照整体来处理整个响应的插件都可以工作。</p><p><code>lua/directives/log</code>:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua/directives/log</span></span><br><span class="line"><span class="keyword">local</span> phases = <span class="built_in">require</span> <span class="string">"core.phases"</span></span><br><span class="line"><span class="keyword">local</span> runtime = <span class="built_in">require</span> <span class="string">"core.runtime"</span></span><br><span class="line"></span><br><span class="line">runtime.plugin_dispatch(ngx.var.server_name, phases.LOG)</span><br></pre></td></tr></table></figure><h3 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h3><p>之前提到 init 指令会调用 <code>runtime.register_plugins</code> 注册插件，其他指令会调用 <code>runtime.plugin_dispatch</code> 触发插件相应阶段的指令方法。</p><p>先来看注册、加载和卸载插件的代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua/core/runtime.lua</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;</span><br><span class="line">  <span class="built_in">_VERSION</span> = <span class="string">'0.0.1'</span>,</span><br><span class="line">  _plugins = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.register_plugins</span><span class="params">(plugin_dir, app_plugins)</span></span></span><br><span class="line">  <span class="keyword">for</span> _, app_plugin <span class="keyword">in</span> <span class="built_in">ipairs</span>(app_plugins) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = _M.load_plugin(plugin_dir, app_plugin.server_name, app_plugin.plugin_name, app_plugin.args <span class="keyword">or</span> &#123;&#125;)</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"[rumtime] failed to load plugin: %s, err: %s"</span>, app_plugin.plugin_name, err))</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.load_plugin</span><span class="params">(plugin_dir, server_name, plugin_name, args)</span></span></span><br><span class="line">  <span class="keyword">local</span> plugin_path = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"%s/%s.lua"</span>, plugin_dir, plugin_name)</span><br><span class="line">  <span class="keyword">local</span> plugin_module, err = <span class="built_in">loadfile</span>(plugin_path)</span><br><span class="line">  <span class="keyword">if</span> plugin_module == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, <span class="built_in">error</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"[runtime] plugin not found, plugin: %s, error: %s"</span>, plugin_name, err))</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">local</span> plugin = plugin_module()</span><br><span class="line">  plugin.init_plugin(args)</span><br><span class="line">  <span class="keyword">local</span> key = <span class="built_in">string</span>.<span class="built_in">lower</span>(server_name)</span><br><span class="line">  <span class="keyword">if</span> _M._plugins[key] == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    _M._plugins[key] = &#123;&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="built_in">table</span>.<span class="built_in">insert</span>(_M._plugins[key], plugin)</span><br><span class="line">  ngx.<span class="built_in">log</span>(ngx.ERR, <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"[runtime] plugin \"%s\" for server name \"%s\", args: %s loaded"</span>, plugin_name, key, cjson.encode(args)))</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.unload_plugin</span><span class="params">(server_name, plugin_name)</span></span></span><br><span class="line">  <span class="keyword">local</span> plugins = _M._plugins[server_name]</span><br><span class="line">  <span class="keyword">if</span> plugins ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(plugins) <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">if</span> plugin_name == v._NAME <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">remove</span>(plugins, i)</span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"[runtime] plugin \"%s\" for server name \"%s\" unloaded"</span>, plugin_name, server_name))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>register_plugins</code> 注册插件，它在内部调用 <code>load_plugin</code> 执行具体的注册操作。<code>load_plugin</code> 调用 <code>loadfile</code> 从指定的目录加载并用参数初始化插件，然后插入到 <code>_plugins</code> 这个 table 中，注意这里把 <code>_plugins</code> 当成一个字典来用，键是 server name，值是插件数组。<code>unload_plugin</code> 用来卸载指定 hostname 下的指定插件。<code>load_plugin</code> 和 <code>unload_plugin</code> 可以结合一套插件管理 API 来动态加载/卸载 API 。</p><p>接下来是指令调用插件的代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua/core/runtime.lua</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.plugin_dispatch</span><span class="params">(server_name, phase)</span></span></span><br><span class="line">  ngx.<span class="built_in">log</span>(ngx.ERR, server_name, <span class="string">", "</span>, phase)</span><br><span class="line">  <span class="keyword">local</span> plugins = _M.get_plugins(server_name)</span><br><span class="line">  <span class="keyword">if</span> plugins ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">for</span> _, plugin <span class="keyword">in</span> <span class="built_in">ipairs</span>(plugins) <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">if</span> plugin[phase] ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> ok, ret = <span class="built_in">pcall</span>(plugin[phase])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">          ngx.<span class="built_in">log</span>(ngx.ERR, <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"[rumtime] dispatch error, plugin name: %s, phase: %s, err: %s"</span>, plugin._NAME, phase, ret))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.get_plugins</span><span class="params">(server_name)</span></span></span><br><span class="line">  <span class="keyword">if</span> server_name == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">local</span> plugins = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, server_plugins <span class="keyword">in</span> <span class="built_in">pairs</span>(_M._plugins) <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">for</span> _, plugin <span class="keyword">in</span> <span class="built_in">ipairs</span>(server_plugins) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(plugins, plugin)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> plugins</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">local</span> key = <span class="built_in">string</span>.<span class="built_in">lower</span>(server_name)</span><br><span class="line">  <span class="keyword">return</span> _M._plugins[key]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>plugin_dispatch</code> 首先使用 server name 调用 <code>get_plugins</code> 来获取和 server name 相关联的所有插件。这里如果 server name 为 <code>nil</code> 则会将返回所有插件，之前在 init_worker 指令中见到了这种用法。在获得插件列表后，<code>plugin_dispatch</code> 会遍历插件列表，使用 <code>pcall</code> 调用 <code>plugin[phase]</code>。<code>pcall</code> 的意思是 <code>protected call</code>，也就是一种保护模式调用，这个调用中如果出现错误，会以返回码的方式告诉调用方而不会导致请求处理直接挂掉。</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>刚才我们一直围绕插件展开讨论，但插件究竟是个什么东西我们一直没提。插件其实就是一个 Lua table，里面有一些数据和指令相关的方法。下面是插件的基本定义：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua/core/plugin.lua</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.init_plugin</span><span class="params">(...)</span></span></span><br><span class="line">  <span class="keyword">local</span> plugin, args = ...</span><br><span class="line">  <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">pairs</span>(args) <span class="keyword">do</span></span><br><span class="line">    plugin[key] = value</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">type</span>(plugin._init_plugin) == <span class="string">"function"</span> <span class="keyword">then</span></span><br><span class="line">    plugin._init_plugin()</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(table, key)</span></span></span><br><span class="line">    <span class="keyword">local</span> value = _M[key]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(value) == <span class="string">"function"</span> <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span></span><br><span class="line">        <span class="keyword">return</span> value(<span class="built_in">table</span>, ...)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经知道 runtime 在调用插件方法时的调用链是这样的：</p><ol><li><code>runtime.plugin_dispatch(server_name, phase)</code></li><li><code>runtime.get_plugins(server_name)</code></li><li><code>pcall(plugin[phase])</code></li></ol><p>在第三步 <code>pcall(plugin[phase])</code> 中，runtime 会先获取 <code>plugin[phase]</code>。这里要注意，pcall 的参数是一个函数（或者说闭包），但我们之前说过，每个插件只会实现它关心的指令，因此这里 <code>plugin[phase]</code> 有可能是 <code>nil</code>，即没有实现。所以我们在 <code>pcall(plugin[phase])</code> 之前需要先判断 <code>plugin[phase]</code> 是否存在。</p><p><code>plugin.lua</code> 中还用到了 <code>metatable.__index</code>，这里需要解释一下为什么这么写。大部分插件会有一些初始化参数需要在加载时赋值给插件，另外插件可能自己也有一些初始化逻辑，如果每个插件都写一遍参数初始化的代码很麻烦。Lua 中 metatable的工作机制是，当通过键来访问 table 的时候，如果这个键没有值，那么 Lua 就会查找该 table 的 metatable（如果有的话）中的 <strong>index 。如果</strong>index 是一个 table，Lua会在表格中查找相应的键。如果 __index 是一个函数，Lua 就会用 table 和键调用那个函数。这个机制有点类似 JavaScript 中的 prototype 。</p><p>由于 <code>plugin.lua</code> 返回的 table 包含一个 <code>__index</code>，且 <code>__index</code> 是一个函数。那么只要具体的插件把这个 table 设置为自己的 metatable，当在这个插件上调用一个不存在的方法时，Lua 就会去它的 metatable 中调用 <code>__index</code> 键对应的函数。于是像初始化插件这样的通用操作就可以放在 <code>plugin.lua</code> 中实现了。</p><h3 id="一个具体的插件"><a href="#一个具体的插件" class="headerlink" title="一个具体的插件"></a>一个具体的插件</h3><p>上面说了这么多，我们还没有见过真正可以用的插件长什么样。这里展示一个叫做 <code>request-id</code> 的插件，它可以给所有 response headers 加上一个指定的header，其中键可以由插件参数指定，值是一个UUID。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- plugins/request-id.lua</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--- request-id</span></span><br><span class="line"><span class="comment">-- Add request-id in HTTP response headers</span></span><br><span class="line"><span class="comment">-- @module request-id</span></span><br><span class="line"><span class="comment">-- @license MIT</span></span><br><span class="line"><span class="comment">-- @release 0.0.1</span></span><br><span class="line"><span class="comment">-- @phases init_worker, header_filter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> uuid = <span class="built_in">require</span> <span class="string">"resty.jit-uuid"</span></span><br><span class="line"><span class="keyword">local</span> meta_plugin = <span class="built_in">require</span> <span class="string">"core.plugin"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> _M = &#123;</span><br><span class="line">  <span class="built_in">_VERSION</span> = <span class="string">"0.0.1"</span>,</span><br><span class="line">  _NAME = <span class="string">"request-id"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- args</span></span><br><span class="line">  key = <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setmetatable</span>(_M, meta_plugin)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.init_worker</span><span class="params">()</span></span></span><br><span class="line">  uuid.seed()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.header_filter</span><span class="params">()</span></span></span><br><span class="line">  ngx.header[_M.key] = uuid()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure><p><code>request-id</code> 插件只有一个参数 key，每个插件都必须调用 <code>setmetatable(_M, meta_plugin)</code> 来讲上面说的基础插件设置成自己的 metatable，以便自动获得初始化函数（如果有其他需要在插件之间共享的函数也可以加进去）。这个插件涉及的指令只有 <code>init_worker</code> 和 <code>header_filter</code>，在 init_worker 中为 uuid 库初始化了随机数种子，在 header_filter 中将一个 key 为 ）_M.key，值为 uuid 的 header 设置到 response headers 中，就这么简单。</p><p>还有一些更复杂的插件，由于篇幅所限无法全部展示出来。不过一旦理解了基本原理和设计，要创建新的插件也不是什么难事。</p><h2 id="实现原则"><a href="#实现原则" class="headerlink" title="实现原则"></a>实现原则</h2><p>有一个实现原则是，不同插件之间不应该产生关联，比如共享状态或者对调用顺序有任何假设。这是因为如果插件之间存在关联，则运行时的效果可能是不可预知的。举个比较刻意的例子，假设对 <a href="http://www.foo.com" target="_blank" rel="noopener">www.foo.com</a> 我们注册有 A 和 B 两个插件，A 在设置了 ngx.ctx.foo = “a” 并在之后读取了 ngx.ctx.foo，B 设置了 ngx.ctx.foo = “b” 并在之后读取了 ngx.ctx.foo。由于框架对插件的调用顺序和他们被注册的顺序一致（一般来说这样设计没问题，因为框架本身并不关心插件的被调用顺序，只是按序遍历插件列表逐个调用罢了。）且 A 在 B 之前被注册，则实际结果是 A 在读取 ngx.ctx.foo 时期望读到的是 “a”，但读到的却是 “b”，因为 ngx.ctx.foo 这个变量在 A 和 B 之间是共享的且 B 比 A 晚执行覆盖了这个变量。</p><p>插件间不应产生关联虽说是原则，但从技术上我们无法阻止有人编写存在关联的插件，只能尽量避免。一个比较好的实践是：在插件内如果有需要用到 <code>ngx.ctx</code> 这种请求相关的上下文变量时，给他一个前缀以降低和其他插件冲突的风险。nginx 内部还有一种范围更广共享方式是使用 <code>lua_shared_dict</code>，这种方式是全局的，可以被所有 worker 共享，使用这种共享内存需要特别小心。如果把视角放到 nginx 之外，产生关联方式就更多了：数据库、缓存、文件等等，其实道理都是一样的，插件间的关联会产生不确定性。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>还可以继续完善这套系统，加入插件管理 API，这部分内容以上面的描述为基础，限于篇幅这里就不展开说了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文详述了如何基于 OpenResty 设计一个插件化的架构。&lt;/p&gt;
    
    </summary>
    
      <category term="Web后端" scheme="https://nullcc.github.io/categories/Web%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="OpenResty" scheme="https://nullcc.github.io/tags/OpenResty/"/>
    
      <category term="插件" scheme="https://nullcc.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>transformer+source map实现TypeScript函数+行列级别错误定位</title>
    <link href="https://nullcc.github.io/2021/04/02/transformer+source%20map%E5%AE%9E%E7%8E%B0TypeScript%E5%87%BD%E6%95%B0+%E8%A1%8C%E5%88%97%E7%BA%A7%E5%88%AB%E9%94%99%E8%AF%AF%E5%AE%9A%E4%BD%8D/"/>
    <id>https://nullcc.github.io/2021/04/02/transformer+source map实现TypeScript函数+行列级别错误定位/</id>
    <published>2021-04-01T16:00:00.000Z</published>
    <updated>2022-04-15T03:41:13.026Z</updated>
    
    <content type="html"><![CDATA[<p>本文将给出一个在运行时获取TS函数完整原始代码并展示出错点的方式。</p><a id="more"></a><h2 id="场景和需求"><a href="#场景和需求" class="headerlink" title="场景和需求"></a>场景和需求</h2><p>在使用TypeScript实现的自动化测试场景中，一般情况下如果测试失败我们都会打印出error message和error stack信息（比如显示在一些dashboard中）来方便我们排查问题。不过这种做法只能获取到出错点的文件和行列号。而且如果运行的是编译成JS后的代码，获取到的文件名和行列号都是JS代码的。当然你可能会说可以使用source map转换成原始的TS代码文件的行列号，或者不主动编译成JS，而是使用ts-node直接运行TS代码，这样报错信息里的代码和行列号就是TS的了。我们确实可以这么做，但也就仅此而已。</p><p>如果能取到出错点对应的方法或函数的完整原始TS代码并展示出出错点和出错信息，直接在错误报告中打印出来，岂不是可以省掉再去工程文件中定位到对应文件和行列号这个步骤，在test case数量大且运行频繁的时候，这种做法能节省我们不少排错时间。</p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>很多人知道在JS中可以使用<code>toString</code>方法打印出函数（非native函数，打印native函数源码只会显示<code>function () { [native code] }</code>）的源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add.toString());</span><br></pre></td></tr></table></figure><p>运行<code>node a.js</code>，脚本会打印出add函数的JS源码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在TS中也能这么做，但打印出的代码并不是TS源码，而是转换成JS后的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.ts</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add.toString());</span><br></pre></td></tr></table></figure><p>运行<code>ts-node b.ts</code>，脚本打印出的add函数源码还是JS的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用tsc编译结果也是一样的，这里就不列出了。</p><p>很显然，不管是用ts-node隐式编译或者是用tsc显式编译TS代码，我们无法简单地使用toString方法来打印函数的完整TS源码。</p><p>不过这也难不倒我们，TS中的transformer是一个很强大的工具，它允许我们在编译阶段对TS代码的抽象语法树(AST)做一些操作。实际上，在transformer中我们可以访问AST的所有node，这些node里有一些信息是我们感兴趣的，比如TS文件名、函数/方法声明的start和end信息，这些TS源码级别的信息有助于实现我们的目标。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这个transformer有几个要实现的目标：</p><ol><li>找到所有函数和方法的声明点，并记录它们在TS源码中的起止位置。</li><li>将这些记录输出到一个外部文件中。</li></ol><p>第一个目标可以通过遍历所有的AST node来实现，使用下面的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transformer.ts</span></span><br><span class="line"><span class="keyword">import</span> ts <span class="keyword">from</span> <span class="string">"typescript"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (program: ts.Program, fileFnRangeMap: <span class="built_in">any</span>): ts.TransformerFactory&lt;ts.SourceFile&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">ctx: ts.TransformationContext</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (sourceFile: ts.SourceFile): ts.SourceFile =&gt; &#123;</span><br><span class="line">      <span class="comment">// 这里定义访问者方法，该方法会在TS遍历每个AST node时被调用</span></span><br><span class="line">      <span class="keyword">const</span> visitor = (node: ts.Node): ts.Node =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> ts.visitEachChild(visitNode(node, program, sourceFile.fileName, fileFnRangeMap), visitor, ctx);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> &lt;ts.SourceFile&gt; ts.visitEachChild(visitNode(sourceFile, program, sourceFile.fileName, fileFnRangeMap), visitor, ctx);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码实际是一个访问者模式的典型用法，我们不用关心TS在编译代码时具体是怎么遍历AST的，我们只需要提供一个方法，告诉TS在访问到每个node时该做什么。<code>visitNode</code>方法需要我们自己实现。另外你可能会好奇<code>fileFnRangeMap</code>是做什么的，可以暂时先忽略这个参数。</p><p>再来看<code>visitNode</code>方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transformer.ts</span></span><br><span class="line"><span class="keyword">const</span> visitNode = (node: ts.Node, program: ts.Program, fileName: <span class="built_in">string</span>, fileFnRangeMap: <span class="built_in">any</span>): ts.Node =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ts.isSourceFile(node)) &#123;</span><br><span class="line">    fileFnRangeMap[node.fileName] = [];</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!isFnDeclaration(node)) &#123;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> start, end = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> positions = fileFnRangeMap[fileName];</span><br><span class="line">  <span class="keyword">if</span> (isVariableDeclarationWithArrowFunction(node)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ts.isVariableDeclarationList(node.parent) || ts.isVariableDeclaration(node.parent)) &#123;</span><br><span class="line">      start = node.parent.pos;</span><br><span class="line">      end = node.parent.end;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    start = node.pos;</span><br><span class="line">    end = node.end;</span><br><span class="line">  &#125;</span><br><span class="line">  positions.push(&#123; start, end &#125;);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isFnDeclaration = (node: ts.Node): <span class="function"><span class="params">boolean</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ts.isFunctionDeclaration(node)</span><br><span class="line">    || ts.isFunctionExpression(node)</span><br><span class="line">    || isVariableDeclarationWithArrowFunction(node)</span><br><span class="line">    || ts.isArrowFunction(node)</span><br><span class="line">    || ts.isMethodDeclaration(node)</span><br><span class="line">    || ts.isConstructorDeclaration(node);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isVariableDeclarationWithArrowFunction = (node: ts.Node): <span class="function"><span class="params">boolean</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ts.isVariableDeclaration(node) &amp;&amp; !!node.initializer &amp;&amp; ts.isArrowFunction(node.initializer);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在TS遍历AST node时会对每个node调用该方法，首先判断当前node是否是<code>SourceFile</code> node，如果是就从中提取出这个文件的名称，并设置<code>fileFnRangeMap</code>中以这个文件名为key的value为一个空数组，我们不打算对node做任何操作，因此直接返回它。如果不是<code>SourceFile</code> node，就判断它是否是一个函数声明node，函数声明node有以下几种：</p><ul><li>使用function声明的函数</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>箭头函数</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> results = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce((x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>带赋值语句的箭头函数</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>类构造函数和类方法声明</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Calc &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要识别出这几种node，我们可以直接使用typescript提供了一些方法来判断，像这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts.isFunctionDeclaration(node)</span><br></pre></td></tr></table></figure><p>如果是上述几种我们关心的函数声明node，需要获取下它们在TS源码里的起止位置，并push到<code>fileFnRangeMap[$sourceFileName]</code>中。这里我们还是不会对node做任何操作，直接返回即可。</p><p>回顾这部分的内容，这个transformer帮助我们在TS遍历AST时记录下我们所关心的函数声明node的起止位置，并把这些信息记录到<code>fileFnRangeMap</code>中以相应文件名为key的数组里。</p><p>到此，我们已经准备好了TS源码中所有函数声明的信息，之后把它输出到一个外部文件就行了。为了输出到外部文件，有一种做法是在遍历到每个函数声明node时把<code>fileFnRangeMap</code>字符串化并存储到文件，这么做可以但效率太低，因为每遍历到一个函数声明node都要写一次文件。 其实我们可以在外部实现这个操作，这就需要控制整个TS编译过程，使用一个<code>compile.ts</code>文件来控制：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compile.ts</span></span><br><span class="line"><span class="keyword">import</span> ts <span class="keyword">from</span> <span class="string">"typescript"</span>;</span><br><span class="line"><span class="keyword">import</span> transformer <span class="keyword">from</span> <span class="string">"./transformer"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> util <span class="keyword">from</span> <span class="string">"./util"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; OUTPUT_FILE_NAME &#125; <span class="keyword">from</span> <span class="string">"./constant"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params">dir: <span class="built_in">string</span>, configFilePath: <span class="built_in">string</span>, writeFileCallback?: ts.WriteFileCallback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parsedCommandLine = ts.getParsedCommandLineOfConfigFile(configFilePath, <span class="literal">undefined</span> <span class="keyword">as</span> <span class="built_in">any</span>, ts.sys <span class="keyword">as</span> <span class="built_in">any</span>);</span><br><span class="line">  <span class="keyword">if</span> (!parsedCommandLine) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Parsing TS config file error!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> filePaths = util.scan(dir);</span><br><span class="line">  <span class="keyword">const</span> compilerOptions = parsedCommandLine.options;</span><br><span class="line">  compilerOptions.sourceMap = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> program = ts.createProgram(filePaths, compilerOptions);</span><br><span class="line">  <span class="keyword">const</span> fileFnRangeMap = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> transformers: ts.CustomTransformers = &#123;</span><br><span class="line">    before: [transformer(program, fileFnRangeMap)],</span><br><span class="line">    after: [],</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> &#123; emitSkipped, diagnostics &#125; = program.emit(<span class="literal">undefined</span>, writeFileCallback, <span class="literal">undefined</span>, <span class="literal">false</span>, transformers);</span><br><span class="line">  <span class="keyword">if</span> (emitSkipped) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(diagnostics.map(<span class="function"><span class="params">diagnostic</span> =&gt;</span> diagnostic.messageText).join(<span class="string">'\n'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  util.writeToFile(OUTPUT_FILE_NAME, <span class="built_in">JSON</span>.stringify(fileFnRangeMap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>compile.ts</code>里的compile方法的用法是这样的： </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile(sourceCodeDir, tsconfigFile);</span><br></pre></td></tr></table></figure><p>有几个地方需要说明，<code>compile</code>中强制开启了source map，因为我们必须借助source map才能通过编译后的JS代码行列号定位到TS源码的行列号。<code>compile</code>方法让我们能控制整个TS编译过程。注意第16行声明了一个<code>fileFnRangeMap</code>对象并将它作为<code>transformer</code>方法的第二个参数。接着在最后将<code>fileFnRangeMap</code>对象字符串化到文件里。</p><p>来看一个例子，假设有一个项目目录和文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|---my-app</span><br><span class="line">|   |---src</span><br><span class="line">|   |   |---inner</span><br><span class="line">|   |   |   |---b.ts</span><br><span class="line">|   |   |---a.ts</span><br></pre></td></tr></table></figure><p>src/a.ts:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>src/inner/b.ts:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> add = (a: <span class="built_in">number</span>, b: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Calc &#123;</span><br><span class="line">  add(a: <span class="built_in">number</span>, b: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在使用如下代码编译后会在当前目录生成一个<code>_ts-err-hunter-file-fn-range.json</code>文件，里面记录了<code>src</code>目录下所有TS文件里方法声明的起止位置，另外我们还获得了source map。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">"src"</span>, <span class="string">"tsconfig.json"</span>);</span><br></pre></td></tr></table></figure><p>_ts-err-hunter-file-fn-range.json:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"src/a.ts"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"start"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"end"</span>: <span class="number">69</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"src/inner/b.ts"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"start"</span>: <span class="number">6</span>,</span><br><span class="line">      <span class="attr">"end"</span>: <span class="number">72</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"start"</span>: <span class="number">18</span>,</span><br><span class="line">      <span class="attr">"end"</span>: <span class="number">72</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"start"</span>: <span class="number">93</span>,</span><br><span class="line">      <span class="attr">"end"</span>: <span class="number">153</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有了上面这些信息，当运行时报错时，我们就可以通过error stack获得出错点的JS文件路径和行列号。然后使用source map查找到对应TS文件的路径和行列号。再计算出TS文件的行列号对应的位置，并查询该位置在<code>_ts-err-hunter-file-fn-range.json</code>里的对应文件中落在哪个函数声明区间，这个区间的起止位置就是这个出错点在TS文件中函数的完整区间了。最后直接把这个区间的代码打印出来可以了。具体的查找过程不复杂，就不赘述了。</p><h2 id="ts-err-hunter"><a href="#ts-err-hunter" class="headerlink" title="ts-err-hunter"></a>ts-err-hunter</h2><p>我写了<a href="https://github.com/nullcc/ts-err-hunter" target="_blank" rel="noopener">ts-err-hunter</a>这个package来实现整个过程。</p><p>为了使用<code>ts-err-hunter</code>, 需要将下面的代码加入到项目的入口文件里：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; register &#125; <span class="keyword">from</span> <span class="string">"ts-err-hunter"</span>;</span><br><span class="line"></span><br><span class="line">register();</span><br></pre></td></tr></table></figure><p>我们假设项目的源码目录是<code>src</code>，且<code>tsconfig.json</code>文件在项目根目录。创建一个名为<code>compile.ts</code>的文件，代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; compile &#125; <span class="keyword">from</span> <span class="string">"ts-err-hunter"</span>;</span><br><span class="line"></span><br><span class="line">compile(<span class="string">"src"</span>, <span class="string">"tsconfig.json"</span>);</span><br></pre></td></tr></table></figure><p>然后执行这个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ts-node compile.ts</span></span><br></pre></td></tr></table></figure><p>执行上面的操作后，相当于使用项目的<code>tsconfig.json</code>配置文件来编译源代码，可以看到引入<code>ts-err-hunter</code>对源项目的编译过程影响并不大。</p><p>为了展示效果，假设我们有这么一个TS文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">"fs"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; register &#125; <span class="keyword">from</span> <span class="string">"ts-err-hunter"</span>;</span><br><span class="line"></span><br><span class="line">register();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// comments...</span></span><br><span class="line">  fs.readFileSync(<span class="string">"xxx.json"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    foo();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">const</span> sourceCode = <span class="keyword">await</span> err.getSourceCode();</span><br><span class="line">    <span class="keyword">if</span> (sourceCode) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`source file: <span class="subst">$&#123;sourceCode.fileName&#125;</span>`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(sourceCode.content);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>使用上面的方法编译并运行这些代码，我们将得到出错点的详细信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">source file: /absolute/path/to/TS/code.ts</span><br><span class="line">&gt;  6 const foo = () =&gt; &#123;</span><br><span class="line">&gt;  7   // comments...</span><br><span class="line">&gt;  8   fs.readFileSync(&quot;xxx.json&quot;);</span><br><span class="line">          ^ ------------&gt; ENOENT: no such file or directory, open &apos;xxx.json&apos;</span><br><span class="line"></span><br><span class="line">&gt;  9 &#125;</span><br></pre></td></tr></table></figure><p>这就是完整的过程和效果啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将给出一个在运行时获取TS函数完整原始代码并展示出错点的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://nullcc.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="typescript" scheme="https://nullcc.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>理解Scala类型系统中的型变</title>
    <link href="https://nullcc.github.io/2020/09/30/%E7%90%86%E8%A7%A3Scala%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%9E%8B%E5%8F%98/"/>
    <id>https://nullcc.github.io/2020/09/30/理解Scala类型系统中的型变/</id>
    <published>2020-09-29T16:00:00.000Z</published>
    <updated>2022-04-15T03:41:13.036Z</updated>
    
    <content type="html"><![CDATA[<p>本文深入解析了Scala类型系统中的三种型变：协变、逆变和不变。</p><a id="more"></a><p>Scala类型系统中的型变有三种形式：协变、逆变和不变。在深入理解型变之前，有必要回顾一下设计模式中的一个关键概念：里氏替换原则。</p><h2 id="型变的核心：里氏替换原则"><a href="#型变的核心：里氏替换原则" class="headerlink" title="型变的核心：里氏替换原则"></a>型变的核心：里氏替换原则</h2><p>里式替换原则有两个关键点：</p><ol><li>任何使用父类的地方都可以用它的子类替换而不会产生任何异常，但反过来则不行。</li><li>子类重载（注意不是重写）父类的方法的入参的限制要比父类的相应方法更宽松，但返回值要比父类更严格。</li></ol><p>第一点比较好理解，即<strong>父类知道的，子类都知道；子类知道的，父类未必知道</strong>，就不赘述了。</p><p>关于第二点，先来看一个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignalProcessor</span>[+<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(in: <span class="type">T</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(in)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码无法通过编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">covariant type T occurs in contravariant position in type T of value in</span><br><span class="line">  def process(in: T): Unit = &#123;</span><br><span class="line">              ^</span><br></pre></td></tr></table></figure><p>编译器给出的异常信息表明，SignalProcessor类的process方法的入参in是泛型类型T的逆变点，但我们给了一个协变的定义。初看这种报错基本上是一头雾水，要搞清楚根本原因我们需要具体分析一下这个SignalProcessor类。</p><p>有如下代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> anySignalProcessor = <span class="keyword">new</span> <span class="type">SignalProcessor</span>[<span class="type">AnyRef</span>]</span><br><span class="line"><span class="keyword">val</span> stringSignalProcessor = <span class="keyword">new</span> <span class="type">SignalProcessor</span>[<span class="type">String</span>]</span><br></pre></td></tr></table></figure><p>考察SignalProcessor[AnyRef]和ignalProcessor[String]的类型关系，无非两种情况：</p><ol><li>SignalProcessor[String]是SignalProcessor[AnyRef]的子类型。</li><li>SignalProcessor[AnyRef]是SignalProcessor[String]的子类型。</li></ol><p>第一种假设，根据里式替换原则，出现SignalProcessor[AnyRef]的地方都要可以用SignalProcessor[String]来替换：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> foo: <span class="type">Integer</span> = <span class="number">1</span></span><br><span class="line">anySignalProcessor.process(foo) <span class="comment">// OK</span></span><br><span class="line">stringSignalProcessor.process(foo) <span class="comment">// Oops! Type mismatch, expected: String, actual: Integer</span></span><br></pre></td></tr></table></figure><p>由于SignalProcessor[String]不能处理非String的入参，也就不能替换SignalProcessor[AnyRef]，假设一不成立。</p><p>第二种假设，根据里式替换原则，出现SignalProcessor[String]的地方都要可以用SignalProcessor[AnyRef]来替换：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bar: <span class="type">String</span> = <span class="string">"abc"</span></span><br><span class="line">stringSignalProcessor.process(bar) <span class="comment">// OK</span></span><br><span class="line">anySignalProcessor.process(bar) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>因此假设二是成立的。</p><p>所以，<strong>SignalProcessor[AnyRef]是SignalProcessor[String]的子类型</strong>，process方法在子类的入参<code>AnyRef</code>也确实比父类的入参<code>String</code>更宽松。此时刚才提到的式替换原则的第二个关键点的上半句：“子类重载（注意不是重写）父类的方法的入参的限制要比父类的相应方法更宽松”就很好理解了。</p><p>回到刚才那段编译报错的代码，应该改为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignalProcessor</span>[-<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(in: <span class="type">T</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(in)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上可见，泛型类的<strong>方法参数</strong>导致了泛型类型在子类和父类关系上发生了逆转。因此，<strong>方法参数的位置被称为逆变点(contravariant position)</strong>。也可以说<strong>泛型类在方法参数上是逆变的</strong>。</p><p>再来看下半句“子类方法的返回值要比父类更严格”，如果process方法返回一个值，这个值一般会被process方法的调用方消费，比如作为另一个方法的参数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignalProcessor</span>[-<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(): <span class="type">T</span> = &#123;</span><br><span class="line">    <span class="literal">null</span>.asInstanceOf[<span class="type">T</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码也会报错，但报错信息和之前稍有不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: contravariant type T occurs in covariant position in type (): T of method process</span><br><span class="line">  def process(): T = &#123;</span><br><span class="line">      ^</span><br></pre></td></tr></table></figure><p>意思是SignalProcessor类的process方法的出参是泛型类型T的协变点，但我们给了一个逆变的定义。</p><p>在这个例子中，对于泛型类在方法的泛型出参上的父子类型关系也无非两种情况：</p><ol><li>SignalProcessor[AnyRef]的process方法的返回值类型是SignalProcessor[String]的process方法的返回值类型的子类型。</li><li>SignalProcessor[String]的process方法的返回值类型是SignalProcessor[AnyRef]的process方法的返回值类型的子类型。</li></ol><p>为了使得之后使用process方法的返回值的调用符合里式替换原则，很显然SignalProcessor[String]的process方法的返回值必须得是SignalProcessor[AnyRef]的process方法的返回值的子类型。</p><p>SignalProcessor[String]的process的返回值在类型上确实需要比SignalProcessor[AnyRef]更严格。</p><p>由上可见，泛型类的<strong>方法返回值</strong>需要符合泛型类型的子类和父类的关系。因此，<strong>方法返回值的位置被称为协变点(covariant position)</strong>。也可以说，<strong>泛型类在方法返回值上是协变的</strong>。</p><p>因此上面这段代码应该改成：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignalProcessor</span>[+<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(): <span class="type">T</span> = &#123;</span><br><span class="line">    <span class="literal">null</span>.asInstanceOf[<span class="type">T</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>论证完里式替换原则的两个关键点，Scala的型变就非常好理解了。</p><h2 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h2><p>假设A是B的子类型，另有泛型类Foo[+T]，则Foo[A]是Foo[B]的子类型，这被称为协变。例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Material</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Liquid</span> <span class="keyword">extends</span> <span class="title">Material</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span>[+<span class="type">T</span>] (<span class="params">private val item: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(): <span class="type">T</span> = item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> liquidContainer = <span class="keyword">new</span> <span class="type">Container</span>[<span class="type">Liquid</span>](<span class="keyword">new</span> <span class="type">Liquid</span>)</span><br><span class="line"><span class="keyword">val</span> materialContainer: <span class="type">Container</span>[<span class="type">Material</span>] = liquidContainer <span class="comment">// OK</span></span><br><span class="line">println(materialContainer.get()) <span class="comment">// Main$$anon$1$Liquid@6035b93b</span></span><br></pre></td></tr></table></figure><p>在需要<code>Container[Material]</code>的地方可以用<code>Container[Liquid]</code>替换，反之则不行：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Material</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Liquid</span> <span class="keyword">extends</span> <span class="title">Material</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span>[+<span class="type">T</span>] (<span class="params">private val item: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(): <span class="type">T</span> = item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> materialContainer = <span class="keyword">new</span> <span class="type">Container</span>[<span class="type">Material</span>](<span class="keyword">new</span> <span class="type">Material</span>)</span><br><span class="line"><span class="keyword">val</span> liquidContainer: <span class="type">Container</span>[<span class="type">Liquid</span>] = materialContainer <span class="comment">// Oops!</span></span><br></pre></td></tr></table></figure><p>这段代码会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: type mismatch;</span><br><span class="line">found   : this.Container[this.Material]</span><br><span class="line">required: this.Container[this.Liquid]</span><br><span class="line">val liquidContainer: Container[Liquid] = materialContainer</span><br></pre></td></tr></table></figure><p>协变很好理解，液体(Liquid)是一种物质(Material)，因此液体容器(Container[Liquid])是一种物质容器(Container[Material])。根据里式替换原则，这里我可以把使用Container[Material]类型对象的地方替换成使用Container[Liquid]类型的对象，获取到的是Liquid，这是可以的，因为Liquid是一种Material。</p><h2 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h2><p>假设A是B的子类型，另有泛型类Foo[-T]，则Foo[B]是Foo[A]的子类型。例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hunter</span>[-<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hunt</span></span>(t: <span class="type">T</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"Caught "</span> + t)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> animalHunter = <span class="keyword">new</span> <span class="type">Hunter</span>[<span class="type">Animal</span>]</span><br><span class="line"><span class="keyword">val</span> bearHunter: <span class="type">Hunter</span>[<span class="type">Bear</span>] = animalHunter</span><br><span class="line">bearHunter.hunt(<span class="keyword">new</span> <span class="type">Bear</span>) <span class="comment">// Caught Main$$anon$1$Bear@aa549e5</span></span><br></pre></td></tr></table></figure><p>在需要<code>Hunter[Bear]</code>的地方可以用<code>Hunter[Animal]</code>替换，反之则不行：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hunter</span>[-<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hunt</span></span>(t: <span class="type">T</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"Caught "</span> + t)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> bearHunter = <span class="keyword">new</span> <span class="type">Hunter</span>[<span class="type">Bear</span>]</span><br><span class="line"><span class="keyword">val</span> animalHunter: <span class="type">Hunter</span>[<span class="type">Animal</span>] = bearHunter <span class="comment">// Oops!</span></span><br></pre></td></tr></table></figure><p>这段代码会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: type mismatch;</span><br><span class="line"> found   : this.Hunter[this.Bear]</span><br><span class="line"> required: this.Hunter[this.Animal]</span><br><span class="line">val animalHunter: Hunter[Animal] = bearHunter</span><br></pre></td></tr></table></figure><p>逆变理解起来不如协变直观。根据逆变的逻辑，在这段代码中，熊(Bear)是一种动物(Animal)，那么动物猎人(Hunter[Animal])是一种猎熊者(Hunter[Bear])。这个逻辑好像有点违反常识，不是应该说猎熊者(Hunter[Bear])是一种动物猎人(Hunter[Animal])吗？但是如果套用里氏替换原则中的概念：在需要基类的地方，都可以用子类替换，但反过来则不行。</p><p>逆变的道理也是一样的，在需要Hunter[Bear]的地方，我们用一个Hunter[Animal]去替代是可以的，因为动物猎人掌握狩猎一切动物的技能，这当然也包括猎熊。但是反过来，在需要Hunter[Animal]的地方，我们无法用Hunter[Bear]去替代，因为动物猎人是全能的，猎熊者只知道如何狩猎熊，如果换成麋鹿，Hunter[Bear]就不灵了。</p><p>根据这个逻辑，不难得出Hunter[Animal]应该是Hunter[Bear]的子类型。</p><h2 id="不变"><a href="#不变" class="headerlink" title="不变"></a>不变</h2><p>如果一个泛型类在类型参数上不加任何修饰，那这个泛型类在这个类型参数上就是不变的，比如Foo[T]。不变也是很有用的，这里引用Scala官方文档中的一个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name</span></span>: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Dog</span>(<span class="params">name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Container</span>[<span class="type">A</span>](<span class="params">value: <span class="type">A</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _value: <span class="type">A</span> = value</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getValue</span></span>: <span class="type">A</span> = _value</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setValue</span></span>(value: <span class="type">A</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    _value = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> catContainer: <span class="type">Container</span>[<span class="type">Cat</span>] = <span class="keyword">new</span> <span class="type">Container</span>(<span class="type">Cat</span>(<span class="string">"Felix"</span>))</span><br><span class="line"><span class="keyword">val</span> animalContainer: <span class="type">Container</span>[<span class="type">Animal</span>] = catContainer</span><br><span class="line">animalContainer.setValue(<span class="type">Dog</span>(<span class="string">"Spot"</span>))</span><br><span class="line"><span class="keyword">val</span> cat: <span class="type">Cat</span> = catContainer.getValue <span class="comment">// 糟糕，这里会将一只狗赋值给一只猫！</span></span><br></pre></td></tr></table></figure><p>还好这段代码无法通过编译，因为编译器会阻止我们这么做。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文深入解析了Scala类型系统中的三种型变：协变、逆变和不变。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="https://nullcc.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Scala" scheme="https://nullcc.github.io/tags/Scala/"/>
    
      <category term="类型系统" scheme="https://nullcc.github.io/tags/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="设计模式" scheme="https://nullcc.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>LL(1)语法解析器的一次简单实践</title>
    <link href="https://nullcc.github.io/2020/04/19/LL(1)%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E5%AE%9E%E8%B7%B5/"/>
    <id>https://nullcc.github.io/2020/04/19/LL(1)语法解析器的一次简单实践/</id>
    <published>2020-04-18T16:00:00.000Z</published>
    <updated>2022-04-15T03:41:13.014Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录LL(1)语法解析器的一次简单实践。</p><a id="more"></a><h2 id="需求概述"><a href="#需求概述" class="headerlink" title="需求概述"></a>需求概述</h2><p>前段时间和Team内部的同学进行了一次Coding Dojo，遇到一道题目，我个人觉得有点意思，就记录了一下自己的解题方式和心得。题目是<a href="http://codingdojo.org/kata/StringCalculator/" target="_blank" rel="noopener">StringCalculator</a>。</p><p>这道题目一共有7个小需求，题目需求这里就不详细说明了，可以参考上面的链接。本文主要给出实现。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这个题目实际上可以用LL(1)语法解析器来处理。这里先给出完整的语法解析器实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lexer.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> LexerOptions &#123;</span><br><span class="line">  collectAllErrors?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Lexer &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> EOF = <span class="string">'&lt;EOF&gt;'</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> TYPE_EOF = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> TYPE_NUMBER: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> TYPE_DELIMITER: <span class="built_in">number</span> = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> TYPE_NEW_LINE: <span class="built_in">number</span> = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> tokenNames: <span class="built_in">string</span>[] = [ <span class="string">'&lt;EOF&gt;'</span>, <span class="string">'NUMBER'</span>, <span class="string">'TYPE_DELIMITER'</span>, <span class="string">'NEW_LINE'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> options: LexerOptions;</span><br><span class="line">  <span class="keyword">private</span> input: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> c: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> i: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> delimiter = <span class="string">','</span>;</span><br><span class="line">  <span class="keyword">private</span> _errors: <span class="built_in">string</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">input: <span class="built_in">string</span>, options?: LexerOptions</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.options = options || &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.input = input;</span><br><span class="line">    <span class="keyword">this</span>.i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.checkDelimiter();</span><br><span class="line">    <span class="keyword">this</span>.c = <span class="keyword">this</span>.input[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> nextToken(): Token &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.c != Lexer.EOF) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">this</span>.c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">this</span>.delimiter[<span class="number">0</span>]: &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.delimiter.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.expect(<span class="keyword">this</span>.delimiter[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.consume();</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.expectNumber()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Token(Lexer.TYPE_DELIMITER, <span class="keyword">this</span>.delimiter);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.collectError(<span class="string">`Number expected but '<span class="subst">$&#123;<span class="keyword">this</span>.getC()&#125;</span>' found at position <span class="subst">$&#123;<span class="keyword">this</span>.i&#125;</span>.`</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\n'</span>: &#123;</span><br><span class="line">          <span class="keyword">this</span>.consume();</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.expectNumber()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Token(Lexer.TYPE_DELIMITER, <span class="string">'\n'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.collectError(<span class="string">`Number expected but '<span class="subst">$&#123;<span class="keyword">this</span>.getC()&#125;</span>' found at position <span class="subst">$&#123;<span class="keyword">this</span>.i&#125;</span>.`</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.isNumber()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.readNumber();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.i &lt; <span class="keyword">this</span>.input.length - <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>.c !== <span class="keyword">this</span>.delimiter[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.collectError(<span class="string">`'<span class="subst">$&#123;<span class="keyword">this</span>.delimiter[<span class="number">0</span>]&#125;</span>' expected but '<span class="subst">$&#123;<span class="keyword">this</span>.input[<span class="keyword">this</span>.i]&#125;</span>' found at position <span class="subst">$&#123;<span class="keyword">this</span>.i&#125;</span>.`</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.consume();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Token(Lexer.TYPE_EOF, Lexer.EOF);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> errors(): <span class="built_in">string</span>[] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._errors;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> checkDelimiter(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> regex = <span class="regexp">/\/\/(.+?)\n(.+)?/</span>;</span><br><span class="line">    <span class="keyword">const</span> res = regex.exec(<span class="keyword">this</span>.input);</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">      <span class="keyword">this</span>.delimiter = res[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">this</span>.input = res[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> isNumber(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.c === <span class="string">'-'</span> || <span class="keyword">this</span>.c === <span class="string">'.'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(<span class="keyword">this</span>.c));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> consume(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.i += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.i &gt; <span class="keyword">this</span>.input.length) &#123;</span><br><span class="line">      <span class="keyword">this</span>.c = Lexer.EOF;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.c = <span class="keyword">this</span>.input[<span class="keyword">this</span>.i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> readNumber() &#123;</span><br><span class="line">    <span class="keyword">let</span> numberStr = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      numberStr += <span class="keyword">this</span>.c;</span><br><span class="line">      <span class="keyword">this</span>.consume();</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="keyword">this</span>.isNumber());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Token(Lexer.TYPE_NUMBER, <span class="built_in">parseFloat</span>(numberStr));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> expectNumber(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/\d/</span>.test(<span class="keyword">this</span>.c) || <span class="keyword">this</span>.c === <span class="string">'-'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> expect(c: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.consume();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.c !== c) &#123;</span><br><span class="line">      <span class="keyword">this</span>.collectError(<span class="string">`<span class="subst">$&#123;c&#125;</span> expected but '<span class="subst">$&#123;<span class="keyword">this</span>.getC()&#125;</span>' found at position <span class="subst">$&#123;<span class="keyword">this</span>.i&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> getC(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.i &lt; <span class="keyword">this</span>.input.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;EOF&gt;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> collectError(errMsg: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.options.collectAllErrors) &#123;</span><br><span class="line">      <span class="keyword">this</span>._errors.push(errMsg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Token &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">type</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">public</span> value: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params"><span class="keyword">type</span>: <span class="built_in">number</span>, value: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="keyword">type</span>;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> getTokenName(x: <span class="built_in">number</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Lexer.tokenNames[x];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了语法解析器以后，剩下的事情就很简单了。这里也不需要parser，只需要实现一个StringCalculator类即可：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Lexer, LexerOptions &#125; <span class="keyword">from</span> <span class="string">'./lexer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> StringCalculator &#123;</span><br><span class="line">  <span class="keyword">private</span> options: LexerOptions;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span> (<span class="params">options?: LexerOptions</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.options = options || &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> add(input: <span class="built_in">string</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tokens = [];</span><br><span class="line">    <span class="keyword">const</span> lexer = <span class="keyword">new</span> Lexer(input, <span class="keyword">this</span>.options);</span><br><span class="line">    <span class="keyword">let</span> token = lexer.nextToken();</span><br><span class="line">    <span class="keyword">while</span> (token.type !== Lexer.TYPE_EOF) &#123;</span><br><span class="line">      tokens.push(token);</span><br><span class="line">      token = lexer.nextToken();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> errors: <span class="built_in">string</span>[] = [];</span><br><span class="line">    errors = errors.concat(lexer.errors);</span><br><span class="line">    <span class="keyword">const</span> negativeNumberTokens = tokens.filter(<span class="function"><span class="params">token</span> =&gt;</span> token.value &lt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (negativeNumberTokens.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> negativeNumbers = negativeNumberTokens.map(<span class="function"><span class="params">token</span> =&gt;</span> token.value);</span><br><span class="line">      errors = errors.concat(<span class="string">`Negative not allowed: <span class="subst">$&#123;negativeNumbers.join(<span class="string">', '</span>)&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errors.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(errors.join(<span class="string">'\n'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> token of tokens) &#123;</span><br><span class="line">      <span class="keyword">if</span> (token.type === Lexer.TYPE_NUMBER) &#123;</span><br><span class="line">        res += &lt;<span class="built_in">number</span>&gt; token.value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string-calculator.test.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; StringCalculator &#125; <span class="keyword">from</span> <span class="string">'../src/calculator'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Test string calculator.'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  test(<span class="string">'Test case 0.'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">const</span> stringCalculator = <span class="keyword">new</span> StringCalculator();</span><br><span class="line">    <span class="keyword">const</span> res = stringCalculator.add(input);</span><br><span class="line">    expect(res).toEqual(<span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'Test case 1.'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">const</span> stringCalculator = <span class="keyword">new</span> StringCalculator();</span><br><span class="line">    <span class="keyword">const</span> res = stringCalculator.add(input);</span><br><span class="line">    expect(res).toEqual(<span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'Test case 2.'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="string">'1,2,3,10'</span>;</span><br><span class="line">    <span class="keyword">const</span> stringCalculator = <span class="keyword">new</span> StringCalculator();</span><br><span class="line">    <span class="keyword">const</span> res = stringCalculator.add(input);</span><br><span class="line">    expect(res).toEqual(<span class="number">16</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'Test case 3.'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="string">'1,2.5,3'</span>;</span><br><span class="line">    <span class="keyword">const</span> stringCalculator = <span class="keyword">new</span> StringCalculator();</span><br><span class="line">    <span class="keyword">const</span> res = stringCalculator.add(input);</span><br><span class="line">    expect(res).toEqual(<span class="number">6.5</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'Test case 4.'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="string">'1\n2,3,10'</span>;</span><br><span class="line">    <span class="keyword">const</span> stringCalculator = <span class="keyword">new</span> StringCalculator();</span><br><span class="line">    <span class="keyword">const</span> res = stringCalculator.add(input);</span><br><span class="line">    expect(res).toEqual(<span class="number">16</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'Test case 5.'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="string">'1\n2,3,10'</span>;</span><br><span class="line">    <span class="keyword">const</span> stringCalculator = <span class="keyword">new</span> StringCalculator();</span><br><span class="line">    <span class="keyword">const</span> res = stringCalculator.add(input);</span><br><span class="line">    expect(res).toEqual(<span class="number">16</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'Test case 6.'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> input = <span class="string">'1\n,2,3,10'</span>;</span><br><span class="line">      <span class="keyword">const</span> stringCalculator = <span class="keyword">new</span> StringCalculator();</span><br><span class="line">      <span class="keyword">const</span> res = stringCalculator.add(input);</span><br><span class="line">      expect(<span class="literal">true</span>).toBe(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      expect(e.message).toBe(<span class="string">"Number expected but ',' found at position 2."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'Test case 7.'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> input = <span class="string">'1,2,3,10,'</span>;</span><br><span class="line">      <span class="keyword">const</span> stringCalculator = <span class="keyword">new</span> StringCalculator();</span><br><span class="line">      <span class="keyword">const</span> res = stringCalculator.add(input);</span><br><span class="line">      expect(<span class="literal">true</span>).toBe(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      expect(e.message).toBe(<span class="string">"Number expected but '&lt;EOF&gt;' found at position 9."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'Test case 8.'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="string">'//;\n1;2'</span>;</span><br><span class="line">    <span class="keyword">const</span> stringCalculator = <span class="keyword">new</span> StringCalculator();</span><br><span class="line">    <span class="keyword">const</span> res = stringCalculator.add(input);</span><br><span class="line">    expect(res).toEqual(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'Test case 9.'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="string">'//|\n1|2|3'</span>;</span><br><span class="line">    <span class="keyword">const</span> stringCalculator = <span class="keyword">new</span> StringCalculator();</span><br><span class="line">    <span class="keyword">const</span> res = stringCalculator.add(input);</span><br><span class="line">    expect(res).toEqual(<span class="number">6</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'Test case 10.'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="string">'//sep\n2sep3'</span>;</span><br><span class="line">    <span class="keyword">const</span> stringCalculator = <span class="keyword">new</span> StringCalculator();</span><br><span class="line">    <span class="keyword">const</span> res = stringCalculator.add(input);</span><br><span class="line">    expect(res).toEqual(<span class="number">5</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'Test case 11.'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> input = <span class="string">'//|\n1|2,3'</span>;</span><br><span class="line">      <span class="keyword">const</span> stringCalculator = <span class="keyword">new</span> StringCalculator();</span><br><span class="line">      <span class="keyword">const</span> res = stringCalculator.add(input);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      expect(e.message).toBe(<span class="string">"'|' expected but ',' found at position 3."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'Test case 12.'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> input = <span class="string">'-1,2'</span>;</span><br><span class="line">      <span class="keyword">const</span> stringCalculator = <span class="keyword">new</span> StringCalculator();</span><br><span class="line">      <span class="keyword">const</span> res = stringCalculator.add(input);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      expect(e.message).toBe(<span class="string">"Negative not allowed: -1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'Test case 13.'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> input = <span class="string">'2,-4,-5'</span>;</span><br><span class="line">      <span class="keyword">const</span> stringCalculator = <span class="keyword">new</span> StringCalculator();</span><br><span class="line">      <span class="keyword">const</span> res = stringCalculator.add(input);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      expect(e.message).toBe(<span class="string">"Negative not allowed: -4, -5"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'Test case 14.'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> input = <span class="string">'-1,,2'</span>;</span><br><span class="line">      <span class="keyword">const</span> stringCalculator = <span class="keyword">new</span> StringCalculator(&#123; collectAllErrors: <span class="literal">true</span> &#125;);</span><br><span class="line">      <span class="keyword">const</span> res = stringCalculator.add(input);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      expect(e.message).toBe(<span class="string">"Number expected but ',' found at position 3.\nNegative not allowed: -1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Coding Dojo过程中我发现这题的很多的实现都是先用<code>split</code>之类的方法去解开整个输入字符串，然后收集到一个数字数组后再去求和。这样做不能说不行，但是随着本题的需求越来越多，这种实现方式的弊端会慢慢显现出来，代码越来越复杂，而且很难修改。如果利用LL(1)语法解析器，其解析精度会比较高，而且一系列需求做下来实际上是对它的渐进式增强。在实际解题的过程中我发现对于每个新需求，使用LL(1)语法解析器的方案需要做的修改和重构量都很小，而且比较不容易出错。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录LL(1)语法解析器的一次简单实践。&lt;/p&gt;
    
    </summary>
    
      <category term="语言应用" scheme="https://nullcc.github.io/categories/%E8%AF%AD%E8%A8%80%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="语法解析器" scheme="https://nullcc.github.io/tags/%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>利用OpenResty做代理实现到STF的请求转发和自定义权限校验</title>
    <link href="https://nullcc.github.io/2020/02/28/%E5%88%A9%E7%94%A8OpenResty%E5%81%9A%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%88%B0STF%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C/"/>
    <id>https://nullcc.github.io/2020/02/28/利用OpenResty做代理实现到STF的请求转发和自定义权限校验/</id>
    <published>2020-02-27T16:00:00.000Z</published>
    <updated>2022-04-15T03:41:13.030Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍一种在两个独立系统之间搭建中间层来做请求转发和权限校验的方案。</p><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在详细介绍架构设计之前必须先陈述一下需求。这是在我现实工作场景中遇到的事情，在我们团队中，需要对app做自动化测试。我们有大约50台真机(iOS + Android)，这些设备分布在很多台主机上。每天我们都需要在这些真机（还有模拟器，但模拟器在这里不是重点）上执行很多测试用例。于是之前我们设计了一个系统（代号device-spy）来主动扫描分布在这些主机上的所有设备的信息，并以一定的策略对外提供服务。客户端通过调用API来向device-spy申请符合某种条件的设备并锁定它，然后直接使用这个设备执行测试用例。当测试用例执行完毕，客户端调用device-spy的API将设备解除占用。当测试运行时，appium会对每一个会话生成session，device-spy系统采用定时轮询的方式检测每个设备对应的session的存在性。如果session消失，device-spy将主动将设备解除占用。另外，客户端崩溃也会导致appium session消失，进而device-spy就会检测到并将相应设备解除占用。我们就是用这种方式来管理这些设备，关于device-spy的情况就先介绍这么多。</p><p>最近，我们团队希望使用STF来实现Android手机设备的远程控制，STF是针对Android设备远程控制的一套比较成熟的开源方案。我们想对device-spy和STF做一个集成，只有在device-spy上申请对某个Android的远程控制后（这会锁住设备使它无法被其他人或者测试脚本使用），才能在STF上真正地去远程控制。任何试图直接在STF上实行远程控制的操作都将被禁止。这个需求的主要目的是不想让用户在STF上对Android设备的操作影响到自动化测试脚本的执行。</p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>在了解了需求后，可以发现这里有两个完全独立的系统：device-spy和STF，我们的目标实际上是要针对这两个系统设计一套鉴权和请求转发方案。从设计方案的最开始，我们需要明确几条原则：</p><ol><li>不对STF的代码做任何改动。</li><li>对device-spy只能做尽量少的改动，最好是只增加新功能不修改现有功能。</li><li>设计要尽量简单可靠。</li></ol><p>计算机科学领域有一句名言：“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决”。</p><p>这个需求也完全可以靠增加一个中间层来解决。既然要求不修改STF，还能达到控制对它API的访问的要求。很直接地可以想到在STF前面加一层反向代理来负责转发所有到STF的请求（HTTP和Websocket）。还可以在这个中间层上做一些鉴权的逻辑用来控制用户浏览器对STF的访问。</p><p>思路很明确，理论上完全可行。剩下的就是技术选型和架构设计。</p><p>技术选型方面，一般来说Web后端做反向代理的组件最常用的就是nginx了。nginx性能强悍且有很好的可扩展性，比如可以使用ngx_lua_module做扩展，允许用户在请求的生命周期的不同阶段实现自己的逻辑。OpenResty又是这方面很好的一个技术方案，于是我把目光投向OpenResty。</p><p>OpenResty是基于nginx和Lua的高性能Web平台，开发者可以在OpenResty的请求处理流程的各个阶段中设置自己的逻辑。下面是OpenResty处理请求流程图：</p><p><img src="/assets/images/post_imgs/openresty_phases.png" alt="OpenResty处理请求的流程图"></p><p>可以不必深究这张图的所有细节，目前重点只需要关注”access_by_lua”和”content_by_lua”两个阶段。在access_by_lua阶段，我们还没有开始处理任何实际的业务逻辑，一般在这个阶段都是处理一些和权限有关的事情，因此这里可以设置鉴权逻辑，当鉴权成功就转发请求到upstream的STF服务，失败则返回一个403 Forbidden。content_by_lua阶段一般用来放置一些实际的操作，我们可以设计一些API用来实现设备注册、用户浏览器授权和设备注销。device-spy将会直接和这些API做集成来为鉴权逻辑做准备。</p><p>至此，思路我们已经准备好了。</p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p>思路有了，还需要设计详细架构才能开始编码。这个中间层系统我把他命名为<code>midway</code>。下图有助于清晰地理解整个流程：</p><p><img src="/assets/images/post_imgs/midway_architecture.png" alt="midway架构设计"></p><p>详细解释一下各个步骤的行为：</p><ol><li>用户在device-spy上申请对某台安卓机器的控制，并指定timeout。</li><li>device-spy锁定这台设备，并生成一个code（为了安全性这个code是有需要加密的，在midway端会解密，防止伪造，但简单起见可以先不实现）。</li><li>device-spy向midway注册设备（携带参数code, timeout，device_ip和adb_port）。</li><li>midway用uuid生成一个session key，并在redis里创建(string)code:session，(string)device:session和(hash)session:{ permission, device }，这三个key-value pairs都设置timeout过期时间。</li><li>device-spy重定向浏览器到midway的<code>/auth?code=xxx</code>上。</li><li>midway验证这个code，如果这个code已经注册，就把对应的session key作为cookie设置在浏览器端。</li><li>(7-10) midway会反向代理所有到STF的HTTP和Websocket请求。特别地，只有当浏览器访问STF的<code>/api/v1/devices/{device_ip}</code>:{adb_port}这个API时，midway才会做权限校验，看看用户session是否有权限操作这台设备，如果不可以就返回403，验证通过则直接proxy_pass到STF，最后返回响应。只对这个API做权限校验就可以了，因为这个远程操控制某台设备之前必须请求该API获取相关信息后建立websocket连接。</li><li>(11) 用户在device-spy上主动注销设备，device-spy会请求midway的注销设备API。</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在实现阶段，我们需要依照上面的架构设计打通所有节点之间的连接，形成功能闭环。由于device-spy上的实现无非就是增加几个API调用不难理解，所以这里我将只讨论midway的详细实现。</p><p>OpenResty是基于nginx的，所以一个nginx.conf是少不了的。nginx.conf这个文件非常重要，它描述了我们的所有请求将如何被nginx处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log logs/error.log;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># declare environment variables</span><br><span class="line">env STF_IP;</span><br><span class="line">env STF_SSH_USER;</span><br><span class="line">env STF_SSH_PASSWORD;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    map $http_upgrade $connection_upgrade &#123;</span><br><span class="line">        default upgrade;</span><br><span class="line">        &apos;&apos;      close;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # lua packages</span><br><span class="line">    lua_package_path   &quot;lualib/?.lua;/usr/local/openresty/nginx/lualib/?.lua;;&quot;;</span><br><span class="line">    lua_package_cpath  &quot;lualib/?.so;/usr/local/openresty/nginx/lualib/?.so;;&quot;;</span><br><span class="line">    init_by_lua_file   &quot;lua/init.lua&quot;;</span><br><span class="line"></span><br><span class="line">    upstream stf_app &#123;</span><br><span class="line">        server $&#123;STF_IP&#125;:21000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    upstream stf_websocket &#123;</span><br><span class="line">        server $&#123;STF_IP&#125;:7110;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_worker_by_lua_block &#123;</span><br><span class="line">        local uuid = require &quot;resty.jit-uuid&quot;</span><br><span class="line">        uuid.seed()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # STF app</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 21000;</span><br><span class="line">        server_name $&#123;SERVER_NAME&#125;;</span><br><span class="line">        resolver 127.0.0.11;</span><br><span class="line"></span><br><span class="line">        # device-spy requests this API to register device with:</span><br><span class="line">        # 1. code</span><br><span class="line">        # 2. timeout (unit: second)</span><br><span class="line">        # 3. device (ip:adb_port)</span><br><span class="line">        # </span><br><span class="line">        # Sample:</span><br><span class="line">        #   method: POST</span><br><span class="line">        #   content-type: application/json</span><br><span class="line">        #   data: &#123;</span><br><span class="line">        #       &quot;code&quot;: &quot;xyz&quot;,</span><br><span class="line">        #       &quot;timeout&quot;: 3600,</span><br><span class="line">        #       &quot;device&quot;: &quot;$&#123;DEVICE_IP&#125;:7500&quot;</span><br><span class="line">        #   &#125;</span><br><span class="line">        location /register-device &#123;</span><br><span class="line">            proxy_ssl_name $host;</span><br><span class="line">            lua_code_cache on;</span><br><span class="line">            content_by_lua_file  &quot;lua/register.lua&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # device-spy requests this API to deregister device:</span><br><span class="line">        # Sample:</span><br><span class="line">        #   method: POST</span><br><span class="line">        #   content-type: application/json</span><br><span class="line">        #   data: &#123;</span><br><span class="line">        #       &quot;device&quot;: &quot;$&#123;DEVICE_IP&#125;:7500&quot;</span><br><span class="line">        #   &#125;</span><br><span class="line">        location /deregister-device &#123;</span><br><span class="line">            proxy_ssl_name $host;</span><br><span class="line">            lua_code_cache on;</span><br><span class="line">            content_by_lua_file  &quot;lua/deregister.lua&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # Client requests this API to authenticate with code in query string, e.g. /auth?code=xxx</span><br><span class="line">        # OpenResty will set cookie in client if success</span><br><span class="line">        location ~ ^/auth$ &#123;</span><br><span class="line">            proxy_ssl_name $host;</span><br><span class="line">            lua_code_cache on;</span><br><span class="line">            content_by_lua_file  &quot;lua/auth.lua&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # OpenResty verifies permission before proxying this request to STF app</span><br><span class="line">        location ~ ^/api/v1/devices/(.+)$ &#123;</span><br><span class="line">            access_by_lua_file &quot;lua/access.lua&quot;; # verify permission by lua script</span><br><span class="line">            proxy_pass http://stf_app;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # OpenResty injects JS code to STF index page to redirect browser to &apos;/&apos; after timeout</span><br><span class="line">        location ~ ^/$ &#123;</span><br><span class="line">            proxy_ssl_name $host;</span><br><span class="line">            lua_code_cache on;</span><br><span class="line">            content_by_lua_file &quot;lua/index.lua&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # Other http requests will be proxied to STF directly</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://stf_app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # STF websocket</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 7110;</span><br><span class="line">        server_name $&#123;SERVER_NAME&#125;;</span><br><span class="line">        resolver 127.0.0.11;</span><br><span class="line"></span><br><span class="line">        # STF websocket requests will be proxied to STF websocket service directly</span><br><span class="line">        location /socket.io/ &#123;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line"></span><br><span class="line">            proxy_pass http://stf_websocket;</span><br><span class="line"></span><br><span class="line">            # enable WebSockets</span><br><span class="line">            proxy_http_version 1.1;</span><br><span class="line">            proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">            proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # STF websocket providers (ports 7400-7499)</span><br><span class="line">    server &#123;</span><br><span class="line">        # can use &quot;listen 7400-7499;&quot; when OpenResty be upgraded to nginx 1.15.10 later</span><br><span class="line">        listen 7400;</span><br><span class="line">        listen 7401;</span><br><span class="line">        listen 7402;</span><br><span class="line">        listen 7403;</span><br><span class="line">        listen 7404;</span><br><span class="line">        listen 7405;</span><br><span class="line">        listen 7406;</span><br><span class="line">        listen 7407;</span><br><span class="line">        listen 7408;</span><br><span class="line">        listen 7409;</span><br><span class="line">        listen 7410;</span><br><span class="line">        listen 7411;</span><br><span class="line">        listen 7412;</span><br><span class="line">        listen 7413;</span><br><span class="line">        listen 7414;</span><br><span class="line">        listen 7415;</span><br><span class="line">        listen 7416;</span><br><span class="line">        listen 7417;</span><br><span class="line">        listen 7418;</span><br><span class="line">        listen 7419;</span><br><span class="line">        listen 7420;</span><br><span class="line">        listen 7421;</span><br><span class="line">        listen 7422;</span><br><span class="line">        listen 7423;</span><br><span class="line">        listen 7424;</span><br><span class="line">        listen 7425;</span><br><span class="line">        listen 7426;</span><br><span class="line">        listen 7427;</span><br><span class="line">        listen 7428;</span><br><span class="line">        listen 7429;</span><br><span class="line">        listen 7430;</span><br><span class="line">        listen 7431;</span><br><span class="line">        listen 7432;</span><br><span class="line">        listen 7433;</span><br><span class="line">        listen 7434;</span><br><span class="line">        listen 7435;</span><br><span class="line">        listen 7436;</span><br><span class="line">        listen 7437;</span><br><span class="line">        listen 7438;</span><br><span class="line">        listen 7439;</span><br><span class="line">        listen 7440;</span><br><span class="line">        listen 7441;</span><br><span class="line">        listen 7442;</span><br><span class="line">        listen 7443;</span><br><span class="line">        listen 7444;</span><br><span class="line">        listen 7445;</span><br><span class="line">        listen 7446;</span><br><span class="line">        listen 7447;</span><br><span class="line">        listen 7448;</span><br><span class="line">        listen 7449;</span><br><span class="line">        listen 7450;</span><br><span class="line">        listen 7451;</span><br><span class="line">        listen 7452;</span><br><span class="line">        listen 7453;</span><br><span class="line">        listen 7454;</span><br><span class="line">        listen 7455;</span><br><span class="line">        listen 7456;</span><br><span class="line">        listen 7457;</span><br><span class="line">        listen 7458;</span><br><span class="line">        listen 7459;</span><br><span class="line">        listen 7460;</span><br><span class="line">        listen 7461;</span><br><span class="line">        listen 7462;</span><br><span class="line">        listen 7463;</span><br><span class="line">        listen 7464;</span><br><span class="line">        listen 7465;</span><br><span class="line">        listen 7466;</span><br><span class="line">        listen 7467;</span><br><span class="line">        listen 7468;</span><br><span class="line">        listen 7469;</span><br><span class="line">        listen 7470;</span><br><span class="line">        listen 7471;</span><br><span class="line">        listen 7472;</span><br><span class="line">        listen 7473;</span><br><span class="line">        listen 7474;</span><br><span class="line">        listen 7475;</span><br><span class="line">        listen 7476;</span><br><span class="line">        listen 7477;</span><br><span class="line">        listen 7478;</span><br><span class="line">        listen 7479;</span><br><span class="line">        listen 7480;</span><br><span class="line">        listen 7481;</span><br><span class="line">        listen 7482;</span><br><span class="line">        listen 7483;</span><br><span class="line">        listen 7484;</span><br><span class="line">        listen 7485;</span><br><span class="line">        listen 7486;</span><br><span class="line">        listen 7487;</span><br><span class="line">        listen 7488;</span><br><span class="line">        listen 7489;</span><br><span class="line">        listen 7490;</span><br><span class="line">        listen 7491;</span><br><span class="line">        listen 7492;</span><br><span class="line">        listen 7493;</span><br><span class="line">        listen 7494;</span><br><span class="line">        listen 7495;</span><br><span class="line">        listen 7496;</span><br><span class="line">        listen 7497;</span><br><span class="line">        listen 7498;</span><br><span class="line">        listen 7499;</span><br><span class="line">        server_name $&#123;SERVER_NAME&#125;;</span><br><span class="line">        resolver 127.0.0.11;</span><br><span class="line"></span><br><span class="line">        # Requests to STF providers will be proxied to STF providers directly</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line"></span><br><span class="line">            proxy_pass http://$&#123;STF_IP&#125;:$server_port;</span><br><span class="line"></span><br><span class="line">            # enable WebSockets</span><br><span class="line">            proxy_http_version 1.1;</span><br><span class="line">            proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">            proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，需要把这个文件中的<code>${STF_IP}</code>和<code>${SERVER_NAME}</code>换成实际的STF的IP和实际server的IP，这里做展示用因此隐藏了这个IP。</p><p>这个nginx.conf内容比较多，我们从上往下看。</p><ol><li>10-12行声明了三个环境变量，环境变量需要在docker-compose.yml中事先声明好。需要说明的是，我在STF的启动命令里使用了<code>--allow-remote</code>，以允许用Wi-Fi远程控制设备。所以每次控制设备之前需要手动在STF所在服务器上调用<code>adb connect {device_ip}:{adb_port}</code>来确保STF服务器和设备处于已连接状态。这三个环境变量将在Lua脚本中被使用，之后会提到。</li><li>15-18行是用来将HTTP 1.1升级成Websocket协议的。</li><li>21-23行声明了Lua package的查找路径。<code>*.lua</code>表示文本格式的Lua脚本文件，<code>*.so</code>表示的是C动态链接库。</li><li>25-32行声明了STF的一些服务作为upstream，<code>stf_app</code>是给HTTP API用的，<code>stf_websocket</code>是给Websocket用的。</li><li>33-36行是Lua的一个第三方库<code>jit-uuid</code>要求的声明，初始化uuid seed。</li><li>39行开始是STF App部分的声明块，声明了<code>/register-device</code>, <code>/deregister-device</code>, <code>/auth</code>, <code>/api/v1/devices/(.+)</code>和所有其他HTTP API的处理方式。在<code>/register-device</code>, <code>/deregister-device</code>和<code>/auth</code>的声明中，<code>content_by_lua_file</code>后的Lua脚本会负责处理这个API的行为。对<code>/api/v1/devices/(.+)</code>，会先用<code>access_by_lua_file</code>指定的Lua脚本检查用户是否有权限请求这个STF API，然后根据检查结果，若是验证通过就转发至STF，否则返回权限不足。其余所有HTTP请求都直接转发至STF。</li><li>104-121行是STF Websocket部分的声明块，指定了当API为<code>/socket.io/</code>时，应该将HTTP 1.1升级到Websocket，并直接转发Websocket请求到STF Websocket service。</li><li>124-241行中有一长串的listen声明，这主要是因为在远程控制Android设备时，STF会启动provider来提供Websocket服务（注意和刚才题到的STF Websocket service相区别），可以在STF启动命令中使用<code>--provider-min-port {port}</code>和<code>--provider-max-port {port}</code>来指定，这里我的参数是<code>--provider-min-port 7400 --provider-max-port 7499</code>，所以就需要有100个listen声明。值得一提的是，nginx在1.15.10中可以在listen中使用一个端口范围，详情参见<a href="http://nginx.org/en/docs/stream/ngx_stream_core_module.html#listen" target="_blank" rel="noopener">nginx listen</a>。不过当前最新的OpenResty基于的Nginx版本是1.15.8，所以不支持。之后如果OpenResty更新后，可以直接使用<code>listen 7400-7499;</code>这种更简洁的方式。对于provider，所有请求都应该被直接转发。</li></ol><p>完成nginx.conf后，就轮到设计各个Lua脚本文件了。这里不打算给出所有Lua脚本的详细代码，只说大致做法。</p><h3 id="设备注册"><a href="#设备注册" class="headerlink" title="设备注册"></a>设备注册</h3><p>midway的<code>/register-device</code>API的行为（参数code、 timeout和device）：</p><ol><li>在Redis中创建一个string，key: code, value: session，并设置过期时间为timeout。</li><li>在Redis中创建一个string，key: device, value: session，并设置过期时间为timeout。</li><li>在Redis中创建一个hash，key: session, value: { permission, device }，并设置过期时间为timeout。</li><li>SSH到STF的服务器上（会使用nginx.conf文件中声明的那三个环境变量），然后执行<code>adb connect {device_ip}:{adb_port}</code>。</li></ol><h3 id="用户浏览器授权"><a href="#用户浏览器授权" class="headerlink" title="用户浏览器授权"></a>用户浏览器授权</h3><p>midway的<code>/auth?code=xxx</code>API的行为：</p><ol><li>在Redis中以code为key获取session。</li><li>如果能获取到，就移除key: code。然后设置浏览器的Cookie：”midwaysid={session}; Max-Age={timeout}; path=/“。最后重定向浏览器到midway的根路径下（对应STF的首页）。</li><li>如果获取不到session，返回400 Invalid code。</li></ol><h3 id="设备注销"><a href="#设备注销" class="headerlink" title="设备注销"></a>设备注销</h3><p>midway的<code>/deregister-device</code>API的行为（参数device）：</p><ol><li>在Redis中移除key: device。</li></ol><h3 id="设备信息获取"><a href="#设备信息获取" class="headerlink" title="设备信息获取"></a>设备信息获取</h3><p>midway的<code>/api/v1/devices/(.+)</code>API的行为：</p><ol><li>使用device做为key在Redis中查询它所对用的session。</li><li>将浏览器Cookie中的key为midwaysid的value和第一步查到的session对比，二者相等则认为验证通过，并直接转发请求到STF。</li><li>第二步中验证不通过将会导致返回403 Permission denied。</li></ol><p>下面这个块是针对一个特殊的行为的，下面会详细说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># OpenResty injects JS code to STF index page to redirect browser to &apos;/&apos; after timeout</span><br><span class="line">location ~ ^/$ &#123;</span><br><span class="line">    proxy_ssl_name $host;</span><br><span class="line">    lua_code_cache on;</span><br><span class="line">    content_by_lua_file &quot;lua/index.lua&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="确保用户在session-timeout后被强制退出控制页面"><a href="#确保用户在session-timeout后被强制退出控制页面" class="headerlink" title="确保用户在session timeout后被强制退出控制页面"></a>确保用户在session timeout后被强制退出控制页面</h2><p>在实现了上述的所有细节后，实际使用时我发现一个问题。当用户进入到STF的设备远程控制页面后，之后的大部分操作都不再需要请求设备信息获取接口了，只需要Websocket连接就够了。由于目前我们只针对设备信息获取的API做了鉴权，假如用户一直停留在某个设备的远程控制页面不出来，就算timeout过了，还是可以继续使用的。</p><p>由于STF是一个单页Web应用，针对这个问题，我想到的最简单的方案是在用户浏览器初次请求STF首页的时候，在其中注入一段特定的JS代码。这段代码是由midway生成并插入到STF的首页响应文本中的。当然，如果session不存在或者为空，则不需要注入JS代码。这段JS代码大致是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'Remote control timeout!'</span>);location.href = <span class="string">'/'</span>;&#125;, $&#123;session-ttl&#125;)&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p><code>${session-ttl}</code>是session在Redis中的TTL，midway会负责填入这个值，这个TTL将随着用户刷新页面的时间的不同而不同。这段代码的主要目的是在TTL时间后，弹框提示用户之前为申请远程设备控制的timeout已经到了，并强制跳转到<code>/</code>。这样就把用户带离了设备控制页面，由于此时session已过期，用户就无法再次直接进入到STF的设备控制页面了。如果想要继续控制设备，就必须去device-spy再做一次申请。</p><p>我把对这个行为的控制放到<code>lua/index.lua</code>中。</p><p>还有一个地方值得说一下，STF默认缓存了首页文档，在初次请求后直到页面缓存失效，当请求首页的HTML页面时都会返回304 Not Modified。这个缓存效果是我们不想要的。这是因为注入到STF首页的JS代码的setTimeout的超时时间和session的TTL有关，因此我们肯定希望每次都返回由midway生成的代码。一个简单的做法是在<code>index.lua</code>中加入：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.header[<span class="string">"Cache-Control"</span>] = <span class="string">"no-store"</span></span><br></pre></td></tr></table></figure><p>另外，我们需要让response headers中的”Content-Length”符合我们生成的文档的长度，所以别忘了加入：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.header[<span class="string">"Content-Length"</span>] = <span class="built_in">string</span>.<span class="built_in">len</span>(body)</span><br></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>既可以将STF和midway分别部署在两台独立的服务器上，也可以将它们部署在同一台服务器上。在初次访问STF时会有一个验证步骤，浏览器会被重定向到启动STF的命令中<code>--public-ip</code>所指向的地址。如果是分开部署，由于我们的目的是让midway反向代理STF的所有流量，因此<code>--public-ip</code>的值应该是midway的地址。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍一种在两个独立系统之间搭建中间层来做请求转发和权限校验的方案。&lt;/p&gt;
    
    </summary>
    
      <category term="web后端" scheme="https://nullcc.github.io/categories/web%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="OpenResty" scheme="https://nullcc.github.io/tags/OpenResty/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊0.1+0.2=0.30000000000000004这件事</title>
    <link href="https://nullcc.github.io/2019/12/15/%E8%81%8A%E4%B8%80%E8%81%8A0.1+0.2=0.30000000000000004%E8%BF%99%E4%BB%B6%E4%BA%8B/"/>
    <id>https://nullcc.github.io/2019/12/15/聊一聊0.1+0.2=0.30000000000000004这件事/</id>
    <published>2019-12-14T16:00:00.000Z</published>
    <updated>2022-04-15T03:41:13.037Z</updated>
    
    <content type="html"><![CDATA[<p>本文专为对于0.1+0.2=0.30000000000000004这一结果很懵逼的人打造。</p><a id="more"></a><p>人们都知道在十进制下0.1+0.2的结果等于0.3，这个是答案毋庸置疑的。但是如果有一天你在某个编程语言环境下输入0.1+0.2，但计算机给出的答案是0.30000000000000004，相信不少人一开始一定会大吃一惊，难道计算机连这么简单的加法运算都能算错吗？甚至有人专门建了一个叫做<a href="https://0.30000000000000004.com/" target="_blank" rel="noopener">0.30000000000000004.com</a>的网站来记录各种编程语言对于0.1+0.2的计算结果。</p><h2 id="0-1和0-2的二进制表示"><a href="#0-1和0-2的二进制表示" class="headerlink" title="0.1和0.2的二进制表示"></a>0.1和0.2的二进制表示</h2><p>我们先来看一下十进制数0.1和0.2如何用二进制表示。0.1和0.2都是小数，对于小数需要采用乘2法来计算它们的二进制表示，也就从一个给定的小数开始，不断乘以2，对于每一轮计算的结果，如果个位是0，就提取0，然后继续计算，如果个位是1，就提取1，然后将个位置0并继续计算，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0.1 * 2 = 0.2 -&gt; 0</span><br><span class="line">0.2 * 2 = 0.4 -&gt; 0</span><br><span class="line">0.4 * 2 = 0.8 -&gt; 0</span><br><span class="line">0.8 * 2 = 1.6 -&gt; 1</span><br><span class="line">0.6 * 2 = 1.2 -&gt; 1</span><br><span class="line">0.2 * 2 = 0.4 -&gt; 0</span><br><span class="line">0.4 * 2 = 0.8 -&gt; 0</span><br><span class="line">0.8 * 2 = 1.6 -&gt; 1</span><br><span class="line">0.6 * 2 = 1.2 -&gt; 1</span><br><span class="line">0.2 * 2 = 0.4 -&gt; 0</span><br><span class="line">0.4 * 2 = 0.8 -&gt; 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>0.1的二进制表示中出现了无限循环的情况，也就是(0.1)<sub>10</sub> = (0.00110011001100…)<sub>2</sub></p><p>再来看0.2的二进制表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0.2 * 2 = 0.4 -&gt; 0</span><br><span class="line">0.4 * 2 = 0.8 -&gt; 0</span><br><span class="line">0.8 * 2 = 1.6 -&gt; 1</span><br><span class="line">0.6 * 2 = 1.2 -&gt; 1</span><br><span class="line">0.2 * 2 = 0.4 -&gt; 0</span><br><span class="line">0.4 * 2 = 0.8 -&gt; 0</span><br><span class="line">0.8 * 2 = 1.6 -&gt; 1</span><br><span class="line">0.6 * 2 = 1.2 -&gt; 1</span><br><span class="line">0.2 * 2 = 0.4 -&gt; 0</span><br><span class="line">0.4 * 2 = 0.8 -&gt; 0</span><br><span class="line">0.8 * 2 = 1.6 -&gt; 1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>0.2的二进制表示中也有无限循环的情况，也就是(0.2)<sub>10</sub> = (0.01100110011001…)<sub>2</sub></p><p>通过上述转换，我们可以发现<strong>计算机无法用二进制精确地表示某些十进制小数</strong>。</p><h2 id="浮点数运算标准IEEE-754"><a href="#浮点数运算标准IEEE-754" class="headerlink" title="浮点数运算标准IEEE-754"></a>浮点数运算标准IEEE-754</h2><p>要理解浮点数运算，就必须提到IEEE-754浮点数运算标准。该标准被运用在大部分CPU和浮点运算器上，可以说是计算机浮点数运算的事实标准，它主要由加州大学伯克利分校的William Morton Kahan教授研究和制定。本文并不打算完整讲述IEEE-754，如有需要可以移步<a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">wikipedia-IEEE_754</a>，下面将只介绍IEEE-754知识的一个子集。</p><p>IEEE-754规定一个浮点数由三个域组成，如下图：</p><ol><li>sign 符号位</li><li>exponent 指数偏移值</li><li>fraction 分数值</li></ol><p>计算一个IEEE-754浮点数的真值公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = sign * exponent * fraction</span><br></pre></td></tr></table></figure><p><img src="/assets/images/post_imgs/IEEE-754-format.png" alt="IEEE-754浮点数的三个域(图片来源于Wikipedia)"></p><p>IEEE-754规定单精度浮点数(32 bits)和双精度浮点数(64 bits)的结构如下：</p><p><img src="/assets/images/post_imgs/IEEE-754-float.png" alt="IEEE-754单精度和双精度浮点数格式"></p><p>32位IEEE-754浮点数的真值计算公式：</p><p>value = (-1)<sup>S</sup> <em> 2<sup>E-127</sup> </em> (1.M)</p><p>64位IEEE-754浮点数的真值计算公式：</p><p>value = (-1)<sup>S</sup> <em> 2<sup>E-1023</sup> </em> (1.M)</p><p>上述两个公式中，对于32位浮点数，E = e + 127，对于64位浮点数，E = e + 1023。</p><p>可以用一种简单的方法将一个浮点数的二进制形式转换成IEEE-754格式，步骤如下：</p><ol><li>将浮点数的二进制表示为科学计数法形式。</li><li>将该浮点数的科学计数法表示的符号位提取出来，正数为0，负数为1，作为S。</li><li>将该浮点数的科学计数法表示的2的次方提取出来，作为e。</li><li>将该浮点数的科学计数法表示的尾数提取出来，作为M。</li><li>计算(-1)<sup>S</sup> <em> 2<sup>E-127</sup> </em> (1.M)的值，即为该IEEE-754格式浮点数的真值。</li></ol><p>按照上面的步骤我们以双精度浮点数来计算0.1+0.2。将下面两个序列以二进制相加：</p><p>(0.1)<sub>10</sub> = (0.00110011001100…)<sub>2</sub><br>(0.2)<sub>10</sub> = (0.01100110011001…)<sub>2</sub></p><p>我们得到：</p><p>(0.3)<sub>10</sub> = (0.1001100110011001…)<sub>2</sub></p><p>同样可以发现，计算机也无法精确地表示十进制数的0.3。</p><p>将0.3的二进制形式转换为科学计数法形式：</p><p>(0.3)<sub>10</sub> = (1.001100110011001…)<sub>2</sub> * 2<sup>-1</sup></p><p>于是得到 S = 0， E = -1 + 1023 = 1022，M = (0.001100110011001…)<sub>2</sub></p><p>所以在IEEE-754的规定下，由上述S，E和M所表示的64位双精度浮点数的真值就是：</p><p>value = (-1)<sup>0</sup> <em> 2<sup>1022-1023</sup> </em> (1.001100110011001…)<sub>2</sub></p><p>64位双精度浮点数的M长度是52位，因此(0.001100110011001…)<sub>2</sub>实际上被存储为(00011001100110011001100110011001100110011001100110<strong>10</strong>)<sub>2</sub>，请注意最后两位，按照之前的规律应该是<strong>01</strong>（很容易发现0.3的二进制形式中包含循环模式1001），怎么变成<strong>10</strong>了呢？实际上这是舍入操作导致的。IEEE-754规定了四种舍入方式：</p><ol><li>舍入到最接近，这是默认的舍入方式，会将结果舍入为最接近且可以表示的值，但是当存在两个数一样接近的时候，则取其中的偶数（在二进制中是以0结尾的）</li><li>朝+∞方向舍入</li><li>朝-∞方向舍入</li><li>朝0方向舍入</li></ol><p>如过要对10011001舍入左起第3位（从0开始）之后的值，则有两种选择：</p><ol><li>1001  (10011001-00001001）</li><li>1010  (10011001+00000111)</li></ol><p>由于舍入到1010(+7)比舍入到1001(-9)更接近10011001，因此上面的M的最后两位就是10而不是01了。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>说了这么多，还需要验证我们的理论。计算验证很简单，可以写一段Python代码来验证这个结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin2dec</span><span class="params">(b)</span>:</span></span><br><span class="line">    bit_seq = [int(bit) <span class="keyword">for</span> bit <span class="keyword">in</span> b <span class="keyword">if</span> bit != <span class="string">'.'</span>]</span><br><span class="line">    value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, bit <span class="keyword">in</span> enumerate(bit_seq):</span><br><span class="line">        value += <span class="number">2</span>**(-i<span class="number">-1</span>) * bit</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">S = <span class="number">0</span></span><br><span class="line">e = <span class="number">-1</span></span><br><span class="line">E = e + <span class="number">1023</span></span><br><span class="line">M = <span class="string">'.001100110011001100110011001100110011001100110011010'</span></span><br><span class="line"></span><br><span class="line">print((<span class="number">-1</span>)**<span class="number">0</span> * <span class="number">2</span>**(<span class="number">1022</span><span class="number">-1023</span>) * (bin2dec(<span class="string">'1'</span> + M)))  <span class="comment"># 0.30000000000000004</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文专为对于0.1+0.2=0.30000000000000004这一结果很懵逼的人打造。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="https://nullcc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="https://nullcc.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="浮点数" scheme="https://nullcc.github.io/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP读书笔记(书已看完，剩下的读书笔记都在心里（逃。。)</title>
    <link href="https://nullcc.github.io/2019/09/29/CSAPP%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0)/"/>
    <id>https://nullcc.github.io/2019/09/29/CSAPP读书笔记(长期更新)/</id>
    <published>2019-09-28T16:00:00.000Z</published>
    <updated>2022-04-15T03:41:13.013Z</updated>
    
    <content type="html"><![CDATA[<p>决定花时间温习一遍CSAPP，本文是 CSAPP《深入理解计算机系统》的读书笔记。</p><a id="more"></a><h2 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章 计算机系统漫游"></a>第一章 计算机系统漫游</h2><h3 id="编译系统的组成"><a href="#编译系统的组成" class="headerlink" title="编译系统的组成"></a>编译系统的组成</h3><p><img src="/assets/images/post_imgs/compilation_system.png" alt="编译系统组成"></p><h3 id="硬件系统的基本组成"><a href="#硬件系统的基本组成" class="headerlink" title="硬件系统的基本组成"></a>硬件系统的基本组成</h3><ul><li>总线</li><li>I/O设备</li><li>主存</li><li>处理器</li></ul><h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p>总线每次传送<strong>定长</strong>的字节块，称作<strong>字(word)</strong>，字中的字节数称为<strong>字长</strong>。字长是系统的基本参数，它的大小在不同计算机中不尽相同，常见的字长有4(32 bits)和8(64 bits)。</p><h4 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h4><p>每个I/O设备都通过一个控制器或适配器与I/O总线相连。</p><h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><p>主存在物理上由一组动态随机存取存储器(DRAM)芯片组成，逻辑上它是一个线性的字节数组，每个字节都有唯一的地址（数组索引），从0开始。</p><h4 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h4><p>处理器是解释和执行存储在主存中指令的引擎，它的核心是一个大小为一个字的存储设备（寄存器），称作<strong>程序计数器(PC)</strong>，在任何时刻，PC都指向主存中的某条机器语言指令，即PC保存的是主存中的某个地址。由此很容易理解为何计算机可寻址的内存大小和它的字大小密切相关，因为PC的容量即是该处理器的字长，能保存的最大主存地址也就是一个字。比如字长为4字节的32位计算机最大寻址只能到4GB(2^32 = 4GB)。</p><p>处理器一直在不断地执行PC指向指令，接着更新PC，将其指向下一条指令，下一条指令的地址和刚被执行的上一条指令的地址不一定是相邻的。</p><p>处理器中包含一些拥有固定名字的寄存器，这些寄存器的大小是<strong>单个字长</strong>。</p><p>处理器在指令的要求下可能会执行下面几个典型的操作：</p><ul><li><strong>加载</strong>：从主存复制一个字节或一个字到寄存器，覆盖寄存器中原来的值。</li><li><strong>存储</strong>：从寄存器复制一个字节或一个字到主存的某个位置，覆盖主存中这个位置原来的值。</li><li><strong>操作</strong>：把两个寄存器的内容复制到ALU做算术运算，并将结果存放到另一个寄存器中，覆盖这个寄存器中原来的值。</li><li><strong>跳转</strong>：从指令中提取一个字，并将这个字复制到PC中覆盖PC中原来的值。</li></ul><h4 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h4><p>存储器层次结构呈金字塔状。从上至下，设备的访问速度越来越慢，容量越来越大，单位字节的造价越来越低。存储器层次结构的主要思想是<strong>上一层存储器作为下一层存储器的高速缓存</strong>。如下图：</p><p><img src="/assets/images/post_imgs/csapp_memory_layer.png" alt="存储器层次结构"></p><h3 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h3><p>操作系统是介于硬件和应用程序之间的一层软件系统，所有应用程序对硬件的操作都必须经过操作系统。</p><p><img src="/assets/images/post_imgs/csapp_computer_system_layer.png" alt="计算机系统的分层视图"></p><p>操作系统的两个基本功能是：</p><ul><li>防止硬件被失控的应用程序滥用。</li><li>向应用程序提供<strong>简单一致的机制</strong>来控制复杂而又通常大不相同的低级硬件设备。</li></ul><p>操作系统提供了三个抽象概念来实现这两个基本功能：</p><ul><li><strong>进程</strong></li><li><strong>虚拟内存</strong></li><li><strong>文件</strong></li></ul><p><img src="/assets/images/post_imgs/csapp_os_abstract.png" alt="操作系统提供的抽象"></p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>操作系统提供了一种假象：系统上只有这个进程在运行，使程序看上去独占处理器、主存和I/O设备。实际上在一个系统上可以同时运行多个进程，进程数是可以多于CPU个数的。CPU通过在进程间快速切换来给人以所有进程都在并发执行的假象。</p><p>为了达到CPU在进程间切换的效果，操作系统负责管理进程运行的上下文，上下文包括PC、寄存器的当前值和主存的内容等。单处理器在任一时刻只能运行一个进程的代码。当操作系统决定要进行进程切换时，会先保存当前进程的上下文信息，然后将新进程的上下文恢复，并将控制权传递到新进程。新进程就会从它上次暂停的地方继续往下运行。</p><p>注：<strong>进程是操作系统进行资源分配的最小单位</strong></p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>在操作系统中，一个进程可以又多个称为线程的执行单元构成，每个线程都运行在进程的上下文中。同一进程中的多个线程共享代码和全局数据。</p><p>注：<strong>线程是操作系统进行任务调度和执行的最小单位</strong></p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>虚拟内存提供了一种假象：每个进程都在独占地使用内存。每个进程看到的内存都是一致的，称为虚拟地址空间。下图是Linux的虚拟地址空间示意图(以hello程序为例)：</p><p><img src="/assets/images/post_imgs/csapp_process_virtual_address_space.png" alt="进程虚拟地址空间"></p><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p><strong>文件就是字节序列</strong>。每个I/O设备，包括键盘、磁盘、显示器、打印机和网络都可以看成文件。系统中的所有输入输出都是通过调用一组称为Unix I/O的系统调用读写文件来实现的。</p><p>文件的概念简单而强大，它屏蔽了所有底层硬件的实现细节，通过一致的视图来操作这些硬件。这使得不同厂商提供的设备都能运行在同一台计算机上。</p><h3 id="重要主题"><a href="#重要主题" class="headerlink" title="重要主题"></a>重要主题</h3><h4 id="Amdahl’s-Law-阿姆达尔定律"><a href="#Amdahl’s-Law-阿姆达尔定律" class="headerlink" title="Amdahl’s Law (阿姆达尔定律)"></a>Amdahl’s Law (阿姆达尔定律)</h4><p>阿姆达尔定律的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。其公式如下：</p><p><strong>S=1/(1-a+a/n)</strong></p><p>其中a为被加速部分占原整体计算的比例，n为性能提升比例。</p><p>按照这个公式，可以推导出两个极端极端情况：</p><ul><li>当a=1时，S=n。整体计算没有串行部分而全部都是并行部分，加速比为n，此时可以通过增加处理节点来提高整体性能。</li><li>当a=0时，S=1。整体计算全部都是串行部分，加速比为1，此时无法通过增加处理节点来提供整体性能。</li><li>当n-&gt;+∞时，S=1/(1-a)。这是一种极限情况。举个例子假如a=0.6，n-&gt;+∞则S=2.5，也就是说当被优化部分的代码占整体计算的60%时，无论怎么优化这部分代码的性能，整体获得的加速比最高不超过2.5。</li></ul><h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><p>在系统中有三个层次的并发和并行：</p><ul><li>线程级并发</li><li>指令级并行</li><li>单指令、多数据并行</li></ul><p><img src="/assets/images/post_imgs/csapp_abstract_layer_2.png" alt="计算机系统中的抽象"></p><h2 id="第二章-信息的表示和处理"><a href="#第二章-信息的表示和处理" class="headerlink" title="第二章 信息的表示和处理"></a>第二章 信息的表示和处理</h2><p>整数的表示虽然只能编码一个相对较小的数值范围，但这种表示是精确的；浮点数虽然能编码一个较大的数值范围，但这种表示是近似的。</p><h3 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h3><ul><li>计算机使用字节(byte, 1byte=8bits)而不是单独的位来作为最小寻址单位。</li><li>机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。内存的每个字节都由一个唯一的数字来标识，称为它的地址，所有可能的地址的集合就称为虚拟地址空间。</li><li>虚拟地址空间是一个逻辑上的概念，实际上计算机将动态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。</li></ul><h4 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h4><p>由于二进制表示法太冗长，人们常用十六进制表示法，可用值为0-9A-F。人们常以0x开头表示十六进制值。</p><p>在十六进制和二进制之间相互转换非常容易，如果给定一个二进制序列要转换为十六进制，只需从低位到高位以4位一组分组，最左边的一组位数若不足4位可以在左边补0。然后将每个4位组直接转换为0-9A-F中的一个值即可。将十六进制转换为二进制就是将每一位以其相应的二进制位串代替即可。</p><h4 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h4><p>字长(word size)指明了指针数据的标称大小，字长决定了虚拟地址空间的最大大小。对于一个字长为w的机器而言，其虚拟地址空间范围为0-2^w-1，程序最多访问2^w个字节。</p><h4 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h4><p>有两种字节顺序：</p><ul><li>小端法(little endian)是最低有效字节在最前面。</li><li>大端法(big endian)是最高有效字节在最前面。</li></ul><p>比如一个int类型的变量值为0x01234567，位于地址0x100处，在两种字节顺序下的情况如下：</p><p>小端法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... 0x100 0x101 0x102 0x103 ...</span><br><span class="line">      67    45    23    01</span><br></pre></td></tr></table></figure><p>大端法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... 0x100 0x101 0x102 0x103 ...</span><br><span class="line">      01    23    45    67</span><br></pre></td></tr></table></figure><p>对于选择哪种字节顺序并没有任何技术上的理由。</p><h4 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h4><p>C语言中的字符串被编码成一个以null(其值为0)字符结尾的字符数组，每个字符都由某个标准编码来表示，如最常见的ASCII字符编码。ASCII字符集适合编码英文文档，如果要支持多语言文字，就需要使用Unicode编码。</p><h4 id="表示代码"><a href="#表示代码" class="headerlink" title="表示代码"></a>表示代码</h4><p>不同机器类型使用不同的且不兼容的指令和编码方式，因此二进制代码是不兼容的。</p><h4 id="布尔代数简介"><a href="#布尔代数简介" class="headerlink" title="布尔代数简介"></a>布尔代数简介</h4><p>布尔代数的操作符：</p><ul><li>非：~</li><li>与：&amp;</li><li>或：|</li><li>异或：^</li></ul><table><thead><tr><th style="text-align:center">~</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><table><thead><tr><th style="text-align:center">&amp;</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table><table><thead><tr><th style="text-align:center">&#124;</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table><table><thead><tr><th style="text-align:center">^</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p>布尔代数的一些数学属性：</p><ul><li>布尔运算&amp;对|的分配律：a&amp;(b|c) 等价于 (a&amp;b)|(a&amp;c)。</li><li>布尔运算|对&amp;的分配律：a|(b&amp;c) 等价于 (a|b)&amp;(a|c)。</li><li>对任何值a来说，有a^a=0，(a^b)^a=b。</li></ul><p>位向量还可以用来表示有限集合，比如位向量a=[01101001]表示集合{0,3,5,6}。</p><h4 id="C语言中的位级运算"><a href="#C语言中的位级运算" class="headerlink" title="C语言中的位级运算"></a>C语言中的位级运算</h4><ul><li>按位或：|</li><li>按位与：&amp;</li><li>取反：~</li><li>按位异或：^</li></ul><h4 id="C语言中的逻辑运算"><a href="#C语言中的逻辑运算" class="headerlink" title="C语言中的逻辑运算"></a>C语言中的逻辑运算</h4><ul><li>或：||</li><li>与：&amp;&amp;</li><li>非：!</li></ul><p>逻辑运算认为所有非零的参数都表示TRUE，而参数0表示FALSE。逻辑运算的结果为1或0，表示TRUE或FALSE。</p><h4 id="C语言中的移位运算"><a href="#C语言中的移位运算" class="headerlink" title="C语言中的移位运算"></a>C语言中的移位运算</h4><p>移位运算是从左至右可结合的，所以<code>x&lt;&lt;j&lt;&lt;k</code>等价于<code>(x&lt;&lt;j)&lt;&lt;k</code></p><p>有3种移位运算：</p><ul><li>左移</li><li>逻辑右移</li><li>算数右移</li></ul><p><strong>右移分两种：逻辑右移和算数右移。逻辑右移x&gt;&gt;k是在左端补k个0，而算数右移x&gt;&gt;k是在左端补k个最高有效位的值。</strong></p><p>实际上，几乎所有的编译器和机器组合都对有符号数使用算数右移，另外<strong>对于无符号数，右移必须是逻辑的</strong>。</p><h3 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h3><h4 id="整型数据类型"><a href="#整型数据类型" class="headerlink" title="整型数据类型"></a>整型数据类型</h4><p>32位程序上C语言整型数据类型的典型取值范围：</p><table><thead><tr><th style="text-align:center">C数据类型</th><th style="text-align:center">最小值</th><th style="text-align:center">最大值</th></tr></thead><tbody><tr><td style="text-align:center">[signed] char</td><td style="text-align:center">-128</td><td style="text-align:center">127</td></tr><tr><td style="text-align:center">unsigned char</td><td style="text-align:center">0</td><td style="text-align:center">255</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">-32768</td><td style="text-align:center">32767</td></tr><tr><td style="text-align:center">unsigned short</td><td style="text-align:center">0</td><td style="text-align:center">65535</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">-2147483648</td><td style="text-align:center">2147483647</td></tr><tr><td style="text-align:center">unsigned</td><td style="text-align:center">0</td><td style="text-align:center">4294967295</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">-2147483648</td><td style="text-align:center">2147483647</td></tr><tr><td style="text-align:center">ungigned long</td><td style="text-align:center">0</td><td style="text-align:center">4294967295</td></tr><tr><td style="text-align:center">int32_t</td><td style="text-align:center">-2147483648</td><td style="text-align:center">2147483647</td></tr><tr><td style="text-align:center">uint32_t</td><td style="text-align:center">0</td><td style="text-align:center">4294967295</td></tr><tr><td style="text-align:center">int64_t</td><td style="text-align:center">-9223372036854775808</td><td style="text-align:center">9223372036854775807</td></tr><tr><td style="text-align:center">uint64_t</td><td style="text-align:center">0</td><td style="text-align:center">18446744073709551615</td></tr></tbody></table><p>64位程序上C语言整型数据类型的典型取值范围：</p><table><thead><tr><th style="text-align:center">C数据类型</th><th style="text-align:center">最小值</th><th style="text-align:center">最大值</th></tr></thead><tbody><tr><td style="text-align:center">[signed] char</td><td style="text-align:center">-128</td><td style="text-align:center">127</td></tr><tr><td style="text-align:center">unsigned char</td><td style="text-align:center">0</td><td style="text-align:center">255</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">-32768</td><td style="text-align:center">32767</td></tr><tr><td style="text-align:center">unsigned short</td><td style="text-align:center">0</td><td style="text-align:center">65535</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">-2147483648</td><td style="text-align:center">2147483647</td></tr><tr><td style="text-align:center">unsigned</td><td style="text-align:center">0</td><td style="text-align:center">4294967295</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">-9223372036854775808</td><td style="text-align:center">9223372036854775807</td></tr><tr><td style="text-align:center">ungigned long</td><td style="text-align:center">0</td><td style="text-align:center">18446744073709551615</td></tr><tr><td style="text-align:center">int32_t</td><td style="text-align:center">-2147483648</td><td style="text-align:center">2147483647</td></tr><tr><td style="text-align:center">uint32_t</td><td style="text-align:center">0</td><td style="text-align:center">4294967295</td></tr><tr><td style="text-align:center">int64_t</td><td style="text-align:center">-9223372036854775808</td><td style="text-align:center">9223372036854775807</td></tr><tr><td style="text-align:center">uint64_t</td><td style="text-align:center">0</td><td style="text-align:center">18446744073709551615</td></tr></tbody></table><p>C语言的整型数据类型的保证的取值范围：</p><table><thead><tr><th style="text-align:center">C数据类型</th><th style="text-align:center">最小值</th><th style="text-align:center">最大值</th></tr></thead><tbody><tr><td style="text-align:center">[signed] char</td><td style="text-align:center">-127</td><td style="text-align:center">127</td></tr><tr><td style="text-align:center">unsigned char</td><td style="text-align:center">0</td><td style="text-align:center">255</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">-32767</td><td style="text-align:center">32767</td></tr><tr><td style="text-align:center">unsigned short</td><td style="text-align:center">0</td><td style="text-align:center">65535</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">-32767</td><td style="text-align:center">32767</td></tr><tr><td style="text-align:center">unsigned</td><td style="text-align:center">0</td><td style="text-align:center">65535</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">-2147483647</td><td style="text-align:center">2147483647</td></tr><tr><td style="text-align:center">ungigned long</td><td style="text-align:center">0</td><td style="text-align:center">4294967295</td></tr><tr><td style="text-align:center">int32_t</td><td style="text-align:center">-2147483648</td><td style="text-align:center">2147483647</td></tr><tr><td style="text-align:center">uint32_t</td><td style="text-align:center">0</td><td style="text-align:center">4294967295</td></tr><tr><td style="text-align:center">int64_t</td><td style="text-align:center">-9223372036854775808</td><td style="text-align:center">9223372036854775807</td></tr><tr><td style="text-align:center">uint64_t</td><td style="text-align:center">0</td><td style="text-align:center">18446744073709551615</td></tr></tbody></table><p>另外，C/C++都支持有符号数（默认）和无符号数，Java只支持有符号数。</p><h4 id="无符号数的编码"><a href="#无符号数的编码" class="headerlink" title="无符号数的编码"></a>无符号数的编码</h4><p>原理：无符号数编码的定义</p><p><img src="/assets/images/post_imgs/csapp_unsigned_encode.png" alt="无符号数编码的定义"></p><p>无符号数的二进制表示有一个很重要的属性，即每个介于0-2^w-1之间的数都有唯一一个w位的值编码。</p><p>原理：无符号数编码的唯一性</p><h4 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h4><p>补码是最常见的计算机编码有符号数的方式（另外两种方式为反码和原码）。</p><p>原理：补码编码的定义</p><p><img src="/assets/images/post_imgs/csapp_two&#39;s_complement_encode.png" alt="补码编码的定义"></p><p>原理：补码编码的唯一性</p><p>一些重要的数字的补码表示：</p><table><thead><tr><th style="text-align:center">数</th><th style="text-align:center">8位字长</th><th style="text-align:center">16位</th><th style="text-align:center">32位</th><th style="text-align:center">64位</th></tr></thead><tbody><tr><td style="text-align:center">UMax</td><td style="text-align:center">0xFF<br>255</td><td style="text-align:center">0xFFFF<br>65535</td><td style="text-align:center">0xFFFFFFFF<br>4294967295</td><td style="text-align:center">0xFFFFFFFFFFFFFFFF<br>18446744073709551615</td></tr><tr><td style="text-align:center">TMin</td><td style="text-align:center">0x80<br>-128</td><td style="text-align:center">0x8000<br>-32768</td><td style="text-align:center">0x80000000<br>-2147483648</td><td style="text-align:center">0x8000000000000000<br>-9223372036854775808</td></tr><tr><td style="text-align:center">TMax</td><td style="text-align:center">0x7F<br>127</td><td style="text-align:center">0x7FFF<br>32767</td><td style="text-align:center">0x7FFFFFFF<br>2147483647</td><td style="text-align:center">0x7FFFFFFFFFFFFFFF<br>9223372036854775807</td></tr><tr><td style="text-align:center">-1</td><td style="text-align:center">0xFF</td><td style="text-align:center">0xFFFF</td><td style="text-align:center">0xFFFFFFFF</td><td style="text-align:center">0xFFFFFFFFFFFFFFFF</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0x00</td><td style="text-align:center">0x0000</td><td style="text-align:center">0x00000000</td><td style="text-align:center">0x0000000000000000</td></tr></tbody></table><p>以下几点值得注意：</p><ul><li>补码的取值范围是不对称的：|TMin| = |TMax| + 1</li><li>最大的无符号数值刚好比补码的最大值的两倍大1：UMax = 2TMax + 1</li></ul><p>C库文件&lt;limits.h&gt;中定义了一组常量来限定编译器运行的这台机器的不同整型数据类型的取值范围，比如INT_MAX、INT_MIN和UINT_MAX。</p><p>有符号数的其他表示方法：</p><ul><li>反码，除了最高有效位的权是-(2^w-1 - 1)而不是-2^w-1，其余和补码一样。</li></ul><p><img src="/assets/images/post_imgs/csapp_ones_complement.png" alt="反码编码的定义"></p><ul><li>原码，最高有效位是符号位。<br><img src="/assets/images/post_imgs/csapp_sign_magnitude.png" alt="原码编码的定义"></li></ul><p>需要注意的是，反码和原码对0的编码表示有两种，[00…0]都解释为+0，而-0在原码中为[10…0]，在反码则为[11…1]。目前几乎所有现代机器都使用补码扁食有符号数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;决定花时间温习一遍CSAPP，本文是 CSAPP《深入理解计算机系统》的读书笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://nullcc.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Basics" scheme="https://nullcc.github.io/tags/Basics/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript中利用transformer获取interface keys</title>
    <link href="https://nullcc.github.io/2019/07/18/TypeScript%E4%B8%AD%E5%88%A9%E7%94%A8transformer%E8%8E%B7%E5%8F%96interface%20keys/"/>
    <id>https://nullcc.github.io/2019/07/18/TypeScript中利用transformer获取interface keys/</id>
    <published>2019-07-17T16:00:00.000Z</published>
    <updated>2022-04-15T03:41:13.021Z</updated>
    
    <content type="html"><![CDATA[<p>本文分成四个部分：</p><ol><li>需求和灵感</li><li>TypeScript的抽象语法树简介</li><li>TypeScript transformer简介</li><li>编写获取TypeScript interface keys的transformer</li></ol><a id="more"></a><h2 id="需求和灵感"><a href="#需求和灵感" class="headerlink" title="需求和灵感"></a>需求和灵感</h2><p>使用过TypeScript写代码的同学都对interface这个东西不陌生，借助interface来定义一些纯值对象的类型是再简单不过了。最开始我的需求很简单，想用interface来定义一个HTTP API的response DTO，在对一个API进行测试的时候，可以验证这个API的response结构是否和我用interface定义的结构相同。</p><p>刚开始想到可以使用ES 6的class来定义DTO，然后通过在运行时获取class的属性。这确实可以，但是用起来有点麻烦，比如下面的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> X &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(<span class="keyword">new</span> X())); <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>这还不够，需要对每个属性赋值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> X &#123;</span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line">  b = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(<span class="keyword">new</span> X())); <span class="comment">// [ 'a', 'b' ]</span></span><br></pre></td></tr></table></figure><p>或者在<code>X</code>的<code>constructor</code>里初始化一下属性（如果只是为了拿到属性名字，直接对每个属性赋值null即可）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> X &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.b = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(<span class="keyword">new</span> X())); <span class="comment">// [ 'a', 'b' ]</span></span><br></pre></td></tr></table></figure><p>虽然这样做也许可行，但是很快我就否定了这种用法。我只是想简单地声明一种类型，然后再需要的时候可以获取这个类型的所有属性。现在不仅要显式初始化所有属性（在<code>constructor</code>中或者直接在class声明属性的时候赋值），还要用<code>new</code>生成一个实例，实在不够优雅。其实在TypeScript中声明DTO一类的东西用interface会好一些，声明的代码简洁，支持直接嵌套属性，也可以声明属性的类型为其他interface，这和真实的HTTP Response Data的结构几乎一模一样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> X &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="built_in">string</span>;</span><br><span class="line">    d: Y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Y &#123;</span><br><span class="line">  u: <span class="built_in">string</span>;</span><br><span class="line">  v: &#123;</span><br><span class="line">    w: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遗憾的是，虽然interface很适合用来描述HTTP Response Data，但正常情况下如果想在运行时获取interface的keys用来和真正的HTTP Response Data结构做对比是不行的，因为TypeScript的interface实际上并不存在于runtime，要理解这个问题需要知道TypeScript针对JavaScript提供了一整套的类型辅助系统，但仅仅是辅助，最终的代码还是要转换成JavaScript来执行。由于JavaScript中并不存在interface，因此也就无法在runtime获得interface的keys了。</p><p>不过也不是完全没有希望，经过一番搜索，我发现了<a href="https://github.com/kimamula/ts-transformer-keys" target="_blank" rel="noopener">ts-transformer-keys</a>这个包，该包宣称可以获得interface的keys。仔细研究了一下，发现这个包提供一个<code>keys&lt;T&gt;()</code>方法，其实现原理是使用了自定义的transformer在将代码转换成JavaScript时获取了interface的信息，然后修改了调用<code>keys&lt;T&gt;()</code>处的抽象语法树(Abstract Syntax Tree, AST)节点信息。换句话说，这个包提供的transformer在将代码转换成JavaScript时直接从AST中找到相应interface的keys，然后创建一个包含所有keys数组，并将这个数组直接输出到转换出来的JavaScript代码中。</p><p>举个简单的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(keys&lt;Foo&gt;());</span><br></pre></td></tr></table></figure><p>上面这几行代码在被转换成JavaScript时被替换成了下面这行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="string">"a"</span>, <span class="string">"b"</span>]);</span><br></pre></td></tr></table></figure><p>正如上面所描述的，<code>ts-transformer-keys</code>对AST Nodes做了遍历-转换，这种能力正是我所需要的。进一步说，由于response DTO内部经常是嵌套结构的，因此很自然想到是否可以支持嵌套interface，比如下面这种情况：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: Bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Bar &#123;</span><br><span class="line">  c: <span class="built_in">boolean</span>;</span><br><span class="line">  d: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(keys&lt;Foo&gt;());</span><br></pre></td></tr></table></figure><p>但是<code>ts-transformer-keys</code>的输出还是只有a和b，看来<code>ts-transformer-keys</code>尚未支持这种用法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="string">"a"</span>, <span class="string">"b"</span>]);</span><br></pre></td></tr></table></figure><p>再进一步，我还想要得到interface各个key的类型和存在性，目前<code>ts-transformer-keys</code>也不支持。不过没关系，知道了内部的实现原理，完全可以自己写一个transformer。</p><h2 id="TypeScript的抽象语法树简介"><a href="#TypeScript的抽象语法树简介" class="headerlink" title="TypeScript的抽象语法树简介"></a>TypeScript的抽象语法树简介</h2><p>在真正开始编写自己的transformer之前，有必要简单了解一下TypeScript的抽象语法树和TypeScript对操作抽象语法树所提供的支持。</p><p>抽象语法树(Abstract Syntax Tree，AST)，下文简称为AST，是源代码语法结构的一种抽象表示。为了更直观地观察TypeScript的AST，可以借助<a href="https://ts-ast-viewer.com/" target="_blank" rel="noopener">ts-ast-viewer</a>这个工具来以树形结构将其可视化。先看一个基本的TypeScript interface的抽象语法树表示，假设有如下代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  a?: <span class="built_in">number</span>;</span><br><span class="line">  b: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用ts-ast-viewer可以得到上面代码的AST结构：</p><p><img src="/assets/images/post_imgs/ts-ast-1.png" alt="interface的AST结构"></p><p>从图中可以很清楚地看到Foo的AST表示，另外在右边的Node部分，还能查看到其AST中具体节点的信息，对于TypeScript的interface我们关心的属性名称、存在性和类型都可找到相应的字段来对应。</p><p>图形化表示如下：</p><p><img src="/assets/images/post_imgs/ts-ast-2.png" alt="interface的AST结构图形表示"></p><p>源代码的几乎每一个细节，在AST中都有体现。让我们从上到下走马观花一下：</p><ol><li>最顶层是<code>SourceFile</code>，每一个TypeScript源代码文件都会对应一个SourceFile。</li><li><code>SourceFile</code>下直接包含的<code>SyntaxList</code>包括了这个文件中的所有语法结构，在这里只有这个interface声明，如果还有其他语法结构，也将被包含在内。</li><li><code>InterfaceDeclaration</code>表示这个interface的声明。</li><li><code>InterfaceKeyword</code>表示关键字interface。</li><li>紧接着的<code>Identifier</code>对应的是interface的名字<code>Foo</code>。</li><li><code>OpenBraceToken</code>表示<code>{</code>。</li><li>接下来又是一个<code>SyntaxList</code>，这个SyntaxList和刚才看到的那个不一样，它只包括了interface Foo中声明的所有语法结构，这样的结构划分有点类似作用域。</li><li>之后的<code>PropertySignature</code>是一个属性签名，表示<code>a?: number;</code>。</li><li>PropertySignature下的一些属性，<code>Identifier</code>表示属性名<code>a</code>，<code>QuestionToken</code>表示<code>?</code>，<code>ColonToken</code>表示<code>:</code>，<code>NumberKeyword</code>表示属性名a的类型是<code>number</code>，<code>SemicolonToken</code>则表示<code>;</code>。</li></ol><p>后面的结构和前面差不多就不赘述了。</p><p>值得一提的是，在TypeScript的类型声明文件<code>typeacript.t.ts</code>的<code>SyntaxKind</code>这个<code>enum</code>声明中，可以找到上面列举的AST语法结构类型的声明，编写transformer的时候我们还会用到它。另外，之前提到<code>ts-transformer-keys</code>是使用transformer来遍历AST Nodes以获取interface keys，并就地创建一个Array，将keys数组（是一个字符串数组）复制给原来TypeScript代码中<code>keys&lt;T&gt;()</code>对应的左值。因此我们还需要能遍历，修改和创建AST Nodes，实际上TypeScript对这些操作已经提供了支持，具体细节之后会谈到。</p><p>上面AST内部的细节部分将在实际编写transformer的时候再来研究，现在只需要大致知道它的结构就可以了。</p><h2 id="TypeScript-transformer简介"><a href="#TypeScript-transformer简介" class="headerlink" title="TypeScript transformer简介"></a>TypeScript transformer简介</h2><p>在介绍transformer之前需要大致了解一下TypeScript的编译过程。</p><p>在<a href="https://github.com/microsoft/TypeScript/" target="_blank" rel="noopener">TypeScript</a>的Wiki中可以找到一篇和TypeScript内部架构和编译过程有关的文章，大部分网络上涉及TypeScript编译过程的文章大都参考它：<a href="https://github.com/microsoft/TypeScript/wiki/Architectural-Overview" target="_blank" rel="noopener">TypeScript Architectural Overview</a>。</p><p>根据文章中的介绍，TypeScript的核心编译过程中涉及的编译组件主要有下面几个：</p><ol><li>Pre-processor: 预处理器（包含Scanner）。</li><li>Parser: 语法分析器。</li><li>Binder: 绑定器。</li><li>Type resolver/ Checker: 类型检查器，解析每种类型的构造，负责处理、检查针对每个类型的语义操作，并生成合适的诊断信息。</li><li>Emitter：生成器，负责根据输入的.ts和.d.ts文件生成最终的结果，它有三种可能的输出：JavaScript源码(.js)、类型定义文件(.d.ts)或source map文件(.js.map)，其中类型定义文件可以帮助开发者在各种IDE中获取TypeScript的类型信息，source map文件则是一个存储源代码与编译代码对应位置映射的信息文件，在debug时我们需要利用source map文件来找到实际运行的代码(最终生成的.js文件)和其原始代码(开发者实际编写的.ts文件)的位置对应关系。</li></ol><p>TypeScript的编译过程简单归纳如下：</p><ol><li>在编译过程的开始阶段，输入是一些.ts源代码，Pre-processor会计算出有哪些源代码文件将参与编译过程（它会查找import语句和用<code>///</code>的引用语句），并在内部调用扫描器(Scanner)对所有源文件进行扫描，并封装成Tokens流，作为之后Parser的输入。</li><li>Parser以预处理器产生的Tokens流作为输入，根据语言语法规则生成抽象语法树(AST)，每个源文件的AST都有一个SourceFile节点。</li><li>Binder会遍历AST，并使用符号(Symbol)来链接相同结构的声明（例如对于具有相同结构的interface或模块，或者同名的函数或模块）。这个机制能帮助类型系统推导出这些具名声明。Binder也会处理作用域，确保每个Symbol都在正确的作用域中被创建。到目前为止，编译过程已经对每个单独的.ts文件进行了处理，得到了每个.ts文件的AST（每个AST都有一个SourceFile节点作为根节点）。接下来还需要将所有.ts文件的SourceFile合并在一起形成一个程序(Program)，TypeScript提供了一个<code>ts.createProgram</code>API来创建Program。我们知道源代码文件经常互相引用，下一步还将处理这些引用关系。</li><li>生成Program后，TypeChecker会负责计算出不同SourceFile中的Symbol引用关系，并将<code>Type</code>赋值给<code>Symbol</code>，并在此时生成语义诊断（如果有错误的话）。</li><li>对于一个Program，会生成一个Emitter，Emitter要做的就是针对每个SourceFile生成输出(.js/.d.ts/.js.map)。</li></ol><p>另外，在TypeScript的Wiki还能找到一篇比较“残缺”的文章（估计是项目开发人员忙于具体实现懒得更新Wiki了），提到了transformer：<a href="https://github.com/microsoft/TypeScript/wiki/Compiler-Internals#transformer" target="_blank" rel="noopener">TypeScript Compiler-Internals</a></p><p>摘录transformer部分的内容如下，其中<code>translated</code>和<code>transforms</code>颇为微妙：</p><blockquote><p>The transformer is nearing completion to replace the emitter. The change in name is because the emitter <strong>translated</strong> TypeScript to JavaScript. The transformer <strong>transforms</strong> TypeScript or JavaScript (various versions) to JavaScript (various versions) using various module systems. The input and output are basically both trees from the same AST type, just using different features. There is still a small printer that writes any AST back to text.</p></blockquote><p>这里对emitter的功能描述是<code>translated TypeScript to JavaScript</code>，emitter的作用是将TypeScript代码<code>翻译</code>成JavaScript代码。而翻译的意思是保持原文意思不变，也就是说emitter对TypeScript代码没有添油加醋，是照原样转成JavaScript的。而对transformer的功能描述是<code>transforms TypeScript or JavaScript (various versions) to JavaScript (various versions) using various module systems</code>，这里的transforms还有转换、变换的功能。</p><p>一言以蔽之，transformer对开发者暴露了AST，使我们能按照我们的意愿遍历和修改AST（这种修改包括删除、创建和直接修改AST Nodes）。</p><p>有了这些信息做铺垫后，可以用一张流程图来表示TypeScript的编译过程：</p><p><img src="/assets/images/post_imgs/ts-ast-3.png" alt="TypeScript的编译过程"></p><h2 id="编写获取TypeScript-interface-keys的transformer"><a href="#编写获取TypeScript-interface-keys的transformer" class="headerlink" title="编写获取TypeScript interface keys的transformer"></a>编写获取TypeScript interface keys的transformer</h2><p>终于到了实际写代码的环节了。在真正实现获取interface keys的transformer之前我们还有几个准备工作要做：</p><ol><li>实现一个最简单的transformer，之后的工作将在此基础上展开。</li><li>研究如何将transformer集成到TypeScript项目中。</li></ol><p>首先我们需要一种能在项目中使用transformer的方式，这里我选择<a href="https://github.com/cevek/ttypescript" target="_blank" rel="noopener">ttypescript</a>，因为它使用起来非常简单，另外还有一种方式是使用<a href="https://github.com/TypeStrong/ts-loader" target="_blank" rel="noopener">ts-loader</a>结合webpack，篇幅关系这里就只介绍使用<code>ttypescript</code>的方式。</p><p>以<code>ttypescript</code>提供的例子为基础，我们可以先写一个基础的transformer（部分代码来自于<a href="https://github.com/kimamula/ts-transformer-keys" target="_blank" rel="noopener">ts-transformer-keys</a>）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/transformer.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ts <span class="keyword">from</span> <span class="string">'typescript'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (program: ts.Program): ts.TransformerFactory&lt;ts.SourceFile&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">ctx: ts.TransformationContext</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (sourceFile: ts.SourceFile): ts.SourceFile =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> visitor = (node: ts.Node): ts.Node =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> ts.visitEachChild(visitNode(node, program), visitor, ctx);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> &lt;ts.SourceFile&gt; ts.visitEachChild(visitNode(sourceFile, program), visitor, ctx);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> visitNode = (node: ts.Node, program: ts.Program): ts.Node =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> typeChecker = program.getTypeChecker();</span><br><span class="line">  <span class="keyword">if</span> (!isKeysCallExpression(node, typeChecker)) &#123;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ts.createStringLiteral(<span class="string">'will be replaced by interface keys later'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> indexTs = path.join(__dirname, <span class="string">'./index.ts'</span>);</span><br><span class="line"><span class="keyword">const</span> isKeysCallExpression = (node: ts.Node, typeChecker: ts.TypeChecker): node is ts.CallExpression =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!ts.isCallExpression(node)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> signature = typeChecker.getResolvedSignature(node);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> signature === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; declaration &#125; = signature;</span><br><span class="line">  <span class="keyword">return</span> !!declaration</span><br><span class="line">    &amp;&amp; !ts.isJSDocSignature(declaration)</span><br><span class="line">    &amp;&amp; (path.join(declaration.getSourceFile().fileName) === indexTs)</span><br><span class="line">    &amp;&amp; !!declaration.name</span><br><span class="line">    &amp;&amp; declaration.name.getText() === <span class="string">'keys'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>几个地方解释一下：</p><ol><li>在导出方法中，<code>ts.visitEachChild</code>可以使用开发者提供的visitor来访问AST Node的每个子节点，并且在visitor中允许返回一个相同类型的新节点来替换当前被访问的节点。</li><li><code>visitNode</code>接受一个<code>ts.Node</code>和<code>ts.Program</code>类型的参数会在访问指定节点的每个子节点时被调用，这个方法需要放回一个<code>ts.Node</code>类型的对象，如果不想对当前节点做任何改变的话，直接返回实参中的<code>node</code>即可，如果想要做一些转换，那就需要自己编码实现了，这也是这个transformer实际发挥作用的地方。目前这里的做法是遇到<code>keys&lt;T&gt;()</code>调用就将节点替换为一个字符串’will be replaced by interface keys later’。</li><li>这里会沿用<code>ts-transformer-keys</code>的调用方式<code>keys&lt;T&gt;()</code>，我们需要判断调用点，<code>isKeysCallExpression</code>就是用来判断源码中调用<code>keys&lt;T&gt;()</code>的地方。</li></ol><p>写个测试来验证一下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/transformer.test.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; keys &#125; <span class="keyword">from</span> <span class="string">'../index'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Test transformer.'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  test(<span class="string">'Should output \"will be replaced by interface keys later\".'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> Foo &#123;&#125;</span><br><span class="line">    expect(keys&lt;Foo&gt;()).toEqual(<span class="string">'will be replaced by interface keys later'</span>); <span class="comment">// true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>测试通过说明我们的transformer生效了。</p><p>接下来要进入本文最重要的部分（请原谅我前面铺垫了这么多=。=）：编写获取interface keys的代码了。在第一部分已经列出了一个包含interface的SourceFile的AST结构，不过里面的interface的结构是平坦的，没有嵌套的层级关系。而我们的目的是能够支持具有层级关系和嵌套的interface，一个有层级关系的interface的AST结构如下：</p><p><img src="/assets/images/post_imgs/ts-ast-4.png" alt="具有层级关系的interface的AST结构"></p><p>我们需要嵌套地对interface的property做处理，完整的代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ts <span class="keyword">from</span> <span class="string">'typescript'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (program: ts.Program): ts.TransformerFactory&lt;ts.SourceFile&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">ctx: ts.TransformationContext</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (sourceFile: ts.SourceFile): ts.SourceFile =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> visitor = (node: ts.Node): ts.Node =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> ts.visitEachChild(visitNode(node, program), visitor, ctx);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> &lt;ts.SourceFile&gt; ts.visitEachChild(visitNode(sourceFile, program), visitor, ctx);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> InterfaceProperty &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  optional: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> symbolMap = <span class="keyword">new</span> Map&lt;<span class="built_in">string</span>, ts.Symbol&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> visitNode = (node: ts.Node, program: ts.Program): ts.Node =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.kind === ts.SyntaxKind.SourceFile) &#123;</span><br><span class="line">    (&lt;<span class="built_in">any</span>&gt;node).locals.forEach(<span class="function">(<span class="params">value: <span class="built_in">any</span>, key: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!symbolMap.get(key)) &#123;</span><br><span class="line">        symbolMap.set(key, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> typeChecker = program.getTypeChecker();</span><br><span class="line">  <span class="keyword">if</span> (!isKeysCallExpression(node, typeChecker)) &#123;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!node.typeArguments) &#123;</span><br><span class="line">    <span class="keyword">return</span> ts.createArrayLiteral([]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">type</span> = typeChecker.getTypeFromTypeNode(node.typeArguments[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">let</span> properties: InterfaceProperty[] = [];</span><br><span class="line">  <span class="keyword">const</span> symbols = typeChecker.getPropertiesOfType(<span class="keyword">type</span>);</span><br><span class="line">  symbols.forEach(<span class="function"><span class="params">symbol</span> =&gt;</span> &#123;</span><br><span class="line">    properties = [ ...properties, ...getPropertiesOfSymbol(symbol, [], symbolMap) ];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ts.createArrayLiteral(properties.map(<span class="function"><span class="params">property</span> =&gt;</span> ts.createRegularExpressionLiteral(<span class="built_in">JSON</span>.stringify(property))));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getPropertiesOfSymbol = (symbol: ts.Symbol, outerLayerProperties: InterfaceProperty[], symbolMap: Map&lt;<span class="built_in">string</span>, ts.Symbol&gt;): InterfaceProperty[] =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> properties: InterfaceProperty[] = [];</span><br><span class="line">  <span class="keyword">let</span> propertyPathElements = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(outerLayerProperties.map(<span class="function"><span class="params">property</span> =&gt;</span> property)));</span><br><span class="line">  <span class="keyword">const</span> property = symbol.escapedName;</span><br><span class="line">  propertyPathElements.push(property);</span><br><span class="line">  <span class="keyword">let</span> optional = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> declaration of symbol.declarations) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">undefined</span> === (&lt;<span class="built_in">any</span>&gt;declaration).questionToken) &#123;</span><br><span class="line">      optional = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> key = &lt;InterfaceProperty&gt; &#123;</span><br><span class="line">    name: propertyPathElements.join(<span class="string">'.'</span>),</span><br><span class="line">    optional,</span><br><span class="line">  &#125;;</span><br><span class="line">  properties.push(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> propertiesOfSymbol = _getPropertiesOfSymbol(symbol, propertyPathElements, symbolMap);</span><br><span class="line">  properties = [</span><br><span class="line">    ...properties,</span><br><span class="line">    ...propertiesOfSymbol,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> properties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isOutermostLayerSymbol = (symbol: <span class="built_in">any</span>): <span class="function"><span class="params">boolean</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> symbol.valueDeclaration &amp;&amp; symbol.valueDeclaration.symbol.valueDeclaration.type.members;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isInnerLayerSymbol = (symbol: <span class="built_in">any</span>): <span class="function"><span class="params">boolean</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> symbol.valueDeclaration &amp;&amp; symbol.valueDeclaration.symbol.valueDeclaration.type.typeName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _getPropertiesOfSymbol = (symbol: ts.Symbol, propertyPathElements: InterfaceProperty[], symbolMap: Map&lt;<span class="built_in">string</span>, ts.Symbol&gt;): InterfaceProperty[] =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isOutermostLayerSymbol(symbol) &amp;&amp; !isInnerLayerSymbol(symbol)) &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> properties: InterfaceProperty[] = [];</span><br><span class="line">  <span class="keyword">let</span> members: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">if</span> ((&lt;<span class="built_in">any</span>&gt;symbol.valueDeclaration).type.symbol) &#123;</span><br><span class="line">    members = <span class="function">(<span class="params">&lt;<span class="built_in">any</span>&gt;symbol.valueDeclaration</span>).<span class="params">type</span>.<span class="params">members</span>.<span class="params">map</span>(<span class="params">(<span class="params">member: <span class="built_in">any</span></span>) =&gt; member.symbol</span>);</span></span><br><span class="line"><span class="function">  &#125; <span class="params">else</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="params">const</span> <span class="params">propertyTypeName</span> = (<span class="params">&lt;<span class="built_in">any</span>&gt;symbol.valueDeclaration</span>).<span class="params">type</span>.<span class="params">typeName</span>.<span class="params">escapedText</span>;</span></span><br><span class="line"><span class="function">    <span class="params">const</span> <span class="params">propertyTypeSymbol</span> = <span class="params">symbolMap</span>.<span class="params">get</span>(<span class="params">propertyTypeName</span>);</span></span><br><span class="line"><span class="function">    <span class="params">if</span> (<span class="params">propertyTypeSymbol</span>) &#123;</span></span><br><span class="line"><span class="function">      <span class="params">if</span> (<span class="params">propertyTypeSymbol.members</span>) &#123;</span></span><br><span class="line"><span class="function">        <span class="params">members</span> = <span class="params">propertyTypeSymbol</span>.<span class="params">members</span>;</span></span><br><span class="line"><span class="function">      &#125; <span class="params">else</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="params">members</span> = (<span class="params">&lt;<span class="built_in">any</span>&gt;propertyTypeSymbol</span>).<span class="params">exportSymbol</span>.<span class="params">members</span>;</span></span><br><span class="line"><span class="function">      &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">  <span class="params">if</span> (<span class="params">members</span>) &#123;</span></span><br><span class="line"><span class="function">    <span class="params">members</span>.<span class="params">forEach</span>(<span class="params">(<span class="params">member: <span class="built_in">any</span></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      properties = [</span></span></span><br><span class="line"><span class="function"><span class="params">        ...properties,</span></span></span><br><span class="line"><span class="function"><span class="params">        ...getPropertiesOfSymbol(<span class="params">member, propertyPathElements, symbolMap</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">      ];</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span>);</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">return</span> <span class="params">properties</span>;</span></span><br><span class="line"><span class="function">&#125;;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">const</span> <span class="params">indexTs</span> = <span class="params">path</span>.<span class="params">join</span>(<span class="params">__dirname, './index.ts'</span>);</span></span><br><span class="line"><span class="function"><span class="params">const</span> <span class="params">isKeysCallExpression</span> = (<span class="params">node: ts.Node, typeChecker: ts.TypeChecker</span>): <span class="params">node</span> <span class="params">is</span> <span class="params">ts</span>.<span class="params">CallExpression</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!ts.isCallExpression(node)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> signature = typeChecker.getResolvedSignature(node);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> signature === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; declaration &#125; = signature;</span><br><span class="line">  <span class="keyword">return</span> !!declaration</span><br><span class="line">    &amp;&amp; !ts.isJSDocSignature(declaration)</span><br><span class="line">    &amp;&amp; (path.join(declaration.getSourceFile().fileName) === indexTs)</span><br><span class="line">    &amp;&amp; !!declaration.name</span><br><span class="line">    &amp;&amp; declaration.name.getText() === <span class="string">'keys'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完整的repo可以移步<a href="https://github.com/nullcc/ts-interface-keys-transformer" target="_blank" rel="noopener">ts-interface-keys-transformer</a>。</p><p>使用该transformer非常简单，首先安装<code>ttypescript</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i ttypescript</span><br></pre></td></tr></table></figure><p>然后在tsconfig.json的<code>compilerOptions</code>下增加如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">  &#123; &quot;transform&quot;: &quot;ts-interface-keys-transformer/transformer&quot; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>例子如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; keys &#125; <span class="keyword">from</span> <span class="string">'ts-interface-keys-transformer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b?: <span class="built_in">string</span>;</span><br><span class="line">  c: &#123;</span><br><span class="line">    d: <span class="built_in">number</span>;</span><br><span class="line">    e?: <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  f: Bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Bar &#123;</span><br><span class="line">  x: <span class="built_in">string</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(keys&lt;Foo&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// [ &#123; name: 'a', optional: false &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: 'b', optional: true &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: 'c', optional: false &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: 'c.d', optional: false &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: 'c.e', optional: true &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: 'f', optional: false &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: 'f.x', optional: false &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: 'f.y', optional: false &#125; ]</span></span><br></pre></td></tr></table></figure><p>在build TypeScript项目时，一般用的是<code>tsc</code>命令，现在由于使用了ttypescript，需要改用<code>ttsc</code>，这里有一个<a href="https://github.com/nullcc/ts-interface-keys-transformer-demo" target="_blank" rel="noopener">ts-interface-keys-transformer-demo</a>展示了用法。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/microsoft/TypeScript/wiki/Architectural-Overview" target="_blank" rel="noopener">TypeScript Architectural Overview</a></li><li><a href="https://github.com/microsoft/TypeScript/wiki/Compiler-Internals#transformer" target="_blank" rel="noopener">TypeScript Compiler-Internals</a></li><li><a href="https://github.com/kimamula/ts-transformer-keys" target="_blank" rel="noopener">ts-transformer-keys</a></li><li><a href="https://ts-ast-viewer.com/" target="_blank" rel="noopener">ts-ast-viewer</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文分成四个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需求和灵感&lt;/li&gt;
&lt;li&gt;TypeScript的抽象语法树简介&lt;/li&gt;
&lt;li&gt;TypeScript transformer简介&lt;/li&gt;
&lt;li&gt;编写获取TypeScript interface keys的transformer&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="编程语言" scheme="https://nullcc.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="typescript" scheme="https://nullcc.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>node.js中利用IPC和共享内存机制实现计算密集型任务转移</title>
    <link href="https://nullcc.github.io/2019/03/23/node.js%E4%B8%AD%E5%88%A9%E7%94%A8IPC%E5%92%8C%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E8%BD%AC%E7%A7%BB/"/>
    <id>https://nullcc.github.io/2019/03/23/node.js中利用IPC和共享内存机制实现计算密集型任务转移/</id>
    <published>2019-03-22T16:00:00.000Z</published>
    <updated>2022-04-15T03:41:13.025Z</updated>
    
    <content type="html"><![CDATA[<p>node.js是单进程单线程运行的，如果遇到一些计算密集型的操作应该怎么办呢？本文提供了一种思路。</p><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>最近在帮Web自动化测试开发小组编写一个基于<a href="http://allure.qatools.ru/" target="_blank" rel="noopener">Allure</a>的日志插件，这里先简要介绍一下需求的上下文和这个插件的职责。</p><p>Allure本身是一个本地的Log Reporting工具，用户可以在将test case的日志使用Allure提供的API写入本地文件，之后可以直接在本地启动Allure Web Server查看测试的运行情况，这种日志收集方式针对本地调试非常方便。</p><p>这个日志插件是基于一个现有的自研Web测试框架设计和开发的，每次跑一遍测试都称为一次Run，每个Run下有若干个test cases，每个test case下又有若干steps，且step是可以有sub steps的（就是嵌套step）。因此整个运行时的数据结构是一个树形结构，该结构如下图所示：</p><p><img src="/assets/images/post_imgs/test_run_structure.png" alt="test run structure"></p><p>在Run级别，框架提供on start run和on end run两个回调函数，在test case级别，框架也提供on start test和on end test两个回调函数，在这些回调函数内部用户可以注册自己的操作。针对steps则是需要用户提供一个针对on log handler的回调函数，每次有log输出时，框架都会调用这个函数。另外测试的执行端由selenium grid控制，具体测试运行在各个slave机器上，test case运行的并发数根据现有的资源数量可以达到几十至上百，考虑到资源有限，CI Daily Run一般设置并发数在60左右。</p><p>一个test case的工作流程如下图：</p><p><img src="/assets/images/post_imgs/test_case_flow.png" alt="test case flow"></p><p>该日志插件的需求（只列出和本文关系密切的需求）：</p><ol><li>需要在每次Run的时候将test cases和steps整理出来。</li><li>对于那些抛出异常的cases，需要判断其抛出的异常信息是否是known failure，如果是，需要在test的元数据中标明known failure issue name，并将test状态设置为Broken，否则设置为Failed。known failure是一个很长的正则表达式列表（本例中的场景如果转换成字符串大约有300+KB），这个列表将在运行test cases之前通过一个HTTP API从远端获得，程序需要遍历它来匹配异常信息判断是否是known failure。本例中由于使用了Allure这种本地日志收集工具，不可避免的需要在本地对失败case进行known failure的匹配。</li></ol><p>整理一下上面列出的信息：</p><ol><li>所有log都是以异步事件的形式发送给用户提供的”onLogHandler”的。</li><li>测试运行的并发数较大（几十至上百）。</li><li>在本地检测失败case的known failure需要遍历一个很长的正则表达式列表，这属于计算密集型操作。</li></ol><h2 id="最初实践"><a href="#最初实践" class="headerlink" title="最初实践"></a>最初实践</h2><p>最开始的解决方案相当简单粗暴，写一个方法，接受两个参数，一个是异常信息字符串，一个是known failure的正则数组。当某个test case抛出异常时，获取到它的异常信息字符串，直接调用这个方法去匹配。开发环境下因为跑的case不多，这么做完全没问题。到了测试环境压测时，发现仅仅30个并发下，很快就会Out Of Memory (下文简称OOM)。开始以为是对node进程分配的内存太小了，于是调高了分配的内存，但这也仅仅只能延缓OOM出现的时间而已。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>之后详细分析了日志，发现OOM一般出现在大量case抛出异常之后，可以想到可能是由于正则匹配是计算密集型操作，node长时间执行CPU密集型操作时，是无法去执行其各个异步回调队列中的回调函数的。前文提到当有log产生时，测试框架都会调用我们设定的onLogHanlder去处理。在并发数比较高且test case中输出log较多的时候，如果此时node进程执行大量计算操作，时间一长node的异步回调事件队列中的回调函数得不到处理，异步事件队列长度疯狂增长，这相当于把对异步回调事件的处理“饿死了”，时间一长，由于异步事件堆积内存就不够用了。这里的知识点涉及node的异步回调处理模型。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然node主进程需要处理大量异步事件，那一个可行的办法就是将这些计算密集型操作从主进程中分离出去。可以考虑使用IPC的方式，利用其它进程来处理这部分计算工作。我们可以使用node的child_process模块fork出一个子进程出来执行这些消耗CPU的操作。由于这些子进程只负责处理计算，并不负责处理异步事件，所以不用担心之前在主进程中发生异步事件“被饿死”的问题。</p><p>上文中还有一个情况还未说明，上文提到的known failure rules是需要从某个外部HTTP API中获取，最开始的做法是在初始化测试框架的时候获取一次，作为参数传递给end run hook，在end run hook中调用检测函数进行匹配。很容易想到用child_process生成一个子进程，并将这个规则列表传递给子进程的方式。首先我们不可能在每个子进程中单独去获取，因为这效率太低了，那就只能从主进程向子进程传递这个列表了。但是对命令行来说，传递这么大的参数有些不太合适，而且就算能用命令行参数传递，每次都要为300KB+的数据进行一次内存申请和复制，效率也不高。</p><p>于是想到可以采用共享内存的方式，在主进程中开辟一块专用内存区域共享给子进程，这样每个子进程在获取known failure rules的时候实际上只需要读一块已经就绪的内存。主进程利用IPC的方式将这块内存的key传递给子进程，子进程接收到主进程发送过来的内存key时，将这块内存的值读出并解析，接着直接进行匹配就好了。</p><p>共享内存方案的示意图如下：</p><p><img src="/assets/images/post_imgs/ipc_shared_memory.png" alt="ipc shared memory"></p><p>下面用主进程和子进程的两段代码进行说明：</p><p>主进程：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> shm <span class="keyword">from</span> <span class="string">'shm-typed-array'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; fork, ChildProcess, ForkOptions &#125; <span class="keyword">from</span> <span class="string">'child_process'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> KNOWN_FAILURE_RULES_API = <span class="string">'...'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchKnownFailureRules = (endpoint: <span class="built_in">string</span>): <span class="built_in">any</span>[] =&gt; &#123;</span><br><span class="line">  <span class="comment">// 从HTTP API获取known failure rule lists，代码省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseFork = (memoryKey, path: <span class="built_in">string</span>, args: ReadonlyArray&lt;<span class="built_in">string</span>&gt;, options?: ForkOptions): <span class="built_in">Promise</span>&lt;<span class="built_in">string</span> | <span class="literal">null</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>&lt;<span class="built_in">string</span> | <span class="literal">null</span>&gt;<span class="function">(<span class="params">(<span class="params">resolve, reject</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> child = fork(<span class="params">path, args, options</span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    child.on(<span class="params">'message', res =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      child.kill(<span class="params"></span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      resolve(<span class="params">res</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;</span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    child.on(<span class="params">'error', err =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      child.kill(<span class="params"></span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      reject(<span class="params">err</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;</span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    child.stderr.on(<span class="params">'data', data =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      child.kill(<span class="params"></span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      reject(<span class="params">data.toString(<span class="params"></span>)</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;</span>);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    child.on(<span class="params">'exit', (<span class="params">code, signal</span>) =&gt; &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      child.kill(<span class="params"></span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      reject(<span class="params"></span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#125;</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    child.send(<span class="params">memoryKey</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span>);</span></span><br><span class="line"><span class="function">&#125;;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">(<span class="params"><span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> knownFailureRules = <span class="keyword">await</span> fetchKnownFailureRules(<span class="params">KNOWN_FAILURE_RULES_API</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 将known failure rule lists转换成Uint16Array</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> arr = <span class="built_in">Uint16Array</span>.<span class="keyword">from</span>(<span class="params">Buffer.<span class="keyword">from</span>(<span class="params"><span class="built_in">JSON</span>.stringify(<span class="params">knownFailureRules</span>)</span>)</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 创建shared memory</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> data = shm.create(<span class="params">arr.length, 'Buffer'</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">if</span> (<span class="params">!data</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 拷贝known failure rule lists的Uint16Array至shared memory</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">for</span> (<span class="params"><span class="keyword">let</span> i = 0; i &lt; data.length; i++</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    data[i] = arr[i];</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> issueName = <span class="keyword">await</span> promiseFork(<span class="params"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      data.key,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      'match-known-failure.js', <span class="comment">// match-known-failure.js是用来匹配known failure的脚本文件</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      ['test-name', 'error-message'] <span class="comment">// 这里作为一个演示，test name和error message都是模拟数据</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">      &#123; silent: <span class="literal">true</span> &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    </span>);</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">console</span>.log(<span class="params">issueName</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125; <span class="keyword">catch</span> (<span class="params">err</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">console</span>.log(<span class="params">err</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>)<span class="params">()</span>;</span></span><br></pre></td></tr></table></figure></p><p>子进程：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// match-known-failure.js</span></span><br><span class="line"><span class="keyword">const</span> shm = <span class="built_in">require</span>(<span class="string">'shm-typed-array'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchKnownFailure = <span class="function">(<span class="params">testName, errorMessage, rules</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 使用正则表达式匹配known failure rule lists，代码省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testName = process.argv[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> errorMessage = process.argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'message'</span>, <span class="keyword">async</span> key =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取shared memory的数据</span></span><br><span class="line">  <span class="keyword">const</span> data = shm.get(key, <span class="string">'Buffer'</span>);</span><br><span class="line">  <span class="keyword">if</span> (data) &#123;</span><br><span class="line">    <span class="keyword">const</span> rules = <span class="built_in">JSON</span>.parse(data.toString());</span><br><span class="line">    <span class="keyword">const</span> res = matchKnownFailure(testName, errorMessage, rules);</span><br><span class="line">    process.send(res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>另外共享内存区域的大小也是有限制的，我们需要在程序结束时手动释放这部分内存，其中<code>sharedMemoryKey</code>是向操作系统申请共享内存时得到的一个唯一key值，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> clearSharedMemory(sharedMemoryKey) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'clear shared memory...'</span>);</span><br><span class="line">    exec(<span class="string">`ipcrm -M <span class="subst">$&#123;sharedMemoryKey&#125;</span>`</span>, (error, stdout, stderr) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">      &#125;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在进程结束时清理shared memory</span></span><br><span class="line">process.on(<span class="string">'exit'</span>,  <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> knownFailureFinder.clearSharedMemory(sharedMemoryKey);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>为了保持简单这里只列出了当’exit’事件发生的处理，其实在异常发生或者程序收到一些系统信号时也应该做这个清除处理。另外这个方案目前只在Linux和Mac OS X下测试通过，时间关系并未在Windows下做适配。</p><h2 id="共享内存方案的一些潜在问题"><a href="#共享内存方案的一些潜在问题" class="headerlink" title="共享内存方案的一些潜在问题"></a>共享内存方案的一些潜在问题</h2><p>共享内存的优点是进行进程间通信非常方便，多个进程可以共享同一块内存，省去了数据拷贝的开销，效率很高。但是在使用共享内存的时候还需要注意，共享内存本身并没有提供同步机制，一切同步操作都需要开发者自己完成。在本文的例子中，由于known failure rules对于所有子进程都是只读的，不存在修改共享内存区域数据的问题，因此也不需要任何同步机制。但在一些需要修改共享内存区域的情况下，还需要开发者手动控制同步。</p><h2 id="其他解决方案"><a href="#其他解决方案" class="headerlink" title="其他解决方案"></a>其他解决方案</h2><p>针对node的计算密集型任务的处理方法，还有很多其他解决方案，以下列举几个：</p><ol><li>编写node的C++扩展来承担这部分计算工作。</li><li>子进程部分可以改用child_process的exec或者spawn调用一些性能更好的语言写的外部程序，比如C/C++和Rust。</li><li>将子进程替换为RPC调用外部服务，但是这种方式比较适合那些传参消耗小的计算任务。</li></ol><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>之前有人问我，我不需要在本地实时分析test case的known failure，我有一个外部服务提供了专门的API可以异步地做这件事，那这种方案不就没用了吗？这个问题很好，如果已经有了外部服务做这件事，确实可以反过来只将test name和error message发送给外部服务，由外部服务进行匹配。本文旨在分享在node.js中遇到计算密集型操作时如何保证主进程不因CPU被长时间占用而阻塞异步事件队列的一种可能方案，文中的例子可能不具有代表性，不过作为一个例子它已经够用了。每个解决方案都有其自身的限制性和适用场景，将分析test case的known failure交给外部服务其实也是一种计算任务转移（当然前提是你已经有了这个外部服务），实际应用中适用哪种方案需要根据具体情况定夺。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;node.js是单进程单线程运行的，如果遇到一些计算密集型的操作应该怎么办呢？本文提供了一种思路。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="https://nullcc.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="node" scheme="https://nullcc.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>OpenResty入坑笔记(1)——搭建基本的OpenResty开发环境</title>
    <link href="https://nullcc.github.io/2019/01/18/OpenResty%E5%85%A5%E5%9D%91%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BA%E5%9F%BA%E6%9C%AC%E7%9A%84OpenResty%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://nullcc.github.io/2019/01/18/OpenResty入坑笔记(1)——搭建基本的OpenResty开发环境/</id>
    <published>2019-01-17T16:00:00.000Z</published>
    <updated>2022-04-15T03:41:13.016Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单记录了一下搭建基本的OpenResty开发环境的过程，并展示了简单的统计endpoint访问次数的功能。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>由于OpenResty基于Nginx，所以首先需要安装Nginx，这个步骤这里就不写了，网上可以找到很详细的安装过程。OpenResty的安装，可以参考<a href="http://openresty.org/en/installation.html" target="_blank" rel="noopener">官方网站的安装文档</a>，也非常容易。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>需要说明的是，由于本文是一个搭建教程，所以只会列出最基本的一些目录和文件，随着后续教程的深入，将添加更多的目录和文件。先来快速浏览一下这个demo中项目的文件结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">views-count</span><br><span class="line">|-- bin</span><br><span class="line">|   |-- start.sh</span><br><span class="line">|   |-- stop.sh</span><br><span class="line">|-- config</span><br><span class="line">|   |-- mine.types</span><br><span class="line">|   |-- nginx.conf</span><br><span class="line">|-- logs</span><br><span class="line">|   |-- access.log</span><br><span class="line">|   |-- error.log</span><br><span class="line">|-- lua</span><br><span class="line">|   |-- controller.lua</span><br><span class="line">|   |-- init.lua</span><br></pre></td></tr></table></figure><h2 id="重要目录和文件详解"><a href="#重要目录和文件详解" class="headerlink" title="重要目录和文件详解"></a>重要目录和文件详解</h2><p><code>bin</code>目录下放置的是Nginx的启动和停止的shell脚本。</p><p>start.sh内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># start.sh</span></span><br><span class="line">nginx_started=$(ps -ef | grep nginx | grep -v <span class="string">'grep'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$nginx_started</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># nginx is not started, start nginx</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">'Start Nginx...'</span></span><br><span class="line">  nginx -t -p `<span class="built_in">pwd</span>` -c config/nginx.conf</span><br><span class="line">  nginx -p `<span class="built_in">pwd</span>` -c config/nginx.conf</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># nginx is started, reload nginx</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">'Reload Nginx...'</span></span><br><span class="line">  nginx -t -p `<span class="built_in">pwd</span>` -c config/nginx.conf</span><br><span class="line">  nginx -s reload -p `<span class="built_in">pwd</span>` -c config/nginx.conf</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>stop.sh内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># stop.sh</span></span><br><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure><p><code>config</code>目录下的<code>mime.types</code>文件是Nginx会用到<code>MIME Type</code>，这个文件的内容基本是固定的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"># mime.types</span><br><span class="line">types &#123;</span><br><span class="line"></span><br><span class="line">  # Data interchange</span><br><span class="line"></span><br><span class="line">    application/atom+xml                  atom;</span><br><span class="line">    application/json                      json map topojson;</span><br><span class="line">    application/ld+json                   jsonld;</span><br><span class="line">    application/rss+xml                   rss;</span><br><span class="line">    # Normalize to standard type.</span><br><span class="line">    # https://tools.ietf.org/html/rfc7946#section-12</span><br><span class="line">    application/geo+json                  geojson;</span><br><span class="line">    application/xml                       xml;</span><br><span class="line">    # Normalize to standard type.</span><br><span class="line">    # https://tools.ietf.org/html/rfc3870#section-2</span><br><span class="line">    application/rdf+xml                   rdf;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # JavaScript</span><br><span class="line"></span><br><span class="line">    # Servers should use text/javascript for JavaScript resources.</span><br><span class="line">    # https://html.spec.whatwg.org/multipage/scripting.html#scriptingLanguages</span><br><span class="line">    text/javascript                       js mjs;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # Manifest files</span><br><span class="line"></span><br><span class="line">    application/manifest+json             webmanifest;</span><br><span class="line">    application/x-web-app-manifest+json   webapp;</span><br><span class="line">    text/cache-manifest                   appcache;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # Media files</span><br><span class="line"></span><br><span class="line">    audio/midi                            mid midi kar;</span><br><span class="line">    audio/mp4                             aac f4a f4b m4a;</span><br><span class="line">    audio/mpeg                            mp3;</span><br><span class="line">    audio/ogg                             oga ogg opus;</span><br><span class="line">    audio/x-realaudio                     ra;</span><br><span class="line">    audio/x-wav                           wav;</span><br><span class="line">    audio/x-matroska                      mka;</span><br><span class="line">    image/bmp                             bmp;</span><br><span class="line">    image/gif                             gif;</span><br><span class="line">    image/jpeg                            jpeg jpg;</span><br><span class="line">    image/jxr                             jxr hdp wdp;</span><br><span class="line">    image/png                             png;</span><br><span class="line">    image/svg+xml                         svg svgz;</span><br><span class="line">    image/tiff                            tif tiff;</span><br><span class="line">    image/vnd.wap.wbmp                    wbmp;</span><br><span class="line">    image/webp                            webp;</span><br><span class="line">    image/x-jng                           jng;</span><br><span class="line">    video/3gpp                            3gp 3gpp;</span><br><span class="line">    video/mp4                             f4p f4v m4v mp4;</span><br><span class="line">    video/mpeg                            mpeg mpg;</span><br><span class="line">    video/ogg                             ogv;</span><br><span class="line">    video/quicktime                       mov;</span><br><span class="line">    video/webm                            webm;</span><br><span class="line">    video/x-flv                           flv;</span><br><span class="line">    video/x-mng                           mng;</span><br><span class="line">    video/x-ms-asf                        asf asx;</span><br><span class="line">    video/x-ms-wmv                        wmv;</span><br><span class="line">    video/x-msvideo                       avi;</span><br><span class="line">    video/x-matroska                      mkv mk3d;</span><br><span class="line"></span><br><span class="line">    # Serving `.ico` image files with a different media type</span><br><span class="line">    # prevents Internet Explorer from displaying then as images:</span><br><span class="line">    # https://github.com/h5bp/html5-boilerplate/commit/37b5fec090d00f38de64b591bcddcb205aadf8ee</span><br><span class="line"></span><br><span class="line">    image/x-icon                          cur ico;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # Microsoft Office</span><br><span class="line"></span><br><span class="line">    application/msword                                                         doc;</span><br><span class="line">    application/vnd.ms-excel                                                   xls;</span><br><span class="line">    application/vnd.ms-powerpoint                                              ppt;</span><br><span class="line">    application/vnd.openxmlformats-officedocument.wordprocessingml.document    docx;</span><br><span class="line">    application/vnd.openxmlformats-officedocument.spreadsheetml.sheet          xlsx;</span><br><span class="line">    application/vnd.openxmlformats-officedocument.presentationml.presentation  pptx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # Web fonts</span><br><span class="line"></span><br><span class="line">    font/woff                             woff;</span><br><span class="line">    font/woff2                            woff2;</span><br><span class="line">    application/vnd.ms-fontobject         eot;</span><br><span class="line">    font/ttf                              ttf;</span><br><span class="line">    font/collection                       ttc;</span><br><span class="line">    font/otf                              otf;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # Other</span><br><span class="line"></span><br><span class="line">    application/java-archive              ear jar war;</span><br><span class="line">    application/mac-binhex40              hqx;</span><br><span class="line">    application/octet-stream              bin deb dll dmg exe img iso msi msm msp safariextz;</span><br><span class="line">    application/pdf                       pdf;</span><br><span class="line">    application/postscript                ai eps ps;</span><br><span class="line">    application/rtf                       rtf;</span><br><span class="line">    application/vnd.google-earth.kml+xml  kml;</span><br><span class="line">    application/vnd.google-earth.kmz      kmz;</span><br><span class="line">    application/vnd.wap.wmlc              wmlc;</span><br><span class="line">    application/x-7z-compressed           7z;</span><br><span class="line">    application/x-bb-appworld             bbaw;</span><br><span class="line">    application/x-bittorrent              torrent;</span><br><span class="line">    application/x-chrome-extension        crx;</span><br><span class="line">    application/x-cocoa                   cco;</span><br><span class="line">    application/x-java-archive-diff       jardiff;</span><br><span class="line">    application/x-java-jnlp-file          jnlp;</span><br><span class="line">    application/x-makeself                run;</span><br><span class="line">    application/x-opera-extension         oex;</span><br><span class="line">    application/x-perl                    pl pm;</span><br><span class="line">    application/x-pilot                   pdb prc;</span><br><span class="line">    application/x-rar-compressed          rar;</span><br><span class="line">    application/x-redhat-package-manager  rpm;</span><br><span class="line">    application/x-sea                     sea;</span><br><span class="line">    application/x-shockwave-flash         swf;</span><br><span class="line">    application/x-stuffit                 sit;</span><br><span class="line">    application/x-tcl                     tcl tk;</span><br><span class="line">    application/x-x509-ca-cert            crt der pem;</span><br><span class="line">    application/x-xpinstall               xpi;</span><br><span class="line">    application/xhtml+xml                 xhtml;</span><br><span class="line">    application/xslt+xml                  xsl;</span><br><span class="line">    application/zip                       zip;</span><br><span class="line">    text/css                              css;</span><br><span class="line">    text/csv                              csv;</span><br><span class="line">    text/html                             htm html shtml;</span><br><span class="line">    text/markdown                         md;</span><br><span class="line">    text/mathml                           mml;</span><br><span class="line">    text/plain                            txt;</span><br><span class="line">    text/vcard                            vcard vcf;</span><br><span class="line">    text/vnd.rim.location.xloc            xloc;</span><br><span class="line">    text/vnd.sun.j2me.app-descriptor      jad;</span><br><span class="line">    text/vnd.wap.wml                      wml;</span><br><span class="line">    text/vtt                              vtt;</span><br><span class="line">    text/x-component                      htc;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nginx.conf</code>是本文讨论的重点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">worker_processes 1; # 工作进程个数，一般设置成和CPU核数相同。Nginx有两种进程，一种是主进程master process，另一种是工作进程</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">worker_connections  1024; # 单个工作进程允许同时建立的最大外部连接数量，一个工作进程在建立一个连接后会同时打开一个文件描述符，该参数受限于进程最大可打开文件数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">include            mime.types;</span><br><span class="line">default_type       application/octet-stream;</span><br><span class="line">gzip               on;</span><br><span class="line">sendfile           on;</span><br><span class="line">keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line"># log format</span><br><span class="line">log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                    &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">access_log logs/access.log  main;</span><br><span class="line">error_log  logs/error.log  error;</span><br><span class="line"></span><br><span class="line">  lua_shared_dict statistics 1m; # 声明了一个1M大小的共享字典，改数据结构在所有工作进程之间共享</span><br><span class="line"></span><br><span class="line"># lua packages</span><br><span class="line">lua_package_path   &quot;lualib/?.lua;;&quot;; # Lua扩展库搜索路径，&apos;;;&apos;是默认路径</span><br><span class="line">lua_package_cpath  &quot;lualib/?.so;;&quot;;  # Lua C扩展库搜索路径，&apos;;;&apos;是默认路径</span><br><span class="line">init_by_lua_file   &quot;lua/init.lua&quot;;   # 当Nginx master进程（如果有）加载Nginx配置文件时，在全局Lua虚拟机上运行该指令指定的lua文件</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       8088;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location /lua &#123;</span><br><span class="line">      default_type text/html;</span><br><span class="line">      lua_code_cache off;  # 控制是否缓存lua代码，生产环境中强烈建议打开，否则性能会下降，开发环境为了调试方便可以关闭</span><br><span class="line">      content_by_lua_file  &quot;lua/controller.lua&quot;; # 作为内容处理程序，为每个请求执行该文件中的lua代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lua</code>目录下存放的都是lua脚本文件，<code>init.lua</code>文件用来存放一些在master进程启动并加载配置文件时执行的初始化操作，一般用来加载需要用到的第三方库，也可以用来初始化一些共享变量，下面的代码初始化了<code>statistics</code>这个共享变量中的<code>views</code>这个key的值为0，之后我们将用这个key来统计用户访问某个endpoint的次数：</p><p>init.lua:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># init.lua</span><br><span class="line"><span class="keyword">local</span> statistics = ngx.shared.statistics;</span><br><span class="line">statistics:set(<span class="string">"views"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>controller.lua:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># controller.lua</span><br><span class="line"><span class="keyword">local</span> statistics = ngx.shared.statistics;</span><br><span class="line">statistics:incr(<span class="string">"views"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">local</span> views = statistics:get(<span class="string">'views'</span>);</span><br><span class="line">ngx.say(<span class="string">'hello world '</span> .. views);</span><br></pre></td></tr></table></figure><p><code>controller.lua</code>中，每个请求都会递增<code>views</code>的值，并在结果中输出，需要特别说明的一点是，为了调试这个功能，我们必须把<code>lua_code_cache</code>设置为<code>on</code>。这是因为如果<code>lua_code_cache</code>为<code>off</code>，<code>init_by_lua</code>将在每个请求上执行，因为这种情况下，每个请求中都会去创建一个全新的Lua虚拟机而非共享同一个Lua虚拟机。在将<code>lua_code_cache</code>设置为<code>on</code>后，运行<code>sh bin/start.sh</code>，第一次访问<code>http://localhost:8088/lua</code>将输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world 1</span><br></pre></td></tr></table></figure><p>第二次访问将输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world 2</span><br></pre></td></tr></table></figure><p>每次访问都会将<code>statistics</code>共享变量中<code>views</code>的值递增1。这就实现了一个基本的统计endpoint访问次数的功能。如果后台需要统计所有的访问次数，我们只需要定期回写该值，并重置<code>statistics</code>共享变量中<code>views</code>的值为0即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在阅读了本文后，读者应该对OpenResty的项目搭建有了一个大致的了解。我们只介绍了很少的一部分概念，写了几行Lua代码就实现了一个简单的访问计数器。在之后的文章中，我们将深入OpenResty的世界，了解OpenResty的运行机制，还有很长一段路要走。</p><p>值得一提的是，到现在为止我们的工作还没有涉及任何应用服务器。这就是OpenResty的作用所在：将和业务无关的事情剥离出整个应用服务层，应用服务层可以专注于做业务相关的事情。在之后还可以看到，我们可以使用Lua实现更多这类“公共功能”，比如读缓存、LRU Cache、写日志、应用防火墙、模板渲染、静态文件合并、负载均衡、流量控制等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单记录了一下搭建基本的OpenResty开发环境的过程，并展示了简单的统计endpoint访问次数的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="web后端" scheme="https://nullcc.github.io/categories/web%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="nginx" scheme="https://nullcc.github.io/tags/nginx/"/>
    
      <category term="openresty" scheme="https://nullcc.github.io/tags/openresty/"/>
    
  </entry>
  
  <entry>
    <title>AOP在JavaScript和TypeScript中的应用</title>
    <link href="https://nullcc.github.io/2019/01/11/AOP%E5%9C%A8JavaScript%E5%92%8CTypeScript%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://nullcc.github.io/2019/01/11/AOP在JavaScript和TypeScript中的应用/</id>
    <published>2019-01-10T16:00:00.000Z</published>
    <updated>2022-04-15T03:41:13.013Z</updated>
    
    <content type="html"><![CDATA[<p>本文将简单聊聊AOP在JavaScript和TypeScript中的应用。本文是之前一篇文章&lt;AOP_in_JavaScript_and_TypeScript&gt;的中文版。</p><a id="more"></a><h2 id="AOP概览"><a href="#AOP概览" class="headerlink" title="AOP概览"></a>AOP概览</h2><p>Aspect Oriented Programming (AOP)，中文意思是“面向切面编程”。AOP的作用用一句话概括就是将业务逻辑和非业务逻辑的代码分开，减少它们的耦合性。</p><p>这么说比较抽象，我们具体点说，在使用selenium-webdriver做一些web自动化测试时，我们经常需要执行一些辅助的操作，比如记录日志、截屏保存等。这些操作本身和测试的业务逻辑没有强关联性，毕竟没有记录日志的操作我们的自动化测试代码也能运行，但是我们大部分时候也确实需要这些辅助操作。我们希望在业务建模阶段不需要考虑这些辅助函数的事情。</p><p>还有一个例子比如我们要在自动化测试的每个步骤后截屏保存，并记录每个步骤的耗时。最简单的做法就是把截屏代码和计算耗时的代码嵌入到每个步骤中。但这么做的问题也显而易见，step多了以后代码难以维护。AOP则可以优雅地解决这类问题。</p><h2 id="AOP和OOP的对比"><a href="#AOP和OOP的对比" class="headerlink" title="AOP和OOP的对比"></a>AOP和OOP的对比</h2><p>大部分人对面向对象编程(OOP)比较熟悉。当我们获得一个需求时，首先要分析需求，然后抽取出一些领域模型。每个领域模型都有它的属性和方法。人们使用封装、组合、继承、多态和设计模式来以OOP的方式构建软件。</p><p>如果你有过用OOP的方式构建软件的经历就会发现OOP是对静态事物建模的。换句话说，OOP是比较擅长的领域是对名词建模。比如，我们有一个Employee类，它有如下属性：age、title和department，还有一些方法：work、takeABreak和loginAdminSystem。属性用来描述对象的特征，方法则决定了对象能够执行什么样的操作。我们可以写出下面这样的面向对象代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> age: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> title: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> department: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, title: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">    <span class="keyword">this</span>.department = department;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> work() &#123;</span><br><span class="line">    <span class="comment">// code for working...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> takeABreak() &#123;</span><br><span class="line">    <span class="comment">// code for taking a break...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> loginAdminSystem() &#123;</span><br><span class="line">    <span class="comment">// code for logining admin system, it's a sensitive operation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> employee = <span class="keyword">new</span> Employee(<span class="string">'Bob'</span>, <span class="number">35</span>, <span class="string">'Software Development Engineer'</span>, <span class="string">'Devlopment'</span>);</span><br><span class="line">employee.work();</span><br><span class="line">employee.takeABreak();</span><br></pre></td></tr></table></figure><p>上面的代码都是和Employee类强关联的业务逻辑，毫无疑问，OOP非常适合做这类描述对象和其行为的事情。</p><p>但有时我们希望能加入更多“动态”东西，比如我们希望在用户执行一些敏感操作的时候记录日志。如果使用OOP来实现，就必须修改相关敏感操作的代码，加入记录日志的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> loginAdminSystem() &#123;</span><br><span class="line">  <span class="comment">// added: code for logging some information</span></span><br><span class="line">  <span class="comment">// code for logining admin system</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这段代码可以工作，但并不优雅。实际上这种做法违反了OCP(开闭原则)。记录日志的操作和这个敏感操作并无强关联性，它只是辅助性的代码。因此最好不要为了加入一个记录日志的辅助功能而去修改业务逻辑代码。</p><p>如何处理这种情况？可以尝试下AOP。简单来说，可以在特定操作前后暴露两个切面：一个在特定操作前，另一个在特定操作后，然后再运行时动态地将其他辅助性函数织入进去。因此AOP实际上是针对动词的。通过将OOP和AOP相结合，我们的代码将变得更加优雅，且有良好的扩展性。</p><p>下面是一个简单的例子：函数包装。假设我们有一个函数”op”，我们将一些日志操作加入其前后：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> op = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'executing op...'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oriOp = op;</span><br><span class="line"></span><br><span class="line">op = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'before op...'</span>);</span><br><span class="line">  oriOp();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'after op...'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次我们不是修改原函数而是包装它。</p><p>上面的例子只是一种非常简单的情形，实际项目中的AOP代码要比上面的示例复杂得多。一般来说我们需要一些“元编程”技术来实现AOP。但基本原则和本质和上面的代码是相似的。值得一提的是，AOP是一种编程理念，并不局限于某种编程语言，大部分编程语言都可以以AOP的方式来编程。</p><p>下面将针对之前提到的，在Web自动化测试中加入如记录日志、截图保存和计算步骤耗时等辅助性功能，给出几个具体的实现来详细说明如何在JavaScript和TypeScript中实现AOP。</p><h2 id="解决方案1-——-简单的方法钩子"><a href="#解决方案1-——-简单的方法钩子" class="headerlink" title="解决方案1 —— 简单的方法钩子"></a>解决方案1 —— 简单的方法钩子</h2><p>看过上面的介绍后，最直接的想法就是，可以将那些业务方法用前置/后置处理器一一包装起来，也就是加入方法钩子。解决方案1使用方法钩子（前置/后置动作）来将原方法包装成一个新方法，我们把辅助性功能放在钩子中。</p><p>代码在<a href="https://github.com/nullcc/ts-aop-example/blob/master/src/driver/methodHook/base.ts" target="_blank" rel="noopener">base driver</a>和<a href="https://github.com/nullcc/ts-aop-example/blob/master/src/driver/methodHook/methodHook.ts" target="_blank" rel="noopener">method hook driver</a>.</p><p>这种方案有一个明显的缺点：如果前置方法和后置方法之间有关联，将难以处理。比如如果要记录一个步骤的耗时，前置方法和后置方法是这样的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before action</span></span><br><span class="line"><span class="keyword">const</span> recordStartTime = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="keyword">return</span> start;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after action</span></span><br><span class="line"><span class="keyword">const</span> recordEndTime = <span class="keyword">async</span> start =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="keyword">const</span> consume = end - start;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`time consume: <span class="subst">$&#123;consume&#125;</span>ms`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>且其中需要用到一个”registerHooksForMethods”方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> registerHooksForMethods(</span><br><span class="line">    methods: <span class="built_in">string</span>[],</span><br><span class="line">    beforeAction: <span class="built_in">Function</span>,</span><br><span class="line">    afterAction: <span class="built_in">Function</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    methods.forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> originalMethod = self[method]; <span class="comment">// original method reference</span></span><br><span class="line">      <span class="keyword">if</span> (originalMethod) &#123;</span><br><span class="line">        self[method] = <span class="keyword">async</span> (...args) =&gt; &#123; <span class="comment">// wrap original method</span></span><br><span class="line">          <span class="keyword">const</span> beforeActionRes = <span class="keyword">await</span> beforeAction();</span><br><span class="line">          <span class="keyword">const</span> methodRes = <span class="keyword">await</span> originalMethod.call(self, ...args);</span><br><span class="line">          <span class="keyword">await</span> afterAction(beforeActionRes, methodRes);</span><br><span class="line">          <span class="keyword">return</span> methodRes;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>registerHooksForMethods方法接受三个参数，用来将一组原方法分别使用前置/后置处理器包装一组对应的新方法。这种实现其实是比较不优雅的，而且很难扩展。因此我们需要继续寻找更好的方案。</p><h2 id="解决方案2-———-静态洋葱模型"><a href="#解决方案2-———-静态洋葱模型" class="headerlink" title="解决方案2 ——— 静态洋葱模型"></a>解决方案2 ——— 静态洋葱模型</h2><p>静态洋葱模型受到<a href="https://koajs.com/" target="_blank" rel="noopener">Koa</a>的启发，这个模型很有意思，对一个方法的执行流程就像一个箭头通过一整颗洋葱：</p><p><img src="/assets/images/post_imgs/koa_onion.png" alt="Koa middileware onion model"></p><p>代码在<a href="https://github.com/nullcc/ts-aop-example/blob/master/src/driver/staticOnion/base.ts" target="_blank" rel="noopener">base driver</a> and <a href="https://github.com/nullcc/ts-aop-example/blob/master/src/driver/staticOnion/staticOnion.ts" target="_blank" rel="noopener">static onion driver</a>.</p><p>洋葱内部每一层都被上面一层所完全包裹，我们将业务方法置于洋葱的最内部，到达业务方法和离开业务方法都将穿越其外层，而且除了业务方法之外，每层都会被穿越两次。每一层都是一个”中间件”。</p><p>静态洋葱模型比刚才的钩子方法要好不少，这里使用装饰器方法来实现它：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decorator</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> webDriverMethod = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, methodName: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> desc = &#123;</span><br><span class="line">      value: <span class="string">"webDriverMethod"</span>,</span><br><span class="line">      writable: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target[methodName], <span class="string">"__type__"</span>, desc);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in BaseWebDriver class, a web driver method</span></span><br><span class="line"><span class="meta">@webDriverMethod</span>()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> findElement(</span><br><span class="line">  by: By,</span><br><span class="line">  ec: <span class="built_in">Function</span> = until.elementLocated,</span><br><span class="line">  timeout: <span class="built_in">number</span> = <span class="number">3000</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">this</span>.webDriver.wait(ec(by), timeout);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.webDriver.findElement(by);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>use</code>方法来增加一个中间件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> use(middleware) &#123;</span><br><span class="line">  <span class="keyword">const</span> webDriverMethods = <span class="keyword">this</span>.getWebDriverMethods();</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> method of webDriverMethods) &#123;</span><br><span class="line">    <span class="keyword">const</span> originalMethod = <span class="keyword">this</span>[method];</span><br><span class="line">    <span class="keyword">if</span> (originalMethod) &#123;</span><br><span class="line">      <span class="keyword">this</span>[method] = <span class="keyword">async</span> (...args) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> result;</span><br><span class="line">        <span class="keyword">const</span> ctx = &#123;</span><br><span class="line">          methodName: method,</span><br><span class="line">          args</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">await</span> middleware(ctx, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">          result = <span class="keyword">await</span> originalMethod.call(self, ...args);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// check this: we must decorate new method every time when adding a middleware</span></span><br><span class="line">      <span class="keyword">this</span>.decorate(<span class="keyword">this</span>[method]); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> decorate(method) &#123;</span><br><span class="line">  <span class="keyword">const</span> desc = &#123;</span><br><span class="line">    value: <span class="string">"webDriverMethod"</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(method, <span class="string">"__type__"</span>, desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态洋葱模型有个小缺点：每增加一个中间件，都必须手动在相关函数上面增加一个装饰器。为了偷懒，我们还可以实现得更动态一些，这就有个方案3。</p><h2 id="解决方案3-——-动态洋葱模型"><a href="#解决方案3-——-动态洋葱模型" class="headerlink" title="解决方案3 —— 动态洋葱模型"></a>解决方案3 —— 动态洋葱模型</h2><p>代码在<a href="https://github.com/nullcc/ts-aop-example/blob/master/src/driver/dynamicOnion/base.ts" target="_blank" rel="noopener">base driver</a> and <a href="https://github.com/nullcc/ts-aop-example/blob/master/src/driver/dynamicOnion/dynamicOnion.ts" target="_blank" rel="noopener">dynamic onion driver</a>.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> DynamicOnionWebDriver <span class="keyword">extends</span> BaseWebDriver &#123;</span><br><span class="line">  <span class="keyword">protected</span> webDriver: WebDriver;</span><br><span class="line">  <span class="keyword">private</span> middlewares = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">webDriver</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(webDriver);</span><br><span class="line">    <span class="keyword">const</span> methods = <span class="keyword">this</span>.getWebDriverMethods();</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> method of methods) &#123;</span><br><span class="line">      <span class="keyword">const</span> desc = &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">          <span class="keyword">if</span> (methods.includes(method) &amp;&amp; <span class="keyword">this</span>.compose) &#123;</span><br><span class="line">            <span class="keyword">const</span> ctx = &#123; <span class="comment">// put some information in ctx if necessary</span></span><br><span class="line">              methodName: method,</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> originFn = <span class="keyword">async</span> (...args) =&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">this</span>.methodMap[method].call(self, ...args);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> fn = <span class="keyword">this</span>.compose();</span><br><span class="line">            <span class="keyword">return</span> fn.bind(<span class="literal">null</span>, ctx, originFn.bind(self));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.methodMap[method].bind(<span class="keyword">this</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">          <span class="keyword">this</span>[method] = value;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, method, desc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> use(middleware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> middleware !== <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Middleware must be a function!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.middlewares.push(middleware);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> compose() &#123;</span><br><span class="line">    <span class="keyword">const</span> middlewares = <span class="keyword">this</span>.middlewares;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next, ...args) =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> res;</span><br><span class="line">      <span class="keyword">const</span> dispatch = <span class="keyword">async</span> i =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> fn = middlewares[i];</span><br><span class="line">        <span class="keyword">if</span> (i === middlewares.length) &#123;</span><br><span class="line">          fn = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (i === middlewares.length) &#123;</span><br><span class="line">            res = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(fn.call(self, ...args));</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(ctx, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">await</span> dispatch(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态洋葱模型要比之前两个方案复杂很多，我们使用<code>Object.defineProperty</code>来定义自己的getter，这些getter将对每个使用了<code>webDriverMethod</code>装饰器的方法生效。<code>compose</code>方法非常重要，它用来将所有中间件和原函数组合到一起，compose是在<a href="https://github.com/koajs/compose/blob/master/index.js" target="_blank" rel="noopener">koa-compose</a>的核心代码基础上修改得来的。getter将调用compose函数来将原函数和所有中间件包装成一个新函数返回。有了这种动态包装机制，就不需要每次增加中间的时候都要手动在原函数上添加装饰器了。</p><p>动态洋葱模型的代码比较难以理解，但绝对值得我们好好去学习。</p><p>顺便一提，本文中除了方法钩子这个名称外，静态洋葱模型和动态洋葱模型都是我自己发明的，如果读者有更好的名字，可以和我交流。</p><h2 id="示例Repo"><a href="#示例Repo" class="headerlink" title="示例Repo"></a>示例Repo</h2><p><a href="https://github.com/nullcc/ts-aop-example" target="_blank" rel="noopener">ts-aop-example</a></p><h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm test</span><br></pre></td></tr></table></figure><h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><ul><li><a href="https://www.zhihu.com/question/24863332" target="_blank" rel="noopener">什么是面向切面编程AOP</a></li><li><a href="https://koajs.com/" target="_blank" rel="noopener">Koa Web Framework</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty()</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将简单聊聊AOP在JavaScript和TypeScript中的应用。本文是之前一篇文章&amp;lt;AOP_in_JavaScript_and_TypeScript&amp;gt;的中文版。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="https://nullcc.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="js" scheme="https://nullcc.github.io/tags/js/"/>
    
      <category term="aop" scheme="https://nullcc.github.io/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>RxJS入坑笔记(一)——基础知识</title>
    <link href="https://nullcc.github.io/2019/01/01/RxJS%E5%85%A5%E5%9D%91%E7%AC%94%E8%AE%B0(%E4%B8%80)%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://nullcc.github.io/2019/01/01/RxJS入坑笔记(一)——基础知识/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2022-04-15T03:41:13.020Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个系列文章，主要记录我自己学习RxJS时的学习笔记和遇到的问题。本文关注RxJS实践环境的搭建和一些基础知识。</p><a id="more"></a><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><p>学习一门编程技术最好的方式是一边看教程一边实践，RxJS也不例外。让我们快速搭建一个开发环境来写一些代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app rxjs-samples --scripts-version=react-scripts-ts</span><br></pre></td></tr></table></figure><p>我们使用<a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a>这个脚手架来搭建一个React编程环境，并使用TypeScript来编写代码。</p><p>接着安装RxJS的一些依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add rxjs rxjs-compat --save</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add tslint --dev</span><br></pre></td></tr></table></figure><p>现在可以直接运行下列命令在开发环境中运行我们的应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure><p>看到一个旋转的React的Logo说明一切正常。</p><h2 id="快速开始——使用GitHub-API获取用户信息"><a href="#快速开始——使用GitHub-API获取用户信息" class="headerlink" title="快速开始——使用GitHub API获取用户信息"></a>快速开始——使用GitHub API获取用户信息</h2><p>这里并不打算从一个传统的”Hello world”例子开始，而是直接展示RxJS相较于传统事件响应编程的不同之处。这个示例很简单，提供一个输入框，用户在输入框中输入内容后，将使用输入内容在GitHub API中搜索用户信息，并将用户信息展示出来。这里面还有两个要求：</p><ol><li>控制1秒内只响应一次输入框的变化</li><li>只有输入框的内容有变化时才调用API获取用户信息</li></ol><p>如果使用传统的事件响应式编程，代码大概是下面这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> usernameInput = <span class="built_in">document</span>.querySelector(<span class="string">'#username'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lastInputValue = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">let</span> lastInputTime = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">usernameInput.addEventListener(<span class="string">'input'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!lastInputTime) &#123;</span><br><span class="line">    lastInputTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="keyword">const</span> interval = now - lastInputTime;</span><br><span class="line">  <span class="keyword">const</span> inputValue = event[<span class="string">'target'</span>][<span class="string">'value'</span>];</span><br><span class="line">  lastInputTime = now;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (interval &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (lastInputValue !== inputValue) &#123;</span><br><span class="line">        lastInputValue = inputValue;</span><br><span class="line">        getUser(inputValue);</span><br><span class="line">      &#125;</span><br><span class="line">      lastInputTime = <span class="literal">null</span>;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (inputValue !== lastInputValue) &#123;</span><br><span class="line">      lastInputValue = inputValue;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      getUser(inputValue);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function"><span class="params">username</span> =&gt;</span> &#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    type: <span class="string">'GET'</span>,</span><br><span class="line">    url: <span class="string">`https://api.github.com/users/<span class="subst">$&#123;username&#125;</span>`</span>,</span><br><span class="line">    success: <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> pre = <span class="built_in">document</span>.createElement(<span class="string">'pre'</span>);</span><br><span class="line">      pre.innerHTML = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">'results'</span>).appendChild(pre);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看了这段代码有何感想？我说几点我的感想，首先控制流对业务代码的侵入性高，不易扩展。且代码冗长不简洁，还需要引入一些外部变量。虽然也实现了想要的功能，但总感觉不是做这件事的最佳方式。</p><p>再来看看用RxJS的实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> usernameInput = <span class="built_in">document</span>.getElementById(<span class="string">'username'</span>) <span class="keyword">as</span> FromEventTarget&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">fromEvent(usernameInput, <span class="string">'input'</span>)</span><br><span class="line">  .map(<span class="function">(<span class="params">event: <span class="built_in">any</span></span>) =&gt;</span> event.currentTarget.value)</span><br><span class="line">  .debounceTime(<span class="number">1000</span>)</span><br><span class="line">  .distinctUntilChanged()</span><br><span class="line">  .switchMap(<span class="function">(<span class="params">username: <span class="built_in">string</span></span>) =&gt;</span> ajax(<span class="string">`https://api.github.com/users/<span class="subst">$&#123;username&#125;</span>`</span>))</span><br><span class="line">  .map(<span class="function">(<span class="params">data: <span class="built_in">any</span></span>) =&gt;</span> data.response)</span><br><span class="line">  .subscribe(</span><br><span class="line">    (val: <span class="built_in">any</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> pre = <span class="built_in">document</span>.createElement(<span class="string">'pre'</span>);</span><br><span class="line">      pre.innerHTML = <span class="built_in">JSON</span>.stringify(val);</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">document</span>.getElementById(<span class="string">'results'</span>) <span class="keyword">as</span> HTMLElement;</span><br><span class="line">      res.appendChild(pre);</span><br><span class="line">    &#125;,</span><br><span class="line">    (err: <span class="built_in">Error</span>) =&gt; &#123;</span><br><span class="line">      alert(err.message)</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>这段代码不但实现了我们想要的功能，而且还非常优雅美观。没错，这就是我们想要的。</p><h2 id="RxJS的基础概念"><a href="#RxJS的基础概念" class="headerlink" title="RxJS的基础概念"></a>RxJS的基础概念</h2><h3 id="核心数据类型"><a href="#核心数据类型" class="headerlink" title="核心数据类型"></a>核心数据类型</h3><p>下面是官方中文文档中对RxJS核心数据类型和Observable概念的简单说明：</p><p>RxJS有一个核心类型Observable，以及围绕Observable的一些其他类型：Observer、 Subscription、Subject和Operators。</p><ul><li>Observable（可观察对象）：可观察对象代表一个可观测的未来值或事件的集合。</li><li>Observer（观察者）：一个回调函数的集合，负责处理由Observable发出的值。</li><li>Subscription（订阅）：当一个Observable被订阅时才会真正得发出值。</li><li>Operators（操作符）：是一些纯函数，我们使用函数式编程的方法来处理集合。</li></ul><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">单个值</th><th>多个值</th></tr></thead><tbody><tr><td style="text-align:left">拉取</td><td style="text-align:left">Function</td><td>Iterator</td></tr><tr><td style="text-align:left">推送</td><td style="text-align:left">Promise</td><td>Observable</td></tr></tbody></table><p>当调用一个函数时，实际上是主动地拉取一个值，而使用迭代器时我们可以主动地拉取多个值。在异步编程中，Promise一旦被创建出来就会立即执行，而后的then实际上是接受Promise决议后推送过来的值，且Promise至多只能推送一个值。Observable则可以同步或异步地推送多个值。</p><h3 id="基本模式"><a href="#基本模式" class="headerlink" title="基本模式"></a>基本模式</h3><p>// todo</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="创建操作符——Creation-Operators"><a href="#创建操作符——Creation-Operators" class="headerlink" title="创建操作符——Creation Operators"></a>创建操作符——Creation Operators</h3><p>可以使用创建操作符来创建Observable，列出如下：</p><ul><li>create</li><li>empty</li><li>from</li><li>fromEvent</li><li>interval</li><li>of</li><li>range</li><li>throwError</li><li>timer</li></ul><h4 id="create操作符"><a href="#create操作符" class="headerlink" title="create操作符"></a>create操作符</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observable = Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  observer.next(<span class="number">1</span>);</span><br><span class="line">  observer.next(<span class="number">2</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    observer.next(<span class="number">3</span>);</span><br><span class="line">    observer.complete();</span><br><span class="line">    observer.next(<span class="number">5</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  observer.next(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscribe = observable.subscribe(</span><br><span class="line">  val =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>运行上面的代码会立即打印1、2和4，并在约1000毫秒后打印3，然后结束，并不会打印5。</p><p>我们可以使用create操作符很容易地创建一个Observable对象，然后随意地发出值。另外可以使用<code>observer.complete()</code>结束整个事件流。下面的例子是一个自然数发生器（周期时钟），每隔1000毫秒发出下一个自然数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observable = Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    observer.next(++num);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscribe = observable.subscribe(</span><br><span class="line">  val =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="empty操作符"><a href="#empty操作符" class="headerlink" title="empty操作符"></a>empty操作符</h4><p>empty操作符会直接使Observable直接结束：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observable = empty();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscribe = observable.subscribe(&#123;</span><br><span class="line">  next: <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;,</span><br><span class="line">  complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'complete'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>直接打印出’complete’。</p><h4 id="from操作符"><a href="#from操作符" class="headerlink" title="from操作符"></a>from操作符</h4><p>from操作符可以从一个可迭代对象(Array, Map, Promise)中创建一个Observable对象：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observable = Observable.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscribe = observable.subscribe(</span><br><span class="line">  val =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这段代码会依次打印1, 2, 3, 4, 5, 6</p><p>使用Map：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> Map();</span><br><span class="line">map.set(<span class="string">'foo'</span>, <span class="number">1</span>);</span><br><span class="line">map.set(<span class="string">'bar'</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observable = Observable.from(map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscribe = observable.subscribe(</span><br><span class="line">  val =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这段代码会打印出：</p><p>[“foo”, 1]<br>[“bar”, 2]</p><p>使用Promise：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observable = Observable.from(promise);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscribe = observable.subscribe(</span><br><span class="line">  val =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这段代码直接打印出100。</p><h4 id="fromEvent操作符"><a href="#fromEvent操作符" class="headerlink" title="fromEvent操作符"></a>fromEvent操作符</h4><p>fromEvent操作符在“快速开始”一节中已经展示了，fromEvent接受一个<code>FromEventTarget</code>对象和一个event name。</p><h4 id="interval操作符"><a href="#interval操作符" class="headerlink" title="interval操作符"></a>interval操作符</h4><p>interval操作符非常简单，接受一个以毫秒为单位的时间参数，每隔这个时间发出一个自增的数字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observable = interval(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscribe = observable.subscribe(</span><br><span class="line">  val =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="of操作符"><a href="#of操作符" class="headerlink" title="of操作符"></a>of操作符</h4><p>of操作符接收不定个数的参数，并依次发射每个参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observable = Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscribe = observable.subscribe(</span><br><span class="line">  val =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>打印出1, 2, 3。</p><p>还可以传入一些其他类型的参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observable = Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>], &#123; a:<span class="number">1</span>, b:<span class="number">2</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">10</span>); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscribe = observable.subscribe(</span><br><span class="line">  val =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这将依次打印出：</p><p>1<br>2<br>3<br>[4, 5]<br>{a: 1, b: 2}<br>ƒ () { console.log(10); }</p><h4 id="range操作符"><a href="#range操作符" class="headerlink" title="range操作符"></a>range操作符</h4><p>可以使用range操作符指定整数的起点和终点（闭区间），并依次发出这些数字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observable = Observable.range(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscribe = observable.subscribe(</span><br><span class="line">  val =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>将打印出1到10的整数。</p><h4 id="throwError操作符"><a href="#throwError操作符" class="headerlink" title="throwError操作符"></a>throwError操作符</h4><p>throw操作符发出一个异常：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observable = throwError(<span class="string">'Got an error.'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscribe = observable.subscribe(&#123;</span><br><span class="line">  next: <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;,</span><br><span class="line">  complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'complete'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这段代码将打印错误：”Got an error.”。</p><h4 id="timer操作符"><a href="#timer操作符" class="headerlink" title="timer操作符"></a>timer操作符</h4><p>timer操作符可以接受两个参数，第一个参数表示经过多长时间后发出一个值（从0开始自增），第二个参数表示之后每隔多长时间发出一个值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observable = timer(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscribe = observable.subscribe(</span><br><span class="line">  val =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这段代码将在1000毫秒后发出1。</p><p>传入第二个参数的情况：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observable = timer(<span class="number">1000</span>, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscribe = observable.subscribe(</span><br><span class="line">  val =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这段代码将在1000毫秒后发出1，之后每隔3000毫秒发出自增的数字。</p><h3 id="过滤操作符——Filtering-Operators"><a href="#过滤操作符——Filtering-Operators" class="headerlink" title="过滤操作符——Filtering Operators"></a>过滤操作符——Filtering Operators</h3><h4 id="debounceTime操作符"><a href="#debounceTime操作符" class="headerlink" title="debounceTime操作符"></a>debounceTime操作符</h4><p>debounceTime操作符会丢弃所有在指定时间间隔内发出的值。在刚才通过GitHub API获取用户信息的例子中已经演示了如何使用，这里再看下面这个计数器的例子，我们限制了用户点击”+”和”-“的速度每秒不能超过一次：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Simple Counter<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">'decrBtn'</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">'incrBtn'</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">'counter'</span>&gt;</span>0<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inceStream = <span class="built_in">document</span>.querySelector(<span class="string">'#incrBtn'</span>);</span><br><span class="line"><span class="keyword">const</span> decrStream = <span class="built_in">document</span>.querySelector(<span class="string">'#decrBtn'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = fromEvent(inceStream, <span class="string">'click'</span>).mapTo(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> s2 = fromEvent(decrStream, <span class="string">'click'</span>).mapTo(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">merge(s1, s2)</span><br><span class="line">    .debounce(<span class="function"><span class="params">()</span> =&gt;</span> timer(<span class="number">1000</span>))</span><br><span class="line">    .startWith(<span class="number">0</span>)</span><br><span class="line">    .scan(<span class="function">(<span class="params">acc, curr</span>) =&gt;</span> acc + curr)</span><br><span class="line">    .subscribe(</span><br><span class="line">      res =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> counter = <span class="built_in">document</span>.getElementById(<span class="string">'counter'</span>);</span><br><span class="line">        counter.innerText = res.toString();</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h4 id="distinctUntilChanged操作符"><a href="#distinctUntilChanged操作符" class="headerlink" title="distinctUntilChanged操作符"></a>distinctUntilChanged操作符</h4><p>distinctUntilChanged控制了只有在当前值和上一次值不同时才发出值，它经常和debounceTime操作符一起用来控制对事件流进行控制。比如我们将一个文本框的输入内容作为查询参数，构造请求发往后端。distinctUntilChanged和debounceTime配合使用可以简单有效地控制该文本框的输入事件触发发送HTTP请求的频率。GitHub API的例子很好地展示了这种用法。</p><p>下面这个例子只会发出连续相同的值序列中的第一个值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observable = Observable.from([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscribe = observable</span><br><span class="line">  .distinctUntilChanged()</span><br><span class="line">  .subscribe(</span><br><span class="line">    val =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>打印出值如下：</p><p>1<br>2<br>1<br>2<br>3</p><h4 id="filter操作符"><a href="#filter操作符" class="headerlink" title="filter操作符"></a>filter操作符</h4><p>filter操作符很好理解，给定一个过滤条件，只发出满足条件的值。下面的例子只会发出偶数值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observable = Observable.from([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscribe = observable</span><br><span class="line">  .filter(<span class="function"><span class="params">num</span> =&gt;</span> num % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">  .subscribe(</span><br><span class="line">    val =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>打印：</p><p>0<br>2<br>4<br>6<br>8</p><h4 id="take操作符"><a href="#take操作符" class="headerlink" title="take操作符"></a>take操作符</h4><p>take操作符会发出序列的前n个值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observable = Observable.from([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscribe = observable</span><br><span class="line">  .take(<span class="number">3</span>)</span><br><span class="line">  .subscribe(</span><br><span class="line">    val =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>打印：</p><p>0<br>1<br>2</p><h4 id="takeUntil操作符"><a href="#takeUntil操作符" class="headerlink" title="takeUntil操作符"></a>takeUntil操作符</h4><p>takeUntil可以时在某个事件发生时，让一个observable直接发送complete信息：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">'btn'</span>&gt;</span>Stop!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'#btn'</span>);</span><br><span class="line"><span class="keyword">const</span> btnObservable = fromEvent(btn, <span class="string">'click'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> intervalObservable = interval(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscribe = intervalObservable</span><br><span class="line">  .takeUntil(btnObservable)</span><br><span class="line">  .subscribe(&#123;</span><br><span class="line">    next: <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;,</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'complete!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>运行上面的代码，一开始将以1000毫秒为间隔自增打印自然数，当按下”Stop!”按钮时，intervalObservable结束，并打印出”complete!”。</p><h3 id="错误处理操作符——Error-Handling-Operators"><a href="#错误处理操作符——Error-Handling-Operators" class="headerlink" title="错误处理操作符——Error Handling Operators"></a>错误处理操作符——Error Handling Operators</h3><p>// todo</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个系列文章，主要记录我自己学习RxJS时的学习笔记和遇到的问题。本文关注RxJS实践环境的搭建和一些基础知识。&lt;/p&gt;
    
    </summary>
    
      <category term="web前端" scheme="https://nullcc.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="RxJS" scheme="https://nullcc.github.io/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>Web API设计实践</title>
    <link href="https://nullcc.github.io/2018/12/17/Web%20API%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5/"/>
    <id>https://nullcc.github.io/2018/12/17/Web API设计实践/</id>
    <published>2018-12-16T16:00:00.000Z</published>
    <updated>2022-04-15T03:41:13.021Z</updated>
    
    <content type="html"><![CDATA[<p>本文将讨论Web API设计的实践。</p><a id="more"></a><h2 id="Web-API的基本概念"><a href="#Web-API的基本概念" class="headerlink" title="Web API的基本概念"></a>Web API的基本概念</h2><p>Web世界在发展了一段时间后，出现了很多在线服务，这些在线服务不但本身提供一些功能，还公开了自己的Web API。第三方应用可以以Web API的方式接入这些在线服务开发自己的应用，从而也衍生出很多周边服务，甚至以这些已存在的在线服务为基础搭建自己的核心服务。</p><p>人们在Web系统中使用URI(Uniform Resource Identifier, 统一资源标识符)来定位资源，顾名思义URI是用来表示资源的，因此URI应该（或者说大部分情况下，特殊情况之后会提到）是一个名词。另外HTTP协议中定义了一些HTTP Method来表示如何操作这个URI，这是动词。HTTP Method + URI就构成了一个基本的操作：动词 + 名词。</p><h2 id="HTTP-Method-和-Endpoints-的设计"><a href="#HTTP-Method-和-Endpoints-的设计" class="headerlink" title="HTTP Method 和 Endpoints 的设计"></a>HTTP Method 和 Endpoints 的设计</h2><p>我们也经常可以在一些Web API上看到动词，例如下面这组操作用户的Web API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET http://api.example.com/v1/get_users</span><br><span class="line">POST http://api.example.com/v1/create_user</span><br><span class="line">PUT http://api.example.com/v1/update_user?id=123</span><br><span class="line">DELETE http://api.example.com/v1/delete_user?id=123</span><br></pre></td></tr></table></figure><p>拿上述的第一个Web API为例，这个URI的作用是获取用户列表，它使用了HTTP GET方法。虽然这么设计Web API也能工作，但这么设计有一些问题：首先HTTP GET和URI中的get重复了，另外一般在URI中有动词也不太符合而且也不符合URI表示资源这个原则，这个URI这样设计会好很多：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://api.example.com/v1/users</span><br></pre></td></tr></table></figure><p>其他几个Web API也有类似的问题，要么是HTTP Method和URI中的内容有重复，要么是URI包含了动词，首先这不大符合URI的设计规范，而且这么做也没有一个统一的标准，试想一下删除用户的Web API也可以设计成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE http://api.example.com/v1/remove_user?id=123</span><br></pre></td></tr></table></figure><p>如果没有统一的设计标准，一旦之后Web API数量增加，就会造成各种奇形怪状的Web API层出不穷，非常不利于维护，当然也影响美观。</p><p>下面以user资源为例，列出了各种操作对应的HTTP Method 和 Endpoints的规范设计方式：</p><table><thead><tr><th style="text-align:left">操作含义</th><th style="text-align:left">HTTP Method</th><th>Endpoint</th></tr></thead><tbody><tr><td style="text-align:left">获取用户列表</td><td style="text-align:left">GET</td><td>/users</td></tr><tr><td style="text-align:left">获取用户信息</td><td style="text-align:left">GET</td><td>/users/:id</td></tr><tr><td style="text-align:left">创建用户</td><td style="text-align:left">POST</td><td>/users</td></tr><tr><td style="text-align:left">更新用户(完整更新)</td><td style="text-align:left">PUT</td><td>/users/:id</td></tr><tr><td style="text-align:left">更新用户(部分更新)</td><td style="text-align:left">PATCH</td><td>/users/:id</td></tr><tr><td style="text-align:left">删除用户</td><td style="text-align:left">DELETE</td><td>/users/:id</td></tr></tbody></table><p>首先说说为什么这么设计，对于一个Web系统中的某种资源来说，绝大部分情况下不止一个，也就是说资源是一个集合的概念，就算只有唯一一个资源，也可以看做是集合只有一个元素的特殊情况。</p><p>比较容易让人混淆的是PUT和PATCH方法的含义，其中PUT是指“完整更新”，客户端需要发送资源的完整信息来更新这个资源，PATCH是指“部分更新”，客户端只需要发送需要更新的个别字段即可完成资源的更新。以user这个资源举例说明的话，假设user有name, age, icon三个属性，有一个id为123的user如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Foo"</span>,</span><br><span class="line">  <span class="attr">"age"</span>: <span class="number">29</span>,</span><br><span class="line">  <span class="attr">"icon"</span>: <span class="string">"http://www.example.com/icon.png</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这时我们希望更新该user的age字段为30，如果使用PUT，body需要包含所有这三个属性，其中不打算做更新的字段保持原来的值即可：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Foo"</span>,</span><br><span class="line">  <span class="attr">"age"</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">"icon"</span>: <span class="string">"http://www.example.com/icon.png</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>如果用PATCH则不必包含所有属性，只需要列出age字段即可：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"age"</span>: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，在设计Web API的 HTTP Method 和 Endpoint 有以下几个需要注意的地方：</p><ol><li>一般情况下（search之类的特殊URI例外），不应该在URI中出现动词，URI表示资源，应该是名词。</li><li>资源名称应该是复数形式。</li><li>注意根据Web API的功能选择适当的HTTP Method：GET操作不应该对服务器端资源造成任何修改，应该是幂等的。POST用来创建资源，PUT用来完整更新资源，PATCH用来局部更新资源，DELETE用来删除资源。</li><li>Endpoints中不要使用空格和需要编码的字符。</li><li>使用连字符来连接多个单词，常用的连字符有”-“和”_”，不建议使用驼峰法，因为URI本身并不区分字母大小写。</li></ol><p>另外比较常见的 Web API Endpoint 经常是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com/v1</span><br><span class="line">https://www.example.com/api/v1</span><br></pre></td></tr></table></figure><p>注意如果主机名已经有”api”了，一般path中就不需要再出现”api”，否则path中会出现”api”以示这是一个Web API Endpoint。选择哪种方式其实也没有一个唯一答案。一般来说能选则第一种尽量选第一种。</p><h3 id="URI中使用动词的特殊情况"><a href="#URI中使用动词的特殊情况" class="headerlink" title="URI中使用动词的特殊情况"></a>URI中使用动词的特殊情况</h3><p>有时候一个行为可能无法很好地映射到一个资源上，一个典型的情形是搜索，典型的Web API搜索URI是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com/v1/search?query=xxx</span><br></pre></td></tr></table></figure><p>这么设计搜索API基本是一种约定俗成的规范，像这类特殊的URI其实可以不拘泥于动词 + 名词的形式，只要这个URI能准确表达出意图，一般也没什么问题。</p><h3 id="查询参数"><a href="#查询参数" class="headerlink" title="查询参数"></a>查询参数</h3><p>分除了host, path以外，Web API还有一个很重要的组成部分：query，也就是查询参数。查询参数的作用是更详细的描述URI所指定的资源。对于是把一些参数放在path中还是放在query中，主要是看这个参数相对于资源的意义。我个人的理解是，如果这个参数具有唯一描述某个资源的能力，比如id，推荐将其放在path中。比如下面的实例描述了一个公司的某个职员：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/v1/companies/123/employees/456</span><br></pre></td></tr></table></figure><p>这里用公司ID和职员ID来唯一定位到资源。还有一种设计方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/v1/companies/123?employee_id=456</span><br></pre></td></tr></table></figure><p>这种方式当然也没问题，不过在URI的长度不是特别长的情况下，建议使用第一种方式。</p><p>有时候我们想通过一系列的参数来对资源进行查询，这一般是一种范围性的查询，不像用ID那样直接定位到唯一一个资源，此时可以使用query去设计URI。例如想要获取某个公司开发部门的，且性别为男的员工，且以名字升序排列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/v1/companies/123?department=development&amp;gender=male&amp;sort=name</span><br></pre></td></tr></table></figure><p>通过区分参数的性质来设计，我们也能让API更加优雅。</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>在获取资源列表的时候，比如获取用户列表，由于用户可能非常多，一次性获取全部用户不现实，因此很自然地会用分页来获取。分页的方案大致可以分为两种：绝对位置分页和相对位置分页。</p><h4 id="基于相对位置的分页方案"><a href="#基于相对位置的分页方案" class="headerlink" title="基于相对位置的分页方案"></a>基于相对位置的分页方案</h4><p>使用页数和每页资源个数来分页获取用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://api.example.com/v1/users?page=2&amp;limit=50&amp;sort=+name</span><br></pre></td></tr></table></figure><p>我们在查询参数中指定了page和limit，这种分页方案以页数为单位，每次获取由limit指定的个数的资源，并指定了排序规则为用户名升序排列(+为升序，-为降序)。这种分页方案很直接，但是有一个问题，由于指定了页数，也就是说我们需要skip前面几页的资源。这在数据库中的操作是这样的，首先查询出所符合查询条件的所有条目，然后skip掉指定数量的条目，skip数量=(page - 1) * limit。这时如果资源集合非常大，页数也指定得很大，数据库就需要skip掉非常多的条目，这会导致查询越来越慢。</p><p>基于页数和每页条目数的分页方案还有一种变体，就是指定offset和size，比如在基于页数和每页条目数的分页方案中的参数为page=2&amp;limit=50，也就是要跳过前面一页（50个个条目），对于offset和size的方案就是offset=50&amp;size=50。这两种方式其实质都是一样的，基于资源的相对位置来分页。</p><p>基于资源的相对位置来分页还有一个问题就是在数据插入/删除频繁的场景下回重复获取。比如记录A位于第50条，使用page=1&amp;limit=50获取时，记录A位于最后一个位置，如果在获取下一页之前，由于某种情况删除了1-50条之间的任意一条或几条，获取下一页的时候，记录A还将出现在返回列表中。</p><p>在数据量不大或者插入/删除不太频繁的场景下，基于相对位置的分页工作得还可以。但如果要彻底避免大量skip和重复获取的问题，就要使用基于绝对位置的分页方案了。</p><h4 id="基于绝对位置的分页方案"><a href="#基于绝对位置的分页方案" class="headerlink" title="基于绝对位置的分页方案"></a>基于绝对位置的分页方案</h4><p>基于绝对位置的分页不再以资源在数据库中的顺序为参考点，而是以一个能快速定位具体资源的方式做为参考点，比如主键或者任何unique key。一般资源都有主键，可以考虑用下面这种方式来获取分页的资源列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://api.example.com/v1/users?max_id=12345&amp;limit=50</span><br></pre></td></tr></table></figure><p>这种方案中的一般做法是，将当前获取到的资源列表的最后一条的unique key作为定位点，向后获取limit参数指定的数量的条目。数据库通过在这个unique key上加上合适的索引来加速这种查询，因此查询效率非常高。</p><h4 id="返回“是否还有后续数据”"><a href="#返回“是否还有后续数据”" class="headerlink" title="返回“是否还有后续数据”"></a>返回“是否还有后续数据”</h4><p>为了让前端做分页，不可避免的需要告知前端“是否还有后续数据”的信息。这里面又有两种常见的情况：</p><ol><li>需要知道总页数</li><li>不需要知道总页数</li></ol><p>需要知道总页数的情况相当常见，比如我们有很多订单，前端对订单列表做分页，用户往往需要知道“总共有多少订单”、“分页的总数”这类信息。这时服务端需要维护资源总数的信息。但是实时计算出资源总数有时候不现实（比如那些动辄上百万个的资源），这时候后端会使用一些其他技巧来实现，不过这不在本文的讨论范围内。</p><p>还有一种情况是不需要知道总页数，比如新闻资讯列表、社交媒体的timeline等。假设此时每页有N个资源，那么当后端在实际获取资源时，每次都获取N+1数量的资源，如果能获取到N+1个，就说明还有下一页，否则当前页就是最后一页。如果还有下一页，就需要把多获取的这个排除掉，只返回N个给客户端。这种方式的成本和实现难度都很低。</p><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>在使用一些需要用户身份认证的Web API时需要做授权操作，OAuth 2.0已经成为Web API授权的事实标准，OAuth 2.0 支持4种授权模式：</p><ol><li>Authorization Code</li><li>Implicit</li><li>Resource Owner Password Credentials</li><li>Client Credentials</li></ol><p>OAuth 2.0详细的信息可以查看这里<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">OAuth 2.0介绍</a>。</p><h2 id="响应数据设计"><a href="#响应数据设计" class="headerlink" title="响应数据设计"></a>响应数据设计</h2><h3 id="响应数据格式"><a href="#响应数据格式" class="headerlink" title="响应数据格式"></a>响应数据格式</h3><p>目前主流的Web API设计中，响应数据格式大部分是JSON。在比较早以前Web API中曾大量使用XML，但JSON由于其简洁易用性等优点很快被广大开发者所接受，慢慢替代了XML称为最主流的Web API响应数据格式。现在基本上很难找到哪个Web API是不支持JSON格式的，很多Web API甚至只支持JSON而不支持XML。</p><h3 id="Web-API-常用的HTTP状态码"><a href="#Web-API-常用的HTTP状态码" class="headerlink" title="Web API 常用的HTTP状态码"></a>Web API 常用的HTTP状态码</h3><p>HTTP相应状态码有五大类：1xx, 2xx, 3xx, 4xx, 5xx：</p><table><thead><tr><th style="text-align:left">HTTP响应吗类型</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">1xx</td><td style="text-align:left">信息状态码</td></tr><tr><td style="text-align:left">2xx</td><td style="text-align:left">成功状态码</td></tr><tr><td style="text-align:left">3xx</td><td style="text-align:left">重定向状态码</td></tr><tr><td style="text-align:left">4xx</td><td style="text-align:left">客户端错误状态码</td></tr><tr><td style="text-align:left">5xx</td><td style="text-align:left">服务端错误状态码</td></tr></tbody></table><p>可以参考<a href="http://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">常用的Web API HTTP状态码</a>。</p><h3 id="更详细的状态码——应用级别的状态码"><a href="#更详细的状态码——应用级别的状态码" class="headerlink" title="更详细的状态码——应用级别的状态码"></a>更详细的状态码——应用级别的状态码</h3><p>由于HTTP状态码只能表达问题的大类，在一些业务规则比较复杂的场景下，出错的时候我们希望服务端为客户端提供足够详细的出错信息，此时可以在响应体中提供应用级别的状态码和状态信息，一个参考例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"error"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"errorCode"</span>: <span class="string">"xxxx"</span>,</span><br><span class="line">  <span class="attr">"errorMessage"</span>: <span class="string">"xxxx"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设计应用级别的状态码和状态信息时也应该注意分类，并在Web API文档中详细说明各个状态码的含义。</p><h2 id="HTTP中的缓存"><a href="#HTTP中的缓存" class="headerlink" title="HTTP中的缓存"></a>HTTP中的缓存</h2><p>相比于从内存和硬盘中获取数据，网络请求的速度实在是太慢了，因此一些情况下将从服务器端获得的资源缓存起来就很关键，这能大大提高响应速度和降低服务器带宽/计算成本。</p><p>HTTP中的缓存概念大致分为两部分：</p><ul><li>过期模型</li><li>验证模型</li></ul><p>过期模型指明了一个资源何时过期，一旦资源过期，客户端就必须抛弃这个资源，重新从服务端获取。先来看看HTTP协议中和过期模型有关的响应首部：</p><ul><li>Expires</li><li>Cache-Control</li></ul><h3 id="过期模型"><a href="#过期模型" class="headerlink" title="过期模型"></a>过期模型</h3><h4 id="Expires响应首部"><a href="#Expires响应首部" class="headerlink" title="Expires响应首部"></a>Expires响应首部</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expires: Sat, 21 Dec 2019 09:32:24 GMT</span><br></pre></td></tr></table></figure><p>Expires响应首部指明了资源过期的时间点，表示资源在这个时间点之后是过期的，这是一个绝对值。需要注意的是Expires用的是服务器的时间，如果客户端和服务器时间不一致，会导致一些误差。</p><h4 id="Cache-Control响应首部"><a href="#Cache-Control响应首部" class="headerlink" title="Cache-Control响应首部"></a>Cache-Control响应首部</h4><p>Cache-Control的用法比较多，比如可以指明资源要经过多少时间后才过期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache-control: max-age=3600</span><br></pre></td></tr></table></figure><p>这指明了资源经过1小时候过期，max-age的单位是秒。</p><p>或者可以指明某个资源不需要被客户端缓存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache-control: no-store</span><br></pre></td></tr></table></figure><p>还可以指明在请求该资源时，需要先询问服务器是否有更新的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache-control: no-cache</span><br></pre></td></tr></table></figure><h3 id="验证模型"><a href="#验证模型" class="headerlink" title="验证模型"></a>验证模型</h3><p>过期模型只能通过查看响应首部中Expires和Cache-Control来得知资源的过期与否，验证模型则需要客户端向服务端询问资源的过期情况，这被称为“附带条件的请求”。客户端需要在请求中附带资源最后的更新日期(Last Modified Time)或实体标签(ETag)，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">etag: &quot;5c137a66-c1a3&quot;</span><br><span class="line">last-modified: Fri, 14 Dec 2018 09:39:50 GMT</span><br></pre></td></tr></table></figure><p>Last-Modified指明了资源最后一次更新的时间，ETag可以认为是资源的标识符，如果资源被更新了，它的标识符就会变化，这有资源的版本有点类似。</p><p>另外ETag还有“强验证”和“弱验证”两种，强验证大概是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etag: &quot;5c137a66-c1a3&quot;</span><br></pre></td></tr></table></figure><p>弱验证需要在双引号之前加上一个”W/“：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etag: W/&quot;5c137a66-c1a3&quot;</span><br></pre></td></tr></table></figure><p>二者的差别在于，强验证下，客户端缓存的资源和服务端的资源只要有任何一点不同，都会被判断为不同，需要重新从服务器获获取资源的最新数据。弱验证宽松很多，并不要求资源的完全一致，只要资源从使用意义来看没差别就不需要重新获取数据，比如一些网页上的广告信息。</p><p>这里不打算详细讲解HTTP缓存相关的内容，有需要可以参考Google和Mozilla官方关于HTTP Cache的资料：</p><ul><li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn" target="_blank" rel="noopener">http-caching</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank" rel="noopener">HTTP caching</a></li></ul><h2 id="在请求和响应中指明媒体类型和可接受的数据格式"><a href="#在请求和响应中指明媒体类型和可接受的数据格式" class="headerlink" title="在请求和响应中指明媒体类型和可接受的数据格式"></a>在请求和响应中指明媒体类型和可接受的数据格式</h2><p>使用Content-Type指明媒体类型很重要，这关系到服务端是否能正确理解客户端发来的请求和客户端能否正确解析服务端发来的响应。例如在返回JSON格式数据的Web API中，响应首部中应该指明响应的Content-Type：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">...</span><br><span class="line">content-type: application/json; charset=utf-8</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果客户端向服务端请求时所带的数据也是JSON格式的，也应该在请求头中说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /api/v1/projects HTTP/1.1</span><br><span class="line">Host: api.example.com</span><br><span class="line">Accept: application/json</span><br><span class="line">Content-Type: application/json</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Content-Type相当于客户端和服务端对数据格式的协商内容，任何一方再和另一方通信时，指明Content-Type就相当于告知对方：我给你的数据是什么媒体类型的。另一方得到这个信息后就可以才去针对这个媒体类型的操作。比如一个创建商品的接口既可以接受JSON数据也可以接受XML数据，那么客户端在发送请求时就必须指明所发送的数据是什么媒体类型的，否则服务端很可能将无法正确处理请求。相反，如果一个获取商品信息的接口同时支持返回JSON和XML两种格式的数据，那么也同样要指明响应数据的格式，否则客户端可能无法正确解析。</p><p>另外，还可以通过Accept首部指明接受何种类型的数据，比如上面的POST请求中，指明了<code>Accept: application/json</code>，这就告知服务端，客户端只能接受JSON格式的数据。</p><p>总而言之，Content-Type和Accept首部对于客户端和服务端双方通信数据的格式约定非常重要。</p><h3 id="定义私有首部"><a href="#定义私有首部" class="headerlink" title="定义私有首部"></a>定义私有首部</h3><p>有些时候HTTP协议中预定义的首部不能满足我们的需求，还需要定义私有首部。比如需要对客户端进行限速的场景，一般做法是指定一个<code>X-RateLimit-Limit</code>首部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-RateLimit-Limit: 60</span><br></pre></td></tr></table></figure><p>至于这个限速的时间单位是多少，不同应用的单位可能不一样，有使用小时的也有使用天的，需要开发者自己去查看Web API文档。</p><p>一般来说，以”X-“开头的首部是私有首部。</p><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>现代Web应用中大量使用Ajax来获取数据，但浏览器的同源策略限制了这一技术的使用。同源策略简单说就是：协议名、主机、端口号这三个数据唯一确定了一个“源”。处于安全方面的考虑，默认情况下浏览器不允许通过Ajax请求不同“源”下的资源。在服务端经过特殊配置后允许不同源的客户端请求，这称为“跨域”。但是既然是Web API，就是要公开出来给其他人用，势必需要支持跨域，否则公开没有任何意义。</p><p>其实有一种方式可以绕过浏览器同源策略（需要客户端和服务器端做一定的支持），就是<a href="http://www.runoob.com/json/json-jsonp.html" target="_blank" rel="noopener">JSONP</a>，但实际上JSONP称不上是什么特别优秀的实践，很多时候是处于无奈才使用。所以如果不是特别需要，建议不要使用JSONP。</p><p>目前Web API 主流的跨域方案是跨域资源共享<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">Cross-Origin Resource Sharing</a>，如果需要允许某个域具有访问我方服务器，可以在请求头中带上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://www.example.com</span><br></pre></td></tr></table></figure><p>如果要允许任何域访问，可以用”*”指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure><p>还有一种方式是服务器端可以在域名的根目录下，放置<code>crossdomain.xml</code>文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cross-domain-policy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">allow-access-from</span> <span class="attr">domain</span>=<span class="string">"www.example.com"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">allow-access-from</span> <span class="attr">domain</span>=<span class="string">"*.foo.com"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">allow-access-from</span> <span class="attr">domain</span>=<span class="string">"110.56.67.189"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cross-domain-policy</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果要允许任意跨域，同样可以用”*”：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cross-domain-policy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">allow-access-from</span> <span class="attr">domain</span>=<span class="string">"*"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cross-domain-policy</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">OAuth 2.0介绍</a></li><li><a href="http://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">常用的Web API HTTP状态码</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn" target="_blank" rel="noopener">http-caching</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank" rel="noopener">HTTP caching</a></li><li><a href="http://www.runoob.com/json/json-jsonp.html" target="_blank" rel="noopener">JSONP</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">CORS</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将讨论Web API设计的实践。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://nullcc.github.io/categories/Web/"/>
    
    
      <category term="API" scheme="https://nullcc.github.io/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>使用nginx实现简单的负载均衡和高可用</title>
    <link href="https://nullcc.github.io/2018/11/27/%E4%BD%BF%E7%94%A8nginx%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <id>https://nullcc.github.io/2018/11/27/使用nginx实现简单的负载均衡和高可用/</id>
    <published>2018-11-26T16:00:00.000Z</published>
    <updated>2022-04-15T03:41:13.028Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何用nginx实现后端服务集群的高可用的最简单方案。</p><a id="more"></a><p>系统情况描述：</p><p>现在有两台部署在不同机器上的后端服务实例，想要将其组成一个服务集群统一对外提供服务，并且在其中一个实例失效的情况下，集群对外还能正常提供服务。最简单的做法是用一个nginx将这两个实例组合起来，并提供一定程度上的健康检查，如果发现某个实例不可用，就暂时不将请求转发给它，直到该实例通过健康检查为止。</p><p>先来看nginx的配置文件<code>nginx.conf</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    #include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">    upstream backends &#123;</span><br><span class="line">        # 健康检查失败一次即认为实例失效，并在接下来的5s内不将请求转发到该失败实例上，其中backend1和backend2为后端服务器的地址</span><br><span class="line">        server backend1 max_fails=1 fail_timeout=5s; </span><br><span class="line">        server backend2 max_fails=1 fail_timeout=5s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://backends;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在docker中运行nginx，并使用指定的配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">   -d \</span><br><span class="line">   --net=host \</span><br><span class="line">   -p 80:80 \</span><br><span class="line">   --name nginx \</span><br><span class="line">   -v ~/docker/nginx/nginx.conf:/etc/nginx/nginx.conf:ro \</span><br><span class="line">   nginx</span><br></pre></td></tr></table></figure><p>这样配置后，这台nginx的宿主机即作为反向代理，且能在一定程度上保证后端实例高可用。当然，这里存在一个nginx失败的单点问题，一旦这个nginx实例挂了，整个服务就挂了。这可以通过为这台nginx实例的机器配置keepalived，利用IP漂移来保证nginx本身的高可用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍如何用nginx实现后端服务集群的高可用的最简单方案。&lt;/p&gt;
    
    </summary>
    
      <category term="web后端" scheme="https://nullcc.github.io/categories/web%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="高可用" scheme="https://nullcc.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JavaScript的Prototype</title>
    <link href="https://nullcc.github.io/2018/11/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E7%9A%84Prototype/"/>
    <id>https://nullcc.github.io/2018/11/12/深入理解JavaScript的Prototype/</id>
    <published>2018-11-11T16:00:00.000Z</published>
    <updated>2022-04-15T03:41:13.035Z</updated>
    
    <content type="html"><![CDATA[<p>本文将展示常常令人迷惑和误解的JavaScript的Prototype到底是什么。</p><a id="more"></a><h2 id="面向对象编程中的类"><a href="#面向对象编程中的类" class="headerlink" title="面向对象编程中的类"></a>面向对象编程中的类</h2><p>在大部分面向对象编程语言中都可以看到“类”的身影，说到“类”，进而就会谈到“继承”、“封装”和“多态”。类是一种蓝图，描述了该类的实例应该具有的数据和行为，我们会调用类的构造函数（构造函数属于类）来<code>实例化</code>一个对象出来。这个实例化出来的对象拥有类所描述的特性和行为。子类继承自父类就相当于将父类复制一份到子类中，子类和父类是相对独立的，在子类中调用或者覆盖父类方法并不会对父类造成影响。因此，类的继承本质就是<code>复制</code>。多态建立在复制这个事实基础上，表面看上去多态是由于子类实例<code>引用</code>了父类方法，实质上多态并不表示子类和父类有关联，而只能说明子类得到了父类的一份副本。</p><p>也就是说，在传统面向对象的设计理念中，类体系的核心是复制。</p><h2 id="JavaScript中的prototype"><a href="#JavaScript中的prototype" class="headerlink" title="JavaScript中的prototype"></a>JavaScript中的prototype</h2><h3 id="prototype的基本行为"><a href="#prototype的基本行为" class="headerlink" title="prototype的基本行为"></a>prototype的基本行为</h3><p>下面的代码定义了一个对象obj，它本身拥有一个属性foo，使用<code>obj.foo</code>可以获取这个属性的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo1.js</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这和prototype有什么关系呢？简单来说，在JavaScript中的某个对象上引用属性时，首先会查看这个对象本身是否拥有这个属性，如果有就返回这个属性的值。如果没有，就需要查看该对象的prototype链了。以下代码将obj的prototype关联到另一个对象上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo2.js</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj.foo); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj) === obj1); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.isPrototypeOf(obj)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj1) === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p><code>Object.create</code>会创建一个对象，并将这个对象的prototype关联到指定的对象。<br><code>Object.getPrototypeOf</code>用来获取一个对象的prototype。<br><code>isPrototypeOf</code>可以判断一个对象是否存在于另一个对象的prototype链上。</p><p>一般来说，普通对象的prototype链最终将指向<code>Object.prototype</code>，而Object.prototype的prototype是<code>null</code>。如下图所示：</p><p><img src="/assets/images/post_imgs/js-prototype1.png" alt="obj的prototype链"></p><p>上面的代码中，obj本身并没有foo这个属性，所以调用obj.foo时会沿着obj的prototype链查找foo属性，最终在obj1上找到了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo3.js</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">bar</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj2, <span class="string">'baz'</span>, &#123;</span><br><span class="line">  value: <span class="number">3</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="built_in">Object</span>.create(obj2);</span><br><span class="line">obj1.foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(obj1);</span><br><span class="line">obj.a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; a: 0 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123; foo: 1 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123; bar: 2 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.foo); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj) === obj1); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj1) === obj2); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj2) === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj2.isPrototypeOf(obj1)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.isPrototypeOf(obj)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.isPrototypeOf(obj)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，for循环部分会打印出：</p><p>a<br>foo<br>bar</p><p>可以发现遍历一个对象时会将其<code>本身</code>的属性(a)和它<code>prototype链上</code>的所有可枚举属性(foo和bar)都遍历出来。</p><p>如果只想遍历对象本身的属性，需要进行<code>hasOwnProperty</code>的判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo4.js</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">bar</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj2, <span class="string">'baz'</span>, &#123;</span><br><span class="line">  value: <span class="number">3</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="built_in">Object</span>.create(obj2);</span><br><span class="line">obj1.foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(obj1);</span><br><span class="line">obj.a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的将打印出：</p><p>a</p><h3 id="JavaScript的“类”和“构造函数”"><a href="#JavaScript的“类”和“构造函数”" class="headerlink" title="JavaScript的“类”和“构造函数”"></a>JavaScript的“类”和“构造函数”</h3><p>JavaScript中有new关键字，于是人们顺理成章地将它当做调用“构造函数”的标志：至少我们在Java/C++中是这么做的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo5.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// Foo &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="keyword">new</span> Bar(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// Bar &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>可以发现，对函数使用new会返回一个对象，即使这个函数本身没有返回任何值（此时返回的是{}）。函数内部的<code>this.x = y</code>的赋值语句会使最终返回的对象具有相应的属性。正因为这样，人们认为Foo是一个类。再看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo6.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Foo(<span class="string">'a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// Foo &#123; name: 'a' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype.constructor === Foo); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.constructor === Foo); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>我们发现由new Foo()创建出来的foo有一个constructor属性，且<code>foo.constructor</code>指向<code>Foo</code>，所以人们更加笃定foo由Foo“构造”，foo是“Foo类”的一个实例。其实Foo和普调的函数并没有区别，只是JavaScript会让所有带有new的函数调用构造一个对象并返回它。</p><p>再来看看人们怎么处心积虑地在JavaScript模拟类的行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo7.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Foo(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> Foo(<span class="string">'b'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(a) === Foo.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.getName()); <span class="comment">// a</span></span><br><span class="line"><span class="built_in">console</span>.log(a.getName === b.getName); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.getName === Foo.prototype.getName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>解释一下上面这段代码，由Foo“构造”出来的对象a有一个name属性，且a的prototype指向Foo.prototype。我们在Foo.prototype上添加一个方法getName，于是再a上执行getName()时，我们成功地通过prototype链找到Foo.prototype.getName，并调用它。接着我们又“构造”了一个对象b，然后我们发现a.getName、b.getName和Foo.prototype.getName指向的是同一个对象。</p><p>这就有点意思了，在传统的类理论中，子类会复制父类的信息，所以子类和父类的同名方法在内存中必然是两个完全不同的对象，我们知道JavaScript中的<code>===</code>是比较对象同一性的。上面的代码意味着不管“构造”出多少个“Foo类”的实例，所有实例的方法都指向Foo.prototype中的方法。这显然和传统面向对象的类理论相违背。</p><p>更神奇的是下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo8.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype.constructor === Foo); <span class="comment">// true</span></span><br><span class="line">Foo.prototype = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype.constructor === Foo); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype.constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Foo(<span class="string">'a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.constructor === Foo); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a.constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面的代码中改变了Foo.prototype，这导致了后面a.constructor不再指向Foo。也就是说，Foo.prototype的constructor属性默认情况下指向该函数自身，但如果我们在创建新对象后改变了Foo.prototype的指向，那么新对象的constructor属性并不会保持原来的指向（因为是引用）。因此，你无法通过a.constructor来确切地知晓是谁“构造”了a。</p><h3 id="proto和prototype"><a href="#proto和prototype" class="headerlink" title="proto和prototype"></a><strong>proto</strong>和prototype</h3><p>先来看一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo9.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo1 = <span class="keyword">new</span> Foo(<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(foo1) === foo1.__proto__) <span class="comment">// true, 对象的原型可以用Object.getPrototypeOf或者__proto__属性获得</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(Foo) === Foo.__proto__); <span class="comment">// true, 函数也是对象，因此也可以用Object.getPrototypeOf或者__proto__属性获得其原型</span></span><br><span class="line"><span class="built_in">console</span>.log(foo1.prototype); <span class="comment">// undefined, 只有函数对象才有prototype属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(foo1) === Foo.prototype); <span class="comment">// true, 由函数“构造”出来的对象的原型默认指向该函数的prototype属性</span></span><br><span class="line"><span class="built_in">console</span>.log(foo1.constructor === Foo) <span class="comment">// true, 由函数“构造”出来的对象的constructor属性默认指向函数本身</span></span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype.constructor === Foo) <span class="comment">// true, 函数的prototype的constructor属性默认指向函数本身</span></span><br></pre></td></tr></table></figure><p>这些错综复杂的关系可以用一张图（稍微清晰一点地）表示：</p><p><img src="/assets/images/post_imgs/js-prototype2.png" alt="构造函数中的原型链"></p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>看下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo10.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo <span class="keyword">instanceof</span> Foo); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>人们往往希望使用<code>instanceof</code>来判断一个对象是否是某个“类”的实例，从字面意思看来这是很直白的。但instanceof回答的问题是，在foo的prototype链中是否有一个对象指向Foo.prototype。通过上面的图我们知道，通过调用<code>new Foo()</code>得到foo，因此foo的原型是Foo.prototype。所以这里结果是true。但是instanceof只能用于对象和函数之间，不能用于对象与对象之间。举个例子，如果是下面这样的代码，用instanceof是不行的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo11.js</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(obj1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> obj1); <span class="comment">// TypeError: Right-hand side of 'instanceof' is not callable</span></span><br></pre></td></tr></table></figure><p>我们用Object.create创建了一个对象，并将该对象prototype指向obj1，如果要判断一个对象的prototype是否是另一个对象，需要使用<code>isPrototypeOf</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo12.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype.isPrototypeOf(foo)); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.isPrototypeOf(obj)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>仔细想想可以发现，实际上根本不存在我们以为的“x是y的实例”这种关系，也就是传统意义上的instanceof，对象间只有引用关系，如果要表示某个对象在另一个对象的prototype链上（不论是普通对象还是函数），最好使用isPrototypeOf。</p><h3 id="JavaScript对象间关系的本质——对象关联"><a href="#JavaScript对象间关系的本质——对象关联" class="headerlink" title="JavaScript对象间关系的本质——对象关联"></a>JavaScript对象间关系的本质——对象关联</h3><p>通过上面的一些例子，我们发现JavaScript中根本不存在所谓的“类继承”机制。对象间是引用、关联的关系。理解了这个事实，很多JavaScript的“神奇”行为也很好解释了，很多人之所以会对JavaScript的“类继承”机制一头雾水，其实完全是因为以错误的方式去尝试理解它。现在再来思考<code>Object.create</code>带来了什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo13.js</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; </span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  foo: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(obj1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.foo()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>obj的prototype是obj1，执行obj.a或者obj.foo()其实是在使用obj的prototype上的属性和方法，这其实是一种<code>委托</code>，而委托本质上是因为对象关联。为了避免属性屏蔽或者冲突，建议在对象上显式地使用委托：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo14.js</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; </span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  foo: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(obj1);</span><br><span class="line">obj.doFoo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.foo();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.doFoo()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>显式地使用委托也很简单，在对象上新建一个方法，在方法内部使用this来调用委托方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将展示常常令人迷惑和误解的JavaScript的Prototype到底是什么。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="https://nullcc.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="js" scheme="https://nullcc.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Node.js异步编程</title>
    <link href="https://nullcc.github.io/2018/11/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Node.js%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>https://nullcc.github.io/2018/11/04/深入理解Node.js异步编程/</id>
    <published>2018-11-03T16:00:00.000Z</published>
    <updated>2022-04-15T03:41:13.035Z</updated>
    
    <content type="html"><![CDATA[<p>本文将深入解析node.js的异步世界（本文比较长，请准备好瓜子和可乐）。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>为了保证文章内所列代码能够正确运行，建议安装babel： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-cli -g</span><br></pre></td></tr></table></figure><h2 id="写在阅读之前"><a href="#写在阅读之前" class="headerlink" title="写在阅读之前"></a>写在阅读之前</h2><p>开发者需要注意区分JavaScript和JavaScript运行时（宿主环境）这两个概念。严格来说，JavaScript单纯指这门编程语言，没有其他附加的含义。对于宿主环境，如果是Web前端开发，默认是浏览器，如果是Node.js，则指的是node.js运行时。不同的宿主环境有很大区别，比如浏览器和node.js的事件循环机制就有所区别。另外像<code>console</code>这个对象（没错，就是你经常用的console.log的那个console）也是由宿主环境提供的，它并不是JavaScript的一部分。</p><p>需要特别说明的是，本文的事件循环部分主要探讨的宿主环境是node.js，异步编程部分中的绝大多数内容都适用于目前常见的宿主环境，如浏览器、Node.js等。要注意的是虽然不同宿主环境有很多相似的地方，但是我们还是要注意区分他们的不同点。</p><h2 id="并发模型和事件循环"><a href="#并发模型和事件循环" class="headerlink" title="并发模型和事件循环"></a>并发模型和事件循环</h2><p>由于JavaScript是单线程运行的，因此它天生是异步的。试想如果一个单线程的程序是同步执行的，一旦有调用阻塞线程，线程就挂起了。对应到现实中的会发现，浏览器因为一个HTTP请求而无法响应用户操作。在使用JavaScript时（不论在哪个宿主环境），都要牢记它是单线程运行的，这个概念非常重要。</p><p>大部分使用node.js的人都被它的“异步非阻塞”特性所吸引，一些I/O密集型的应用在使用异步非阻塞的实现后，性能可以有很大的提升，而且应用所占用的资源还比原来采用同步方式编程的低得多。在语言级别，由于是单线程运行，所以完全不存在线程间同步这种麻烦事。</p><p>Node.js的并发模型基于事件循环(Event Loop)。下面是一个最简单的事件循环模型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (queue.waitForMessage()) &#123;</span><br><span class="line">  queue.processNextMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个无限while循环，当事件队列中有未处理的消息时，就取出一个消息来处理，否则就一直等待直到有队列中有消息。</p><p>为了解释Node.js的事件循环，这里直接引用我翻译的Node.js官方文档中对其事件循环的描述<a href="/2018/10/11/[译]深入理解Node.js的事件循环、定时器和process.nextTick/">(译)深入理解Node.js的事件循环、定时器和process.nextTick()</a>。</p><h2 id="JavaScript异步编程的几种常见模式"><a href="#JavaScript异步编程的几种常见模式" class="headerlink" title="JavaScript异步编程的几种常见模式"></a>JavaScript异步编程的几种常见模式</h2><ul><li>回调函数</li><li>Promise</li><li>Generation Function</li><li>async/await</li><li>Event</li></ul><h3 id="回调函数-callback"><a href="#回调函数-callback" class="headerlink" title="回调函数(callback)"></a>回调函数(callback)</h3><p>回调函数是最基本的一种异步调用模式，回调函数会在异步操作完成之后被调用。下面试一个简单的Node.js中异步读取文件的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readFileCallback.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'a.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> babel-node readFile.js</span></span><br><span class="line">foo</span><br><span class="line">file a content</span><br></pre></td></tr></table></figure><p><code>foo</code>被先打印出来，接着等文件读取完毕，打印出文件内容<code>file a content</code>，可以看到读取文件这个操作并不会阻塞当前进程。因为Node.js运行时直接从<code>fs.readFile</code>中返回，继续往下运行。</p><p>再看一个定时器的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timerCallback.js</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setTimeout(fn, <span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>运行这段代码会发现运行后控制台立即打印出2，接着在大约3000毫秒后，控制台打印出1。这个例子再次体现了Node.js的异步特性。</p><p>我们再来看看在同步模式中写代码的场景。假设用户想要读取一个文件，由于读取文件（内部是一个系统调用，需要陷入内核）是一个耗时操作（文件比较大或者使用机械硬盘的时候的尤其耗时），因此在同步模式下，这个读取操作会阻塞当前进程（假设目前没有使用多线程），当前进程将被挂起。当前进程的其他代码在该读取操作完成之前无法被执行，如果这个文件的读取需要耗费1秒，则当前进程就要被阻塞1秒，也就是说宝贵的CPU资源在程序运行的时候要被白白浪费1秒。不要小看这1秒，1秒的CPU资源在程序在运行的时候是非常宝贵的。</p><p>如果我们想要使用回调函数的方式<code>按顺序</code>读取两个文件，再打印出它们的内容就要嵌套使用回调函数了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nestReadFileCallback.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a file content: "</span> + data);</span><br><span class="line">  fs.readFile(<span class="string">'b.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"b file content: "</span> + data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> babel-node nestCallback.js</span></span><br><span class="line">a file content: file a content</span><br><span class="line">b file content: file b content</span><br></pre></td></tr></table></figure><p>这里为了达到<code>异步串行</code>执行的目的，我们使用了嵌套回调。代码开始有点不清爽了，想象一下如果多个异步调用需要按一定顺序串行执行，例如后一次异步调用依赖前一次异步调用的数据，代码会是这个样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// callback hell</span></span><br><span class="line">doSomethingAsync1(<span class="function">(<span class="params">err1, data1</span>) =&gt;</span> &#123;</span><br><span class="line">  doSomethingAsync2(data1, (err2, data2) =&gt; &#123;</span><br><span class="line">    doSomethingAsync3(data2, (err3, data3) =&gt; &#123;</span><br><span class="line">    doSomethingAsync4(data3, (err4, data4) =&gt; &#123;</span><br><span class="line">    doSomethingAsync5(data4, (err5, data5) =&gt; &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果业务逻辑比较复杂，维护这种代码简直是噩梦，开发者把这种代码叫做callback hell（回调地狱）。那怎么办呢？我们可以使用Promise。</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>ES 6中原生提供了Promise对象，Promise对象代表<code>某个未来才会知道结果的事件</code>(一般是一个异步操作)，换句话说，一个Pomise就是一个代表了异步操作最终完成或者失败的对象。Promise本质上是一个绑定了回调的对象，而不是像callback异步编程那样直接将回调传入函数内部。</p><p>Promise对外提供了统一的API，可供进一步处理。Promise的<code>最终</code>状态有两种：<code>fulfilled</code>和<code>rejected</code>，<code>fulfilled</code>表示Promise处于完成状态，<code>rejected</code>表示Promise处于被拒绝状态，这两种状态都是Promise的<code>已决议</code>状态，相反如果Promise还未被<code>决议</code>，它就处于<code>未决议</code>状态。</p><p>需要强调的一点是，Promise一经决议就无法改变其状态，这使得Promise和它的名字一样：君子一言驷马难追。</p><p>使用Promise对象可以用同步操作的流程写法来表达异步操作，避免了层层嵌套的异步回调，代码也更加清晰易懂，方便维护。用Promise重写读取文件的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseReadSingleFile.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> read = <span class="function"><span class="params">filename</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err)&#123;</span><br><span class="line">    reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">read(<span class="string">'a.txt'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">"err: "</span> + err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果有多个异步操作需要串行执行，且后一个操作需要拿到前一个操作的结果，我们可以在Promise上使用链式调用(Promise chain)，下面是顺序读取两个文件的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseReadMultiFiles.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> read = <span class="function"><span class="params">filename</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err)&#123;</span><br><span class="line">    reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(<span class="string">'a.txt'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="string">'b.txt'</span>); <span class="comment">// 注意这里：在then中返回一个Promise</span></span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">"err: "</span> + err);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">"err: "</span> + err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在可以大致总结一下用Promise写串行异步程序的基本模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func1()</span><br><span class="line">.then(<span class="function"><span class="params">result1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> func2(result1);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result2</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> func3(result2);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result3</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> func4(result3);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>then里的参数是可选的，这里的<code>.catch(errCallback)</code>其实是<code>then(null, errCallback)</code>的缩写形式。需要注意的是，如果想要在then的fulfilled中获取上一个Promise中的结果，上一个Promise中必要显式返回结果。</p><p>catch之后还可以继续链式调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// catch1.js</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Initial'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Something failed'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Do something'</span>); <span class="comment">// never reach here!</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'Catch error'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Do this whatever happened before'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> babel-node catch1.js</span></span><br><span class="line">Initial</span><br><span class="line">Catch error</span><br><span class="line">Do this whatever happened before</span><br></pre></td></tr></table></figure><p>一个Promise链式调用在遇到错误时会立即停止，此时如果在该出错的then之后有catch（不管这个catch是否紧跟在出错then之后），这个catch里的errCallback都会被调用，出错then和catch中间的所有then都会被忽略：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// catch2.js</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Initial'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Something failed'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Do this'</span>); <span class="comment">// never reach here!</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Skip this'</span>); <span class="comment">// never reach here!</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'Catch error'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Final'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> babel-node catch2.js</span></span><br><span class="line">Initial</span><br><span class="line">Catch error</span><br><span class="line">Final</span><br></pre></td></tr></table></figure><p>在实际编程中，如果我们将一系列异步操作使用Promise链串行执行，意味着这一串操作是一个整体。一旦整体操作中的某个步骤出错，都不应该继续执行下去了。此时我们可以把catch放在Promise链的最后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// catch3.js</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Initial'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Do something 1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Do something 2 failed'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Do something 2'</span>); <span class="comment">// never reach here!</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Do something 3'</span>); <span class="comment">// never reach here!</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">`Catch error: <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> babel-node catche.js</span></span><br><span class="line">Initial</span><br><span class="line">Do something 1</span><br><span class="line">Catch error: Error: Do something 2 failed</span><br></pre></td></tr></table></figure><p>这么做的好处显而易见，这符合软件工程中的<a href="https://www.martinfowler.com/ieeeSoftware/failFast.pdf" target="_blank" rel="noopener">Fail Fast</a>。</p><h4 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h4><p>将setTimeout函数Promise化。</p><p>解析：</p><p>setTimeout是一个旧式的异步API，它接受一个回调和一个时间参数。在ES 6以后写异步代码，强烈不建议直接调用旧式的异步API，应该把这些API都包装成Promise，并且永远不要在业务代码中直接调用这些旧式异步API。为什么不建议这么做？一个很重要的原因对异常的捕获会有问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setTimeoutError.js</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'This is an error!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  setTimeout(fn, <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err); <span class="comment">// never reach here!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里try/catch块无法捕获到<code>fn</code>中的异常。</p><p>参考代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timerPromise.js</span></span><br><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">delay(<span class="number">5000</span>)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'here'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure><p>运行这段代码，<code>hello</code>会被立即打印，<code>here</code>会在大约5000毫秒后被打印：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> babel-node timerPromise.js</span></span><br><span class="line">hello</span><br><span class="line">here</span><br></pre></td></tr></table></figure><p>回到刚才说到的异常捕获问题，将setTimeout包装成Promise后，我们就可以捕获到异常了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timerPromiseCatch.js</span></span><br><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">delay(<span class="number">5000</span>)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'This is an error!'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err); <span class="comment">// Error: This is an error!</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Promise-API"><a href="#Promise-API" class="headerlink" title="Promise API"></a>Promise API</h4><h5 id="Promise-resolve-和-Promise-reject"><a href="#Promise-resolve-和-Promise-reject" class="headerlink" title="Promise.resolve() 和 Promise.reject()"></a>Promise.resolve() 和 Promise.reject()</h5><p>使用Promise.resolve()可以立即得到一个已经resolve的Promise，这里有两种情况，如果入参本身就是一个Promise，则Promise.resolve()原样返回这个Promise，如果入参是一个立即值（比如一个整型），那么Promise.resolve()会将这个立即值包装成Promise然后返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseResolve.js</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1); <span class="comment">// Promise &#123; 100 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p2); <span class="comment">// Promise &#123; 200 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="built_in">Promise</span>.resolve(p2);</span><br><span class="line"><span class="built_in">console</span>.log(p3); <span class="comment">// Promise &#123; 200 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 === p3); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>使用Promise.reject()则是可以立即得到一个已经reject的Promise，其使用方式和Promise.resolve()类似。</p><h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h5><p>Promise.all()接受一个Promise的数组，而且会<code>并行地</code>处理数组中的所有Promise：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseAll.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> read = <span class="function"><span class="params">filename</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err)&#123;</span><br><span class="line">    reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = read(<span class="string">'a.txt'</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = read(<span class="string">'b.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> results = <span class="built_in">Promise</span>.all([p1, p2]);</span><br><span class="line">results</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// [ 'file a content', 'file b content' ]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise.all()会返回一个promise，这个promise会收到一个完成消息，这是一个由所有传入的promise的完成消息组成的数组，该数组中元素的顺序与传入时的元素顺序一致，与每个promise的完成时间无关。从Promise.all()返回的这个promise只有在所有的成员promise<code>完成</code>后才会完成。如果这些成员promise中有一个被拒绝的话，Promise.all()返回的promise就会立即被拒绝，并丢弃所有其他promise的全部结果。</p><p>看一个例子，如果其中某个promise决议后为拒绝状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseAllWithReject.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> read = <span class="function"><span class="params">filename</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err)&#123;</span><br><span class="line">    reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = read(<span class="string">'a.txt'</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = read(<span class="string">'b.txt'</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'This is an error!'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> results = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br><span class="line">results</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// never reach here!</span></span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err); <span class="comment">// Error: This is an error!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>请记住为每个promise都关联一个拒绝处理函数。</p><p>刚才提到只有Promise.all()中的所有成员promise都已完成，其返回的promise的状态返回是已完成。也就是说，Promise.all()调用的完成时间取决于最慢完成的那个promise。一个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseAllTime.js</span></span><br><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = delay(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = delay(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Time consuming: <span class="subst">$&#123;end - start&#125;</span>ms`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> babel-node promiseAllTime.js</span></span><br><span class="line">Time consuming: 5002ms</span><br></pre></td></tr></table></figure><p>简而言之，Promise.all()会协调所有promise的运行。</p><h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h5><p>Promise.race()接收一个promise数组，这些promise之间是<code>竞争</code>关系，哪个先完成就返回哪个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseRace.js</span></span><br><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  delay(<span class="number">1000</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> resolve(<span class="number">100</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  delay(<span class="number">5000</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> resolve(<span class="number">200</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// 100</span></span><br><span class="line">  <span class="keyword">const</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Time consuming: <span class="subst">$&#123;end - start&#125;</span>ms`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里p1和p2各延迟了1000ms和5000ms，分别返回100和200，使用Promise.race()只会得到先完成的p1的值，而p2会被丢弃。</p><p>Promise.race()的一种典型用法就是为一个可能耗时较长的异步操作设置一个超时，如果我们希望针对某个异步操作设置一个超时时间，如果超时了，就拒绝这个异步操作的状态，可以这么处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseRaceTimeout.js</span></span><br><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout = <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Time out!'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  delay(<span class="number">1000</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> resolve(<span class="number">100</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  delay(<span class="number">5000</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> resolve(<span class="number">200</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, timeout(<span class="number">3000</span>)]);</span><br><span class="line">p</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// 100</span></span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p_ = <span class="built_in">Promise</span>.race([p2, timeout(<span class="number">3000</span>)]);</span><br><span class="line">p_</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err); <span class="comment">// Error: Time out!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里p1需要1000ms才能完成，p2需要5000ms，超时定时器统一设置成了3000ms，因此<code>Promise.race([p1, timeout(3000)])</code>会得到已经完成的p1的值（100），<code>Promise.race([p2, timeout(3000)])</code>会得到一个超时的结果，在then的reject中可以拿到这个异常。当然，如果在超时定时器超时之前已经有promise被拒绝的话，Promise.race()会直接变成拒绝状态。</p><p>Promise API还有其他几个变体：</p><ul><li>Promise.none() 和Promise.all()相反，要求所有promise都要被拒绝，然后将拒绝转化成完成值。</li><li>Promise.any() 会忽略拒绝，只要有一个promise完成，整体的状态即为完成。</li><li>Promise.first() 只要第一个promise完成，它就会忽略后续promise的任何完成和拒绝。</li><li>Promise.last() 类似于Promise.first()，但条件变为只有最后一个promise完成胜出。</li></ul><p>对这个四个Promise API有兴趣的同学可以自己做做实验，这里不再深入讲解。</p><h5 id="then-和catch"><a href="#then-和catch" class="headerlink" title="then()和catch()"></a>then()和catch()</h5><p>刚才已经提到过，使用then()和catch()可以形成Promise调用链，这里快速总结一下它们的使用方法：</p><ul><li>p.then(fulfilled);</li><li>p.then(fulfilled, rejected);</li><li>p.catch(rejected); // 等价于 p.then(null, rejected);</li></ul><h4 id="包装旧式异步API"><a href="#包装旧式异步API" class="headerlink" title="包装旧式异步API"></a>包装旧式异步API</h4><p>可能项目中有一些遗留代码还在使用旧式异步API，如果我们要将这部分代码Promise化，最好是有比较好用的工具，下面的polyfill可以帮助你Promise化旧式异步API：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseWrapper.js</span></span><br><span class="line"><span class="keyword">const</span> promiseWrapper = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>); <span class="comment">// convert arguments to a real array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> cb = <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(data);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promiseWrapper.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> read = promiseWrapper(fs.readFile);</span><br><span class="line"></span><br><span class="line">read(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>read是经过Promise化的fs.readFile，调用read会返回一个Promise，一切和我们想象的一致。不过这样用有一个前提条件，原来的旧式异步API必须是<a href="http://nodejs.cn/api/errors.html#errors_error_first_callbacks" target="_blank" rel="noopener">error-first</a>的，好消息是大多数Node.js核心API都是error-first的。</p><h4 id="Promise的局限性"><a href="#Promise的局限性" class="headerlink" title="Promise的局限性"></a>Promise的局限性</h4><ol><li>不可取消。</li><li>不可打断。</li><li>一经决议就不可变。</li></ol><h3 id="迭代器-Iterator-和生成器-Generator"><a href="#迭代器-Iterator-和生成器-Generator" class="headerlink" title="迭代器(Iterator)和生成器(Generator)"></a>迭代器(Iterator)和生成器(Generator)</h3><p>ES 6中引入了生成器函数(Generator Function)。生成器函数用<code>function *</code>定义。它和普通函数相比有一些有意思的特性。</p><p>用一个简单的例子来展示生成器函数的工作方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generator.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">10</span> * (<span class="keyword">yield</span> <span class="string">'world'</span>);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = generator();</span><br><span class="line"><span class="keyword">let</span> res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'pause here'</span>);</span><br><span class="line"></span><br><span class="line">res = it.next(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 40, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> babel-node generator.js</span></span><br><span class="line">hello</span><br><span class="line">&#123; value: 'world', done: false &#125;</span><br><span class="line">pause here</span><br><span class="line">&#123; value: 40, done: true &#125;</span><br></pre></td></tr></table></figure><p>上面代码段定义了一个生成器函数，这里重要的是它的执行流程：</p><ol><li>调用一个生成器函数（就像调用普通函数那样）并不会立即开始执行这个生成器内部的代码，而是返回一个它的迭代器。因此<code>generator();</code>实际上返回了一个迭代器。</li><li>接着<code>let res = it.next();</code>这行代码使生成器函数开始执行，打印<code>hello</code>。当遇到<code>yield</code>时，生成器会暂停，交出控制权。这里打印res会发现其内容为<code>{ value: &#39;world&#39;, done: false }</code>，value是生成器内部的yield出的值，如果yield后面没有东西，这个value就是<code>undefined</code>，<code>done</code>为<code>false</code>表示生成器还未执行完毕。</li><li><code>console.log(&#39;pause here&#39;);</code>这行代码是我们在生成器暂停期间插入的一段执行逻辑。刚才提到，在生成器暂停期间会交出控制权，因此控制权又回到外部。</li><li>语句<code>res = it.next(4);</code>将使生成器继续运行，直到遇到下一个yield，而且这次传入了4，通过<code>next()</code>传入的值会使得yield获取这个值，所以在生成器内部x的值就是40（10*4）。再次观察res为<code>{ value: 40, done: true }</code>，由于生成最终返回x，所value就是40，done也变为<code>true</code>了，说明生成器执行完毕。</li></ol><p>通过解析这段代码我们可以发现几个很有意思的事情：</p><ol><li>生成器内部可以通过yield主动交出控制权，使控制权回到调用方。</li><li>yield后面可以有值，有值得yield会将这个值<code>返回</code>出来。</li><li>可以通过<code>next()</code>将值传入生成器中，该值将作为对应yield的值。</li><li>调用<code>next()</code>后，会获得一个结果，这个结果包含两个值，<code>value</code>表示当前yield的执行结果（或者return的结果）<code>done</code>表示生成器执行状态的信息：true/false分别表示执行完毕和还未执行完毕。</li><li>生成器通过<code>yeild</code>和<code>next</code>使得外部和生成器内部的通信称为可能。</li></ol><p>看到这里可能有人要问了，这有什么用呢？和Promise相比有什么好处？请慢慢往下看。</p><p>还有一种场景，假设我们要获得一个无限的自然数序列，从小到大一次取出一个来用。由于自然数是无限的，我们不可能一次性用一个数组将它们都生成出来（时间上不允许，空间上也不允许），其实也没有必要。我们只需要在需要获取一个自然数的时候生成出一个就好了。这时使用生成器再合适不过：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// numberGenerator.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">numberGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = numberGenerator();</span><br><span class="line"><span class="keyword">let</span> res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br></pre></td></tr></table></figure><p>由于生成器里面是一个无限while循环，所以<code>done</code>一直是<code>false</code>。</p><p>使用生成器函数需要注意一点，在获得生成器函数的迭代器后，第一次调用其<code>next()</code>方法时不需要传参数（尽管你可以这么做）。因为此时还没遇到yield，传了也没意义。</p><h4 id="生成器函数的错误处理"><a href="#生成器函数的错误处理" class="headerlink" title="生成器函数的错误处理"></a>生成器函数的错误处理</h4><p>可以直接在生成器函数中使用try/catch捕获异常：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generatorCatchError.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> x = (<span class="keyword">yield</span> <span class="string">'world'</span>)();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err); <span class="comment">// TypeError: (intermediate value) is not a function</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = generator();</span><br><span class="line">it.next();</span><br><span class="line"><span class="keyword">const</span> res = it.next(<span class="string">'bar'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>由于上面的代码段中有异常，被catch捕获，没有显式调用return语句，所以默认返回值是undefined。</p><p>想停止一个生成器函数只需要调用其迭代器的<code>return</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generatorStop.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">numberGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = numberGenerator();</span><br><span class="line"><span class="keyword">let</span> res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">res = it.return(); <span class="comment">// stop generator</span></span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>回想Promise部分介绍的链式Promise，虽然避免了嵌套回调问题，但是一连串.then()也让人挺烦的，如果能真正像写同步代码那样写串行异步代码那该多好。实际上使用生成器函数已经可以做到这点。但是为了更好地理解后面的内容，这里还有几个准备工作要做。我们知道在生成器函数中yield一个值的时候，外部可以通过next()拿到这个值，刚才的代码中yield后面都是立即值，如果把这个值换成一个异步函数会怎样？</p><p>很自然地，我们会想让代码变成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generatorReadFileBadExample.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generator</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> file1 = <span class="keyword">yield</span> fs.readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(file1); <span class="comment">// undefined</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = generator();</span><br><span class="line"><span class="keyword">let</span> res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: undefined, done: false &#125;</span></span><br><span class="line">res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>但很可惜的是，这样做并不奏效，为什么？</p><h4 id="小练习-1"><a href="#小练习-1" class="headerlink" title="小练习"></a>小练习</h4><p>思考一下为什么上面这段代码不能工作？</p><p>解析：</p><p>其实仔细思考yield的行为就会发现，<code>fs.readFile</code>是一个旧式的异步API，调用它会立即返回undefined，如果没有传入一个回调函数给它，我们无法获得任何信息。那么问题来了，如果还要在生成器函数里调用fs.readFile时传入回调函数，那不是又回到解放前了吗，我们可不想再直接去面对赤裸裸地回调函数。也就是说，将fs.readFile直接在生成器内部执行是不可能的了，那么只能将fs.readFile的执行放到生成器函数外部，换句话说，我们要将fs.readFile连同它的参数通过yield<code>传递</code>到外部去执行，我们需要包装一下fs.readFile。将一个函数和一堆参数绑定后塞入另一个新的函数里，叫函数的<a href="https://zh.wikipedia.org/zh/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="noopener">柯里化(currying)</a>，换一种更通俗易懂的讲法：我们把一堆参数固定到一个函数上。</p><p>由于在JavaScript中函数是一等对象，所以借助高阶函数的抽象功能，可以写一个帮助方法来对任意在最后一个参数上为回调函数的异步API进行柯里化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thunkify.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunkify = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line">readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>)(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// file a content</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们来尝试一下将柯里化后的旧式异步API和生成器函数结合使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generatorReadFile1.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunkify = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generator</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> file1 = <span class="keyword">yield</span> readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(file1); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">const</span> file2 = <span class="keyword">yield</span> readFile(<span class="string">'b.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(file2); <span class="comment">// undefined</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = generator();</span><br><span class="line"><span class="keyword">let</span> res = it.next();</span><br><span class="line">res.value(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// file a content</span></span><br><span class="line">&#125;);</span><br><span class="line">res = it.next();</span><br><span class="line">res.value(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// file b content</span></span><br><span class="line">&#125;);</span><br><span class="line">res = it.next();</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>第一次调用next()时，我们从其value中得到了柯里化后的fs.readFile，我们叫它readFile。readFile接受一个回调函数，因此只要传入回调我们就能获得异步调用的结果。很好，我们的第一步目的达到了。但是仔细一看，还是有问题：在生成器函数中我们打印file1和file2结果都是undefined，生成器函数在交出控制权后，控制权转移到外部，异步调用也在外部完成，异步调用的结果也在外面。没关系，我们可以通过<code>next(value)</code>将这个异步调用结果带回给生成器函数内部：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generatorReadFile2.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunkify = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> file1 = <span class="keyword">yield</span> readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'got '</span> + file1); <span class="comment">// got file a content</span></span><br><span class="line">  <span class="keyword">const</span> file2 = <span class="keyword">yield</span> readFile(<span class="string">'b.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'got '</span> + file2); <span class="comment">// got file b content</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = generator();</span><br><span class="line"><span class="keyword">let</span> res = it.next();</span><br><span class="line">res.value(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  res = it.next(data);</span><br><span class="line">  res.value(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    res = it.next(data);</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>非常好，我们成功地将异步调用的结果又传回给生成器函数，问题到这一步应该说已经基本解决了。说基本解决是因为调用方式还没有自动化，还需要手动一步步调用<code>res.value(cb)</code>，再次发挥JavaScript高阶函数的强大威力，写一个自动执行生成器函数的工具吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generatorAutoRunner.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunkify = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> file1 = <span class="keyword">yield</span> readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'got '</span> + file1); <span class="comment">// got file a content</span></span><br><span class="line">  <span class="keyword">const</span> file2 = <span class="keyword">yield</span> readFile(<span class="string">'b.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'got '</span> + file2); <span class="comment">// got file b content</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> run = <span class="function"><span class="params">g</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> it = g();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = it.next(data);</span><br><span class="line">    <span class="keyword">if</span> (res.done) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.value;</span><br><span class="line">    &#125;</span><br><span class="line">    res.value(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run(generator);</span><br></pre></td></tr></table></figure><p>自动运行生成器函数的原理很简单，在生成器函数的迭代器上执行next时，返回的是一个柯里化后的异步函数，我们需要调用这个异步函数，同时传入一个参数，这个参数是一个回调函数，它是自动执行的关键，该回调函数内部在获取到结果值的时候，需要调用next方法将这个结果值带回给生成器函数内部，如此循环下去直到结束。</p><h5 id="yield-语句"><a href="#yield-语句" class="headerlink" title="yield *语句"></a>yield *语句</h5><p>普通的yield语句后面跟一个异步操作，yield <em>语句后面可以跟另一个可迭代对象，在实际使用中yield </em>后面一般要跟另一个Generator函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunkify = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = thunkify(fs.readFile);</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f1); <span class="comment">// file a content</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> f_ = <span class="keyword">yield</span> *anotherGenerator(); <span class="comment">//此处插入了另外一个异步流程</span></span><br><span class="line">  <span class="built_in">console</span>.log(f_); <span class="comment">// file c content</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">yield</span> readFile(<span class="string">'b.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f3); <span class="comment">// file b content</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> anotherGenerator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">yield</span> readFile(<span class="string">'c.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> it = g();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> result = it.next(data);</span><br><span class="line"><span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line">result.value(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">next();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">run(generator);  <span class="comment">//自动执行</span></span><br></pre></td></tr></table></figure><p>在使用生成器函数作为异步控制流的时期，业界比较流行的自动执行的解决方案是co库：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// co1.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunkify = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> file1 = <span class="keyword">yield</span> readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'got '</span> + file1); <span class="comment">// got file a content</span></span><br><span class="line">  <span class="keyword">const</span> file2 = <span class="keyword">yield</span> readFile(<span class="string">'b.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'got '</span> + file2); <span class="comment">// got file b content</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还可以直接利用co库并发地执行一系列操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// co2.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunkify = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> files = [<span class="string">'a.txt'</span>, <span class="string">'b.txt'</span>];</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">yield</span> files.map(<span class="function"><span class="params">file</span> =&gt;</span> readFile(file, <span class="string">'utf8'</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// [ 'file a content', 'file b content' ]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还可以用yield并发地执行一个可迭代对象中的异步操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// coWithArray.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunkify = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> files = [<span class="string">'a.txt'</span>, <span class="string">'b.txt'</span>];</span><br><span class="line">  <span class="keyword">const</span> results = <span class="keyword">yield</span>* files.map(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readFile(file, <span class="string">'utf8'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(results); <span class="comment">// [ 'file a content', 'file b content' ]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>直到ES 7中出现async/await之前，业界普遍都是采用co库的方案。</p><p>async和await是ES 7中的新语法，新到连ES 6都不支持，但是可以通过Babel一类的预编译器处理成ES 5的代码。目前比较一致的看法是async和await是js对异步的终极解决方案。要注意的一个点是，await只能用在async函数中，但async函数中未必一定要有await。</p><p>立即尝试看看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async.js</span></span><br><span class="line"><span class="keyword">const</span> promiseWrapper = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [].slice.call(<span class="built_in">arguments</span>); <span class="comment">// convert arguments to a real array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> cb = <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(data);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, args.concat(cb));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = promiseWrapper(fs.readFile);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'a.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"><span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'b.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f1); <span class="comment">// file a content</span></span><br><span class="line"><span class="built_in">console</span>.log(f2); <span class="comment">// file b content</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">asyncReadFile();</span><br></pre></td></tr></table></figure><p>如果不加<code>await</code>调用<code>async</code>函数，该异步函数将像旧式异步函数那样直接返回，也就是说，后面的代码不会等待该异步函数执行完毕，看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async-without-await.js</span></span><br><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> demo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  delay(<span class="number">5000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - start&#125;</span>ms --- a`</span>);</span><br><span class="line">  <span class="keyword">await</span> delay(<span class="number">5000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - start&#125;</span>ms --- b`</span>);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">demo();</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0ms --- a</span><br><span class="line">5006ms --- b</span><br></pre></td></tr></table></figure><h3 id="使用事件进行异步编程"><a href="#使用事件进行异步编程" class="headerlink" title="使用事件进行异步编程"></a>使用事件进行异步编程</h3><p>除了回调函数、Promise、Generator、async/await这些异步方案以外，还有一种常见的异步方案：事件。在Node.js中使用事件编程十分简单，下面是一个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event.js</span></span><br><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">'news'</span>, payload =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(payload.data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">'logout'</span>, payload =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`User logout: <span class="subst">$&#123;payload.data&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventEmitter.emit(<span class="string">'news'</span>, &#123; <span class="attr">data</span>: <span class="string">'Hello world!'</span>&#125;);</span><br><span class="line">eventEmitter.emit(<span class="string">'logout'</span>, &#123; <span class="attr">data</span>: <span class="string">'Foo'</span>&#125;);</span><br></pre></td></tr></table></figure><p>事件的一大特定是它的解耦能力，事件相比方法调用的耦合度要低一些。在一些业务场景下，模块之间可以通过事件来解耦。</p><h2 id="常用的异步编程库"><a href="#常用的异步编程库" class="headerlink" title="常用的异步编程库"></a>常用的异步编程库</h2><p><a href="https://github.com/caolan/async" target="_blank" rel="noopener">async</a><br><a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="noopener">bluebird</a><br><a href="https://github.com/tj/co" target="_blank" rel="noopener">co</a></p><h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p><a href="/2018/10/11/[译]深入理解Node.js的事件循环、定时器和process.nextTick/">(译)深入理解Node.js的事件循环、定时器和process.nextTick()</a><br><a href="https://www.martinfowler.com/ieeeSoftware/failFast.pdf" target="_blank" rel="noopener">Fail Fast</a><br><a href="http://nodejs.cn/api/errors.html#errors_error_first_callbacks" target="_blank" rel="noopener">error-first</a><br><a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">Promise/A+规范</a><br><a href="https://zh.wikipedia.org/zh/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="noopener">柯里化(currying)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将深入解析node.js的异步世界（本文比较长，请准备好瓜子和可乐）。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="https://nullcc.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="js" scheme="https://nullcc.github.io/tags/js/"/>
    
      <category term="node" scheme="https://nullcc.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>AOP in JavaScript and TypeScript</title>
    <link href="https://nullcc.github.io/2018/10/28/AOP_in_JavaScript_and_TypeScript/"/>
    <id>https://nullcc.github.io/2018/10/28/AOP_in_JavaScript_and_TypeScript/</id>
    <published>2018-10-27T16:00:00.000Z</published>
    <updated>2022-04-15T03:41:13.013Z</updated>
    
    <content type="html"><![CDATA[<p>Write something about aop in JavaScript and TypeScript.</p><a id="more"></a><h2 id="AOP-Overview"><a href="#AOP-Overview" class="headerlink" title="AOP Overview"></a>AOP Overview</h2><p>Aspect Oriented Programming (AOP), Chinese meaning is “面向切面编程”. We can separate parts of business logic with AOP to reduce coupling of them.</p><p>Let’s image a very common situation, beside execute necessary automated operations, we also need to do something like logging, save screenshot when we use selenium-webdriver to do web automated testing. It is obvious that these operations is not strongly related with business logic, but we sure need them. Now the situation is that we need these functions but we no hope to include these code explicitly in modeling stage. So we want a new way to reslove it.</p><p>For example, we want to recode time consuming and take a screenshot after every step in web automated testing. The simplest way is to put the code which record time consuming and take a screenshot in every step. But disadvantages of this approach is if we have many step, things will become uncontrollable. It’s impossible to maintain thousands of steps which there are lots of similar code in every step.</p><p>AOP makes it possible to resolve this problem elegantly.</p><h2 id="AOP-vs-OOP"><a href="#AOP-vs-OOP" class="headerlink" title="AOP vs OOP"></a>AOP vs OOP</h2><p>We are familiar with Object Oriented Programming (OOP). When we get a requirements, firstly we analyze the requirements and extract some domain models. Every domain model has its own attributes and methods. People using encapsulation, composition, inheritance, polymorphism and design patterns to building software and practice the thinking of OOP.</p><p>If you have experiences about building software with OOP you will find that OOP is to model static things. In other words, OOP is for nouns. For example, we have a <code>Employee</code> class with attributes <code>name</code>, <code>age</code>, <code>title</code> and <code>department</code>, with methods <code>work</code>, <code>takeABreak</code> and <code>loginAdminSystem</code>. Attributes describe characteristics of objects, and methods are the operations objects can execute. Base on these, we can write some OO code:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> age: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> title: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> department: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, title: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">    <span class="keyword">this</span>.department = department;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> work() &#123;</span><br><span class="line">    <span class="comment">// code for working...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> takeABreak() &#123;</span><br><span class="line">    <span class="comment">// code for taking a break...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> loginAdminSystem() &#123;</span><br><span class="line">    <span class="comment">// code for logining admin system, it's a sensitive operation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> employee = <span class="keyword">new</span> Employee(<span class="string">'Bob'</span>, <span class="number">35</span>, <span class="string">'Software Development Engineer'</span>, <span class="string">'Devlopment'</span>);</span><br><span class="line">employee.work();</span><br><span class="line">employee.takeABreak();</span><br></pre></td></tr></table></figure><p>Above code is strong related with Employee class which form the business logic. There is no doubt that, OOP is very suitable for describing objects.</p><p>But sometime we may want some more “dynamic” things, such as we hope to logging while user is executing a sensitive operation. If we choose OOP implementation, we must modify the code of the sensitive operation <code>loginAdminSystem</code> to add logging code to it. Like this:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> loginAdminSystem() &#123;</span><br><span class="line">  <span class="comment">// added: code for logging some information</span></span><br><span class="line">  <span class="comment">// code for logining admin system</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>It’s work of course, but no elegant. Actually it againsts OCP (open closed principle). Logging are not strongly correlated with the sensitive operation above. We had better do not to modify business logic to add logging feature. </p><p>But how to reslove it? We can try AOP. Simplely, we can expose two sections in specific operation: one before it and another after it, then weave in other functions dynamically in runtime. That is to say AOP is for verbs. Our code will become more elegant and extendable with the cooperation of OOP and AOP.</p><p>A simple example: function wrapping. Assume we have a function <code>op</code>, we want to logging something before and after it:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let op = () =&gt; &#123;</span><br><span class="line">  console.log(&apos;executing op...&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let oriOp = op;</span><br><span class="line"></span><br><span class="line">op = () =&gt; &#123;</span><br><span class="line">  console.log(&apos;before op...&apos;);</span><br><span class="line">  oriOp();</span><br><span class="line">  console.log(&apos;after op...&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This time we wrap the function instead of modifying it.</p><p>AOP code in project is more complex than code above. Basically we need some meta programming technique to support AOP. But the basic principle is similar with code above. It is worth mentioning that AOP is a programming concept, but not own by a specific programming language. Most of programming languages can be written in AOP way.</p><h2 id="Solution-1-Simple-Method-Hooks"><a href="#Solution-1-Simple-Method-Hooks" class="headerlink" title="Solution 1 - Simple Method Hooks"></a>Solution 1 - Simple Method Hooks</h2><p>Solution 1 use hooks (before/after action) to wrap original method to new method, we put the auxiliary functions in hooks.<br>See <a href="https://github.com/nullcc/ts-aop-example/blob/master/src/driver/methodHook/base.ts" target="_blank" rel="noopener">base driver</a> and <a href="https://github.com/nullcc/ts-aop-example/blob/master/src/driver/methodHook/methodHook.ts" target="_blank" rel="noopener">method hook driver</a>.</p><p>Issues: It’s difficult to handle relationship between before action and after action. For example, if we want to record time consuming of an action, the before action and after action will be:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before action</span></span><br><span class="line"><span class="keyword">const</span> recordStartTime = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="keyword">return</span> start;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after action</span></span><br><span class="line"><span class="keyword">const</span> recordEndTime = <span class="keyword">async</span> start =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="keyword">const</span> consume = end - start;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`time consume: <span class="subst">$&#123;consume&#125;</span>ms`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>and <code>registerHooksForMethods</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> registerHooksForMethods(</span><br><span class="line">    methods: <span class="built_in">string</span>[],</span><br><span class="line">    beforeAction: <span class="built_in">Function</span>,</span><br><span class="line">    afterAction: <span class="built_in">Function</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    methods.forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> originalMethod = self[method]; <span class="comment">// original method reference</span></span><br><span class="line">      <span class="keyword">if</span> (originalMethod) &#123;</span><br><span class="line">        self[method] = <span class="keyword">async</span> (...args) =&gt; &#123; <span class="comment">// wrap original method</span></span><br><span class="line">          <span class="keyword">const</span> beforeActionRes = <span class="keyword">await</span> beforeAction();</span><br><span class="line">          <span class="keyword">const</span> methodRes = <span class="keyword">await</span> originalMethod.call(self, ...args);</span><br><span class="line">          <span class="keyword">await</span> afterAction(beforeActionRes, methodRes);</span><br><span class="line">          <span class="keyword">return</span> methodRes;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>As you can see above, in <code>registerHooksForMethods</code> method, we have to get the return value of before action and pass it to after action which implementation is ugly and inflexible.</p><p>So, we give up this solution even it may work.</p><h2 id="Solution-2-Static-Onion-Model"><a href="#Solution-2-Static-Onion-Model" class="headerlink" title="Solution 2 - Static Onion Model"></a>Solution 2 - Static Onion Model</h2><p>Let’s look at an interesting model first: middleware onion model in <a href="https://koajs.com/" target="_blank" rel="noopener">Koa</a>:</p><p><img src="/assets/images/post_imgs/koa_onion.png" alt="Koa middileware onion model"></p><p>See <a href="https://github.com/nullcc/ts-aop-example/blob/master/src/driver/staticOnion/base.ts" target="_blank" rel="noopener">base driver</a> and <a href="https://github.com/nullcc/ts-aop-example/blob/master/src/driver/staticOnion/staticOnion.ts" target="_blank" rel="noopener">static onion driver</a>.</p><p>Static onion model is much better than method hook. It use onion model to reslove issues in method hook solution. We use a decorator to decorate methods:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decorator</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> webDriverMethod = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, methodName: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> desc = &#123;</span><br><span class="line">      value: <span class="string">"webDriverMethod"</span>,</span><br><span class="line">      writable: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target[methodName], <span class="string">"__type__"</span>, desc);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in BaseWebDriver class, a web driver method</span></span><br><span class="line"><span class="meta">@webDriverMethod</span>()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> findElement(</span><br><span class="line">  by: By,</span><br><span class="line">  ec: <span class="built_in">Function</span> = until.elementLocated,</span><br><span class="line">  timeout: <span class="built_in">number</span> = <span class="number">3000</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">this</span>.webDriver.wait(ec(by), timeout);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.webDriver.findElement(by);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Call <code>use</code> method to add a middleware:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> use(middleware) &#123;</span><br><span class="line">  <span class="keyword">const</span> webDriverMethods = <span class="keyword">this</span>.getWebDriverMethods();</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> method of webDriverMethods) &#123;</span><br><span class="line">    <span class="keyword">const</span> originalMethod = <span class="keyword">this</span>[method];</span><br><span class="line">    <span class="keyword">if</span> (originalMethod) &#123;</span><br><span class="line">      <span class="keyword">this</span>[method] = <span class="keyword">async</span> (...args) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> result;</span><br><span class="line">        <span class="keyword">const</span> ctx = &#123;</span><br><span class="line">          methodName: method,</span><br><span class="line">          args</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">await</span> middleware(ctx, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">          result = <span class="keyword">await</span> originalMethod.call(self, ...args);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// check this: we must decorate new method every time when adding a middleware</span></span><br><span class="line">      <span class="keyword">this</span>.decorate(<span class="keyword">this</span>[method]); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> decorate(method) &#123;</span><br><span class="line">  <span class="keyword">const</span> desc = &#123;</span><br><span class="line">    value: <span class="string">"webDriverMethod"</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(method, <span class="string">"__type__"</span>, desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>But there is a little disadvantage: We must decorate new method every time when adding a middleware. In order to avoid this, we can wrap the method in runtime dynamically. Let’s move on to Solution 3.</p><h2 id="Solution-3-Dynamic-Onion-Model"><a href="#Solution-3-Dynamic-Onion-Model" class="headerlink" title="Solution 3 - Dynamic Onion Model"></a>Solution 3 - Dynamic Onion Model</h2><p>See <a href="https://github.com/nullcc/ts-aop-example/blob/master/src/driver/dynamicOnion/base.ts" target="_blank" rel="noopener">base driver</a> and <a href="https://github.com/nullcc/ts-aop-example/blob/master/src/driver/dynamicOnion/dynamicOnion.ts" target="_blank" rel="noopener">dynamic onion driver</a>.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> DynamicOnionWebDriver <span class="keyword">extends</span> BaseWebDriver &#123;</span><br><span class="line">  <span class="keyword">protected</span> webDriver: WebDriver;</span><br><span class="line">  <span class="keyword">private</span> middlewares = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">webDriver</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(webDriver);</span><br><span class="line">    <span class="keyword">const</span> methods = <span class="keyword">this</span>.getWebDriverMethods();</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> method of methods) &#123;</span><br><span class="line">      <span class="keyword">const</span> desc = &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">          <span class="keyword">if</span> (methods.includes(method) &amp;&amp; <span class="keyword">this</span>.compose) &#123;</span><br><span class="line">            <span class="keyword">const</span> ctx = &#123; <span class="comment">// put some information in ctx if necessary</span></span><br><span class="line">              methodName: method,</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> originFn = <span class="keyword">async</span> (...args) =&gt; &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">this</span>.methodMap[method].call(self, ...args);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> fn = <span class="keyword">this</span>.compose();</span><br><span class="line">            <span class="keyword">return</span> fn.bind(<span class="literal">null</span>, ctx, originFn.bind(self));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.methodMap[method].bind(<span class="keyword">this</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">          <span class="keyword">this</span>[method] = value;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, method, desc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> use(middleware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> middleware !== <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Middleware must be a function!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.middlewares.push(middleware);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> compose() &#123;</span><br><span class="line">    <span class="keyword">const</span> middlewares = <span class="keyword">this</span>.middlewares;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next, ...args) =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> res;</span><br><span class="line">      <span class="keyword">const</span> dispatch = <span class="keyword">async</span> i =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> fn = middlewares[i];</span><br><span class="line">        <span class="keyword">if</span> (i === middlewares.length) &#123;</span><br><span class="line">          fn = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (i === middlewares.length) &#123;</span><br><span class="line">            res = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(fn.call(self, ...args));</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(ctx, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">await</span> dispatch(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dynamic onion model is much complex than solution 1 and 2. We use <code>Object.defineProperty</code> to define our getter for every method which is taged by <code>webDriverMethod</code> decorator. The <code>compose</code> method is the key to organize all middlewares and the original method, method getter will call <code>compose</code> method when we want to get a method and finally return a wrapped method.</p><p>Dynamic onion model is a little difficult to understand but it is worthy to take your time to learn it.</p><p>BTW: method hook, static onion model and dynamic onion model these names is invented by myself, if you find a better way to describe them, please tell me.</p><h2 id="Example-Repo"><a href="#Example-Repo" class="headerlink" title="Example Repo"></a>Example Repo</h2><p><a href="https://github.com/nullcc/ts-aop-example" target="_blank" rel="noopener">ts-aop-example</a></p><h2 id="Run-tests"><a href="#Run-tests" class="headerlink" title="Run tests"></a>Run tests</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm test</span><br></pre></td></tr></table></figure><h2 id="More-Informations"><a href="#More-Informations" class="headerlink" title="More Informations"></a>More Informations</h2><ul><li><a href="https://www.zhihu.com/question/24863332" target="_blank" rel="noopener">什么是面向切面编程AOP</a></li><li><a href="https://koajs.com/" target="_blank" rel="noopener">Koa Web Framework</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty()</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Write something about aop in JavaScript and TypeScript.&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="https://nullcc.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="js" scheme="https://nullcc.github.io/tags/js/"/>
    
      <category term="aop" scheme="https://nullcc.github.io/tags/aop/"/>
    
  </entry>
  
</feed>
